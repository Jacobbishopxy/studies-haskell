\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{定义并发与并行}

一个\textit{并发}程序需要在同一时刻执行若干不相关的任务。假设一个游戏服务器：它由多个组件构成，每个组件都要与外界进行复杂的交互。某个组件可能是处理多用户聊天；若干个
则是处理用户的输入，并将更新后的状态返回给用户；另外一些则是执行物理计算。

一个并发程序的正确操作并不需要多核，不过多核可以增强性能与响应。

相反的，一个\textit{并行}程序解决单个问题。假设一个金融模型用于预测单个股票下一分钟的价格。如果我们希望将此模型应用在交易所中的每个股票上，例如预计哪只票可以进行买卖，
那么通过五百个核进行计算肯定比一个核计算更能快速的得到一个答案。这种情况下，并行程序通常不依靠多核也能正确工作。

另一个用于区分两者差别的方法在于它们如何与外界进行交互。根据定义，一个并发程序会持续不断地进行网络协议，数据库等处理。而一个典型的并行程序则更为集中：它流式的接受数据，
处理一段时间（进行少许 I/O），然后流式的输出数据。

很多传统语言会模糊这两者之间的边界，因为它们强制程序员使用相同的方式构建这两种程序。

\subsection*{使用线程的并发编程}

作为并发程序的构建块，大多数编程语言都提供了创建多个独立控制线程的方法。Haskell 也不例外，尽管在 Haskell 中使用线程编程看起来与其他语言有些不同。

Haskell 中，一个线程就是一个独立其它线程执行的\acode{IO}操作。要创建一个线程，我们需要导入\acode{Control.Concurrent}模块并使用\acode{forkIO}函数。

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Concurrent
  ghci> :t forkIO
  forkIO :: IO () -> IO ThreadId
  ghci> :m +System.Directory
  ghci> forkIO (writeFile "xyzzy" "seo craic nua!") >> doesFileExist "xyzzy"
  False
\end{lstlisting}

\subsubsection*{线程是不确定的}

GHC 的运行时组件没有指定执行线程的顺序。因此，在上面的示例中，新线程创建的文件\textit{xyzzy}在原始线程检查其存在时可能已经创建，也可能还没有创建。如果我们尝试此
示例一次，然后删除\textit{xyzzy}并再次尝试，那么第二次可能会得到不同的结果。

\subsubsection*{隐藏延迟}

假设有一个很大的文件需要被压缩并写入磁盘，但是又想要迅速的处理用户的输入，使用户感受到程序的快速响应。可以使用\acode{forkIO}在另一个线程中进行文件写入。

\begin{lstlisting}[language=Haskell]
  import Codec.Compression.GZip ( compress )
  import Control.Concurrent (forkIO)
  import Control.Exception (SomeException, handle)
  import qualified Data.ByteString.Lazy as L

  main :: IO ()
  main = do
    putStrLn "Enter a file to compress>"
    name <- getLine
    handle (print :: SomeException -> IO ()) $ do
      content <- L.readFile name
      _ <- forkIO $ compressFile name content
      return ()
    where
      compressFile path = L.writeFile (path ++ ".gz") . compress
\end{lstlisting}

注：原文使用的\acode{readline}库不再适用，另外\acode{print}也需要显式声明类型。

因为这里使用了惰性的\acode{ByteString} I/O，剩下的只需要在主线程中打开文件。实际的读取则是在另一条线程中进行。

\acode{handle print}的使用提供了廉价打印错误信息的方法，例如文件名不存在。

\subsection*{线程间的简单通讯}

在两个线程之间共享信息的最简单方法是让它们都是用一个变量。在我们的文件压缩例子中，主线程与另一个线程共享文件的名称以及内容。因为 Haskell 数据在默认情况下是不可变的，
所以这没有任何的风险：两个线程都不能修改另一个线程所见的文件名或内容。

我们通常需要线程主动地与其他线程进行交互。例如，GHC 并没有为线程提供查看另一个线程是否正在执行、已经完成或是崩溃的方法。不过它提供了一个\textit{同步变量}类型，即
\acode{MVar}，允许我们使用它来达到目的。

\acode{MVar}的作用像是一个单元素的盒子：它要么是满的要么是空的。我们可以将某个东西放入盒子，使其满上，或是拿出使其空置。

\begin{lstlisting}[language=Haskell]
  ghci> import Control.Concurrent
  ghci> :t putMVar
  putMVar :: MVar a -> a -> IO ()
  ghci> :t takeMVar
  takeMVar :: MVar a -> IO a
\end{lstlisting}

如果我们尝试将一个值放入已经满的\acode{MVar}中，线程则会进入睡眠直到其它线程将该值取出。同样的，如果尝试从一个空置的\acode{MVar}中取值，线程也会进入睡眠直到其它的
线程将值放入。

\begin{lstlisting}[language=Haskell]
  import Control.Concurrent

  communicate :: IO ()
  communicate = do
    m <- newEmptyMVar
    _ <- forkIO $ do
      v <- takeMVar m
      putStrLn $ "received" ++ show v
    putStrLn "sending"
    putMVar m "wake up"
\end{lstlisting}

\acode{newEmptyMVar}函数有一个描述性的名称；要创建一个非空的\acode{MVar}则使用\acode{newMVar}。

\begin{lstlisting}[language=Haskell]
  ghci> :t newEmptyMVar
  newEmptyMVar :: IO (MVar a)
  ghci> :t newMVar
  newMVar :: a -> IO (MVar a)
\end{lstlisting}

测试：

\begin{lstlisting}[language=Haskell]
  ghci> :l MVarExample.hs
  [1 of 2] Compiling Main             ( MVarExample.hs, interpreted )
  Ok, one module loaded.
  ghci> communicate
  sending
  received "wake up"
\end{lstlisting}

如果你拥有传统语言中并发编程的经验，那么可以将\acode{MVar}看做是用有两个目的的助力。

\begin{enumerate}
  \item 将一个信息从一个线程发送至另一个线程，例如，消息。
  \item 为线程间共享的可变数据提供\textit{互斥}。当数据没有被任何线程使用时，将其放入\acode{MVar}中，另一个线程将其临时取出进行读取或者修改。
\end{enumerate}

\subsection*{主线程与其它线程的等待}

GHC 的运行时系统将程序的原始控制线程与其它线程区别对待。当该线程完成执行，运行时系统认为程序作为一个整体已经完成。如果又其它线程仍在执行，它们则会被终止。

因此，当我们有不能杀死的长时间运行线程时，我们必须做出特殊安排以确保主线程在其他线程完成之前不会完成。下面是一个小库使其易于实现：

\begin{lstlisting}[language=Haskell]
  import Control.Concurrent
  import Control.Exception
  import Control.Monad
  import Data.Map as M

  data ThreadStatus
    = Running
    | Finished -- terminated normally
    | Threw IOException -- changed from `Exception`
    deriving (Eq, Show)

    -- | Create a new thread manager.
    newManager :: IO ThreadManager

    -- | Create a new managed thread.
    forkManaged :: ThreadManager -> IO () -> IO ThreadId

    -- | Immediately return the status of a managed thread.
    getStatus :: ThreadManager -> ThreadId -> IO (Maybe ThreadStatus)

    -- | Block until a specific managed thread terminates.
    waitFor :: ThreadManager -> ThreadId -> IO (Maybe ThreadStatus)

    -- | Block until all managed threads terminate.
    waitAll :: ThreadManager -> IO ()
\end{lstlisting}

我们使用通常的方法来保持\acode{ThreadManager}类型的抽象：我们将其包装在\acode{newtype}中，并防止用于创建该类型的值。在模块导出中，给出类型构造函数以及
构造管理者的 IO 操作，并不导出数据构造函数。

\begin{lstlisting}[language=Haskell]
  module NiceFork
    ( ThreadManager,
      newManager,
      forkManaged,
      getStatus,
      waitFor,
      waitAll,
    )
  where
\end{lstlisting}

对于\acode{ThreadManager}的实现，我们维护一个从线程 ID 到线程状态的映射：

\begin{lstlisting}[language=Haskell]
  -- Thread map
  newtype ThreadManager
    = Mgr (MVar (M.Map ThreadId (MVar ThreadStatus)))
    deriving (Eq)

  -- Create a new thread manager
  newManager :: IO ThreadManager
  newManager = Mgr <$> newMVar M.empty
\end{lstlisting}

这里有两个级别的\acode{MVar}使用。首先是\acode{Map}，通过替换一个新版本允许我们对其进行“修改”。同时还可以确保使用\acode{Map}的任何线程看到的是一致的视图。

对于管理的每个线程，我们维护一个\acode{MVar}。每个线程的\acode{MVar}开始时为空，即表明线程正在执行。当线程结束或被未捕获的异常杀死时，将该信息放入\acode{MVar}中。

要创建一个线程并观察其状态，我们必须执行一点记录性的操作。

\begin{lstlisting}[language=Haskell]
  -- Create a new managed thread and watch its status
  forkManaged :: ThreadManager -> IO () -> IO ThreadId
  forkManaged (Mgr mgr) body =
    -- safely modify an MVar
    modifyMVar mgr $ \m -> do
      state <- newEmptyMVar
      tid <- forkIO $ do
        result <- try body
        putMVar state $ either Threw (const Finished) result
      return (M.insert tid state m, tid)
\end{lstlisting}

\subsubsection*{安全的修改 MVar}

在上述\acode{forkManaged}中使用的\acode{modifyMVar}函数非常有用：它是一个安全的\acode{takeMVar}与\acode{putMVar}组合。

\begin{lstlisting}[language=Haskell]
  ghci> :t modifyMVar
  ved "wake up!"
  modifyMVar :: MVar a -> (a -> IO (a, b)) -> IO b
\end{lstlisting}

它从\acode{MVar}中取值，将其传递给一个函数。该函数可以同时生成一个新值并返回一个结果。如果该函数抛出异常，那么\acode{modifyMVar}则会将原有值放回\acode{MVar}中，
否则将新值放入其中。它返回函数的另一个元素作为自己的结果。

当我们使用\acode{modifyMVar}而不是通过\acode{takeMVar}与\acode{putMVar}来手动管理一个\acode{MVar}时，我们避免了两种常见的并行错误：

\begin{enumerate}
  \item 忘记将值放回\acode{MVar}。这可能导致\textit{死锁}，在这种情况下，一些线程永远在等待一个永远不会向其放入值的\acode{MVar}。
  \item 未能考虑到抛出异常的可能，从而中断了代码流程。这可能导致\textit{应该}发生的对\acode{putVar}的调用实际上并没有发生，从而再次导致死锁。
\end{enumerate}

因为这些优秀的安全属性，尽可能的使用\acode{mofigyMVar}是一个明智的选择。

我们可以采用\acode{modifyMVar}遵循的模式，将其应用于许多其它资源管理的情况中。以下是该模式的步骤：

\begin{enumerate}
  \item 获取资源
  \item 将资源传递给函数进行处理
  \item 总是释放资源，即使该函数抛出了异常。如果出现这种情况，将异常重新抛出使其能被应用代码捕获。
\end{enumerate}

除了安全之外，这种方法还有另一个好处：它可以使我们的代码更简短且更容易理解。从上面的\acode{forkManaged}中可以看出，Haskell 对于匿名函数的轻量级语法使得这种风格的
编码在视觉上不那么突兀。

以下是\acode{modifyMVar}的定义，我们可以看到这种模式的特定样式：

\begin{lstlisting}[language=Haskell]
  import Control.Concurrent (MVar, putMVar, takeMVar)
  import Control.Exception (evaluate, mask, onException)

  modifyMVar' :: MVar a -> (a -> IO (a, b)) -> IO b
  modifyMVar' m io =
    mask $ \restore -> do
      a <- takeMVar m
      (a', b) <- restore (io a >>= evaluate) `onException` putMVar m a
      putMVar m a'
      return b
\end{lstlisting}

注：详见\href{https://hackage.haskell.org/package/ghc-internal-9.1001.0/docs/src/GHC.Internal.Control.Concurrent.MVar.html#modifyMVar}{此处}。

无论是在处理网络连接、数据库句柄还是 C 库管理的数据，它都能轻松的适应用户的特定需求。

\subsubsection*{查找线程的状态}

\acode{getStatus}函数能告诉我们一个线程的当前状态。如果该线程不再被管理（或者是从来没有被管理过），它返回\acode{Nothing}。

\begin{lstlisting}[language=Haskell]
  -- Immediately return the status of a managed thread
  getStatus :: ThreadManager -> ThreadId -> IO (Maybe ThreadStatus)
  getStatus (Mgr mgr) tid =
    modifyMVar mgr $ \m ->
      case M.lookup tid m of
        Nothing -> return (m, Nothing)
        Just st -> tryTakeMVar st >>= mst m
    where
      mst m' mm = case mm of
        Nothing -> return (m', Just Running)
        Just sth -> return (M.delete tid m', Just sth)
\end{lstlisting}

如果线程仍在运行，其返回\acode{Just Running}。否则，它表示该线程为何被终结，同时停止管理该线程。

如果\acode{tryTakeMVar}函数找到\acode{MVar}是空的，它便立刻返回\acode{Nothing}而不是阻塞。

\begin{lstlisting}[language=Haskell]
  ghci> :t tryTakeMVar
  tryTakeMVar :: MVar a -> IO (Maybe a)
\end{lstlisting}

否则，它像通常那样从\acode{MVar}中提取值。

\acode{waitFor}函数的行为类似，不过并不是立刻返回，它会阻塞，直到给定的线程在返回之前终止。

\begin{lstlisting}[language=Haskell]
  -- Block until a specific managed thread terminates
  waitFor :: ThreadManager -> ThreadId -> IO (Maybe ThreadStatus)
  waitFor (Mgr mgr) tid = do
    maybeDone <- modifyMVar mgr $ \m ->
      return $ case M.updateLookupWithKey (\_ _ -> Nothing) tid m of
        (Nothing, _) -> (m, Nothing)
        (done, m') -> (m', done)
    case maybeDone of
      Nothing -> return Nothing
      Just st -> Just <$> takeMVar st
\end{lstlisting}

它首先提取保存线程状态的\acode{MVar}（如果存在）。\acode{Map}类型的\acode{updateLookupWithKey}函数很有用：它将查找与修改或删除值结合起来。

\begin{lstlisting}[language=Haskell]
  ghci> :m +Data.Map
  ghci> :t updateLookupWithKey
  updateLookupWithKey :: (Ord k) =>
                         (k -> a -> Maybe a) -> k -> Map k a -> (Maybe a, Map k a)
\end{lstlisting}

这种情况下，我们希望总是删除持有线程状态的\acode{MVar}（如果它存在），这样我们的线程管理器将不再管理线程。如果有要提取的值，我们从\acode{MVar}中获取线程的退出状态
并返回它。

最后一个有用的函数就是简单的等待所有管理的线程完成，并忽略它们的退出状态：

\begin{lstlisting}[language=Haskell]
  -- Block until all managed threads terminate
  waitAll :: ThreadManager -> IO ()
  waitAll (Mgr mgr) = modifyMVar mgr es >>= mapM_ takeMVar
    where
      es m = return (M.empty, M.elems m)
\end{lstlisting}

\subsubsection*{编写更紧凑的代码}

上面\acode{waitFor}的定义不太令人满意，因为两个地方执行了类似的代码：在由\acode{modifyMVar}调用的函数内部，以及在它的返回值上。

当然，我们可以应用前面遇到的一个函数来消除这种重复。由\acode{Control.Monad}模块带来的\acode{join}可以解决这个问题。

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Monad
  ghci> :t join
  join :: (Monad m) => m (m a) -> m a
\end{lstlisting}

这里的技巧就是通过让第一个表达式返回应该从\acode{modifyMVar}返回后执行的 IO 操作来摆脱第二个\acode{case}表达式。这里使用了\acode{join}：

\begin{lstlisting}[language=Haskell]
  waitFor (Mgr mgr) tid =
    join . modifyMVar mgr $ \m -> return $
      case M.updateLookupWithKey (\_ _ -> Nothing) tid m of
        (Nothing, _) -> (m, return Nothing)
        (Just st, m') -> (m', Just <$> takeMVar st)
\end{lstlisting}

这是一个有趣的想法：我们可以在纯函数代码中创建 monadic 函数或操作，然后传递它，直到最终可用的单元中结束。一旦我们的开发令其有意义，这可能是一种灵活的编写代码的方式。

\subsection*{通过隧道进行交流}

对于线程之间的一次性通信，\acode{MVar}是非常好的选择。另一种类型\acode{Chan}提供单向通信通道。下面是一个简单的例子：

\begin{lstlisting}[language=Haskell]
  import Control.Concurrent (forkIO, newChan, readChan, writeChan)

  chanExample :: IO ()
  chanExample = do
    ch <- newChan
    _ <- forkIO $ do
      writeChan ch "hello world"
      writeChan ch "now i quit"
    readChan ch >>= print
    readChan ch >>= print
\end{lstlisting}

如果\acode{Chan}是空的，\acode{readChan}会阻塞知道有值可以读取。\acode{writeChan}函数永远不会阻塞：它会立刻向\acode{Chan}中写入一个新值。

\subsection*{几点重要的须知}

\subsubsection*{MVar 与 Chan 是 non-strict 的}

正如大多数 Haskell 容器类型一样，\acode{MVar}与\acode{Chan}都是 non-strict 的：它们都不计算其内容。提到这点并不是因为它是一个问题，而是因为它是一个常见的盲点：
人们倾向认为这些类型是 strict 的，也许是因为它们在\acode{IO}单子中使用。

对于其它容器类型，错误猜测\acode{MVar}或\acode{Chan}类型的 strict 性的结果通常是空间或性能泄漏。这里有一个合理的设想。

fork 一个线程，在另一个核执行昂贵计算。

\begin{lstlisting}[language=Haskell]
  import Control.Concurrent

  notQuiteRight :: IO ()
  notQuiteRight = do
    mv <- newEmptyMVar
    _ <- forkIO $ expensiveComputation_stricter mv
    -- some other activity
    result <- takeMVar mv
    print result

  expensiveComputation_stricter :: MVar [Char] -> IO ()
  expensiveComputation_stricter mv = do
    let a = "this is"
        b = "not really"
        c = "all that expensive"
    putMVar mv (a ++ b ++ c)
\end{lstlisting}

这像是做某事儿，同时将其结果返回给\acode{MVar}：

\begin{lstlisting}[language=Haskell]
  expensiveComputation_stricter :: MVar [Char] -> IO ()
  expensiveComputation_stricter mv = do
    let a = "this is"
        b = "not really"
        c = "all that expensive"
    putMVar mv (a ++ b ++ c)
\end{lstlisting}

当我们从父线程的\acode{MVar}中获取结果并试图对它做一些事情时，我们的线程开始疯狂的计算，因为我们从未强迫计算发生在另一个线程内！

像往常一样，解决方案很简单，一旦我们知道存在潜在的问题：为 fork 的线程增加 strict 性，以确保计算在原线程发生。strict 最好放在一个地方，以免遗忘。

\begin{lstlisting}[language=Haskell]
  {-# LANGUAGE BangPatterns #-}

  import Control.Concurrent (MVar, putMVar, takeMVar)
  import Control.Exception (IOException, catch, mask, onException, throw)

  modifyMVar_strict :: MVar a -> (a -> IO a) -> IO ()
  modifyMVar_strict m io = mask $ \restore -> do
    a <- takeMVar m
    !a' <- restore (io a) `onException` putMVar m a
    putMVar m a'

  modifyMVar_strict' :: MVar a -> (a -> IO a) -> IO ()
  modifyMVar_strict' m io = mask $ \restore -> do
    a <- takeMVar m
    !a' <-
      restore (io a) `catch` \e ->
        putMVar m a >> throw (e :: IOException)
    putMVar m a'
\end{lstlisting}

注：原文中\acodegrn{Control.Exception}库提供的\acode{block}与\acode{unblock}已被废弃，现在改用\acode{mask}来实现。

上述代码中的\acode{!}模式简单易用，但这并不总保证数据总能被计算。

\subsubsection*{Chan 是无边界的}

由于\acode{writeChan}总能立即成功，所以使用\acode{Chan}有着潜在的风险。如果一个线程的写比另一个线程的读要多，那么这个线程将以一种不受约束的方式增长：未读的消息
将随着读取越来越落后而堆积起来。

\subsection*{共享状态仍然很困难}

尽管与其它语言相比，Haskell 在线程间共享数据有不同的原语，但它仍然面临相同的基本问题：编写正确的并发程序非常困难。实际上，其它语言中并发编程的一些缺陷同样适用
于 Haskell。两个比较著名的问题就是\textit{死锁}与\textit{饥饿}。

\subsubsection*{死锁}

在\textit{死锁}的情况下，两个或多个线程在访问共享资源时永远的卡住。一个典型的多线程死锁问题就是忘记申请锁的顺序。这类型的 bug 太常见了，即：\textit{锁序反转}。
虽然 Haskell 不提供锁，但是\acodegrn{MVar}类型仍然容易出现顺序反转的问题。下面是一个简单的例子：

\begin{lstlisting}[language=Haskell]
  import Control.Concurrent (MVar, forkIO, modifyMVar_, newMVar, yield)

  nestedModification :: (Num a1, Num a2) => MVar a2 -> MVar a1 -> IO ()
  nestedModification outer inner = do
    modifyMVar_ outer $ \x -> do
      yield -- force this thread to temporarily yield the CPU
      modifyMVar_ inner $ \y -> return $ y + 1
      return $ x + 1
    putStrLn "done"

  main :: IO ()
  main = do
    a <- newMVar (1 :: Int)
    b <- newMVar (2 :: Int)
    _ <- forkIO $ nestedModification a b
    _ <- forkIO $ nestedModification b a

    return ()
\end{lstlisting}

%

\subsubsection*{饥饿}

%

\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}

\subsubsection*{任何希望？}

\subsection*{使用多核 GHC}

\subsubsection*{运行时选项}

\subsubsection*{为 Haskell 寻找有效核术}

\subsubsection*{使用合适的运行时}



\end{document}
