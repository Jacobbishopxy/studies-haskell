\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{关联列表}

通常我们需要处理由键索引的无序数据。例如 Unix 管理员会有一系列的数值 UIDs 以及其关联的用户名。该列表的价值在于能够查找给定 UID 的用户名，而不是按照数据的顺序。
换言之，UID 是数据库的键。

在 Haskell 中，有若干方法可以处理类似这样数据的结构。两个最常见的就是关联列表以及由\acode{Data.Map}模块提供的\acode{Map}类型。关联列表很方便，因为它们很简单。
它们就是 Haskell 的列表，因此所有熟悉的列表函数同样可用于关联列表。然而对于较大的数据集，\acode{Map}则比关联列表具有更大的性能优势。

关联列表就是一个包含了（键，值）元组的普通列表。对于 UID 映射至用户名的类型就是\acode{[(Integer, String)]}。

Haskell 拥有一个称为\acode{Data.List.lookup}的内建函数用于关联列表的查询。其类型为\acode{Eq a => a -> [(a, b)] -> Maybe b}。

\begin{lstlisting}[language=Haskell]
  ghci> let al = [(1,"one"),(2,"two"),(3,"three"),(4,"four")]
  ghci> lookup 1 al
  Just "one"
  ghci> lookup 5 al
  Nothing
\end{lstlisting}

\acode{lookup}函数实际很简单，我们可以自己编写一个：

\begin{lstlisting}[language=Haskell]
  myLookup :: (Eq a) => a -> [(a, b)] -> Maybe b
  myLookup _ [] = Nothing
  myLookup key ((thisKey, thisVal) : rest) =
    if key == thisKey
      then Just thisVal
      else myLookup key rest
\end{lstlisting}

让我们来看一个更复杂的关联列表。在 Unix/Linux 机器中存在一个名为\acode{/etc/passwd}的文件用于存储用户名，UIDs，home 路径，已经其它数据。我们将编写一个程序用于
解析该文件，创建一个关联列表，令用户通过给定的 UID 来查找用户名。

\begin{lstlisting}[language=Haskell]
  import Control.Monad (when)
  import Data.List
  import System.Environment (getArgs)
  import System.Exit
  import System.IO

  main = do
    -- Load the command-line arguments
    args <- getArgs

    -- If we don't have the right amount of args, give an error and abort
    when (length args /= 2) $ do
      putStrLn "Syntax: passwd-al filename uid"
      exitFailure

    -- Read the file lazily
    content <- readFile $ head args

    -- Compute the username in pure code
    let username = findByUID content $ read $ args !! 1

    -- Display the result
    case username of
      Just x -> putStrLn x
      Nothing -> putStrLn "Could not find that UID"

    putStrLn "whatever"

  -- Given the entire input and a UID, see if we can find a username.
  findByUID :: String -> Integer -> Maybe String
  findByUID content uid =
    let al = map parseLine . filter (('#' /=) . head) . lines $ content
     in lookup uid al

  -- Convert a colon-separated line into fields
  parseLine :: String -> (Integer, String)
  parseLine input =
    let fields = split ':' input
     in (read (fields !! 2), head fields)

  -- Takes a delimiter and a list. Break up the list based on the delimiter.
  split :: (Eq a) => a -> [a] -> [[a]]
  -- If the input is empty, the result is a list of empty lists.
  split _ [] = [[]]
  split delim str =
    -- Find the part of the list before delim and put it in "before".
    -- The rest of the list, including the leading delim, goes in "remainder".
    let (before, remainder) = span (/= delim) str
     in before : case remainder of
          [] -> []
          -- If there is more data to precess,
          -- call split recursively to process it
          x ->
            split delim $ tail x
\end{lstlisting}

\textbf{注}：原文的\acode{findByUID}函数中的\acode{let al = map parseLine . lines \$ content}需要修改成
\acode{let al = map parseLine . filter (('#' /=) . head) . lines \$ content}才能对\acode{/etc/passwd}文件生效。否则会抛出异常
\acode{Prelude.!!: index too large}。

测试：

\begin{lstlisting}
  % runhaskell passwd-al.hs /etc/passwd 0
  root
  % runhaskell passwd-al.hs /etc/passwd 3
  Could not find that UID
\end{lstlisting}

\subsection*{映射}

\acode{Data.Map}模块提供了一个与关联列表行为相似的\acode{Map}类型，不过有更优异的性能。

映射提供了其它语言中与哈希表一样功能。其内部的实现为一个平衡二叉树。相较于哈希表，在不可变数据上的表现而言，映射更加的高效。这也是纯函数式编程如何深刻影响我们编写代码的
最明显的例子：我们选择的数据结构和算法可以清晰的表达并且高效的执行，但是我们对特定任务的选择通常与命令式语言中的对应选项不同。

\acode{Data.Map}中有些函数与 Prelude 同名，因此需要\acode{import qualified Data.Map as Map}并使用\acode{Map.name}来引用模块中对应的名称。

\begin{lstlisting}[language=Haskell]
  import Data.Map qualified as Map

  -- Functions to generate a Map that represents an association list as a map

  al = [(1, "one"), (2, "two"), (3, "three"), (4, "four")]

  {-
  Create a map representation of 'al' by converting the association list using Map.fromList
  -}
  mapFromAL = Map.fromList al

  {-
  Create a map representation of 'al' by doing a fold
  -}
  mapFold = foldl (\map (k, v) -> Map.insert k v map) Map.empty al

  {-
  Manually create a map with the elements of 'al' in it
  -}
  mapManual =
    Map.insert 2 "two"
      . Map.insert 4 "four"
      . Map.insert 1 "one"
      . Map.insert 3 "three"
      $ Map.empty
\end{lstlisting}

类似\acode{Map.insert}的函数通常在 Haskell 中这么工作：它们返回输入数据的拷贝，并应用所需的修改。这对于映射而言很轻松。这意味着可以使用\acode{foldl}来构建一个如
\acode{mapFold}案例中那样的映射。或者是调用\acode{Map.insert}串联在一起如\acode{mapManual}案例中那样。使用\textbf{ghci}来查看是否如同预期：

\begin{lstlisting}[language=Haskell]
  ghci> :l buildmap.hs
  [1 of 2] Compiling Main             ( buildmap.hs, interpreted )
  Ok, one module loaded.
  ghci> mapFromAL
  fromList [(1,"one"),(2,"two"),(3,"three"),(4,"four")]
  ghci> mapFold
  fromList [(1,"one"),(2,"two"),(3,"three"),(4,"four")]
  ghci> mapManual
  fromList [(1,"one"),(2,"two"),(3,"three"),(4,"four")]
\end{lstlisting}

注意\acode{mapManual}的输出与之前使用列表来构建映射的输出是不一样的。映射并不确保原始的顺序。

\subsection*{函数也是数据}

Haskell 一部分的能力就是创建于操作函数非常的容易。下面是一个将函数存储为 record 字段的例子：

\begin{lstlisting}[language=Haskell]
  data CustomColor = CustomColor {red :: Int, green :: Int, blue :: Int}
    deriving (Eq, Show, Read)

  data FuncRec = FuncRec {name :: String, colorCalc :: Int -> (CustomColor, Int)}

  plus5func color x = (color, x + 5)

  purple = CustomColor 255 0 255

  plus5 = FuncRec {name = "plus5", colorCalc = plus5func purple}

  always0 = FuncRec {name = "always0", colorCalc = const (purple, 0)}
\end{lstlisting}

注意\acode{colorCalc}的类型：它是一个函数，接受一个\acode{Int}并返回\acode{(CustomColor, Int)}的元组。我们创建了两个\acode{FuncRec}的 records：
\acode{plus5}与\acode{always0}。注意两者的\acode{colorCalc}总是返回紫色。\acode{FuncRec}其本身并没有字段用于存储颜色，而是以某种方式使值成为了函数本身。
这就是\textit{闭包 closure}。

\begin{lstlisting}[language=Haskell]
  ghci> :l funcrecs.hs
  [1 of 2] Compiling Main             ( funcrecs.hs, interpreted )
  Ok, one module loaded.
  ghci> :t plus5
  plus5 :: FuncRec
  ghci> name plus5
  "plus5"
  ghci> :t colorCalc plus5
  colorCalc plus5 :: Int -> (CustomColor, Int)
  ghci> (colorCalc plus5) 7
  (CustomColor {red = 255, green = 0, blue = 255},12)
  ghci> :t colorCalc always0
  colorCalc always0 :: Int -> (CustomColor, Int)
  ghci> (colorCalc always0) 7
  (CustomColor {red = 255, green = 0, blue = 255},0)
\end{lstlisting}

更高级的方式，例如将数据用于若干地方，使用类型构造函数则会大有帮助：

\begin{lstlisting}[language=Haskell]
  data FuncRec = FuncRec
    { name :: String,
      calc :: Int -> Int,
      namedCalc :: Int -> (String, Int)
    }

  mkFuncRec :: String -> (Int -> Int) -> FuncRec
  mkFuncRec name calcfunc =
    FuncRec
      { name = name,
        calc = calcfunc,
        namedCalc = \x -> (name, calcfunc x)
      }

  plus5 = mkFuncRec "plus5" (+ 5)

  always0 = mkFuncRec "always0" (const 0)
\end{lstlisting}

这里有一个名为\acode{mkFuncRec}的函数，其接受一个\acode{String}以及另一个函数作为参数，返回一个新的\acode{FuncRec} record。注意\acode{mkFuncRec}的两个参数
在若干地方都被用到了。

\begin{lstlisting}[language=Haskell]
  ghci> :l funcrecs2.hs
  [1 of 2] Compiling Main             ( funcrecs2.hs, interpreted )
  Ok, one module loaded.
  ghci> :t plus5
  plus5 :: FuncRec
  ghci> name plus5
  "plus5"
  ghci> (calc plus5) 5
  10
  ghci> (namedCalc plus5) 5
  ("plus5",10)
  ghci> let plus5a = plus5 {name = "PLUS5A"}
  ghci> name plus5a
  "PLUS5A"
  ghci> (namedCalc plus5a) 5
  ("plus5",10)
\end{lstlisting}

注意\acode{plus5a}的创建。我们修改了\acode{name}字段而不是\acode{namedCalc}字段。这是为什么\acode{name}拥有一个新的名称，而\acode{namedCalc}仍然返回的是
传入\acode{mkFuncRec}的名称；它不会改变，除非我们显式的修改它。

\subsection*{拓展案列：/etc/passwd}

\subsection*{拓展案列：数值类型}

\subsection*{函数作为数据的优点}

\subsection*{通用序列}

\end{document}
