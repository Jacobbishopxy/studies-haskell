\documentclass[./main.tex]{subfiles}

\begin{document}

略

\subsection*{简单开始：递归展示一个路径}

在设计我们的库之前，让我们先解决几个小问题。我们的第一个问题就是递归的列出一个路径的所有文件与子路径。

\begin{lstlisting}[language=Haskell]
  module RecursiveContents (getRecursiveContents) where

  import Control.Monad (forM)
  import System.Directory (doesDirectoryExist, getDirectoryContents)
  import System.FilePath ((</>))

  getRecursiveContents :: FilePath -> IO [FilePath]
  getRecursiveContents topdir = do
    names <- getDirectoryContents topdir
    let properNames = filter (`notElem` [".", ".."]) names
    paths <- forM properNames $ \name -> do
      let path = topdir </> name
      isDirectory <- doesDirectoryExist path
      if isDirectory
        then getRecursiveContents path
        else return [path]
    return (concat paths)
\end{lstlisting}

\acode{filter}表达式确保一个路径列表中不会包含特殊的路径名称，例如\acode{.}或者\acode{..}。如果没有过滤它们则会有无限的递归。

这里又遇到了上一章的\acode{forM}；它等同于\acode{mapM}只不过参数调转了：

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Monad
  ghci> :t mapM
  mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
  ghci> :t forM
  forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
\end{lstlisting}

与原文（如下）不同：

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Monad
  ghci> :type mapM
  mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
  ghci> :type forM
  forM :: (Monad m) => [a] -> (a -> m b) -> m [b]
\end{lstlisting}

函数体中会检查当前输入是否为一个路径：如果是，则递归调用\acode{getRecursiveContents}来列举该路径；否则，它返回一个单例列表，
即当前输入的名称。（别忘了\acode{return}函数在 Haskell 有独特的意义：它通过单子类型构造函数来包装一个值。）

另一个值得指出的点在于变量\acode{isDirectory}的使用。一个命令式的语言例如 Python，通常会表述为\acode{if os.path.isdir(path)}，
然而\acode{doesDirectoryExist}函数是一个\textit{action}；它的返回类型是\acode{IO Bool}而不是\acode{Bool}。又因为一个
\acode{if}表达式需要的是\acode{Bool}类型，我们需要使用\acode{<-}来获取被 \acode{IO} 所包裹着的 action 的\acode{Bool}返回，
这样才能在\acode{if}中使用解包过后的\acode{Bool}。

每个 loop 的便利都会返回一个名称列表，因此这里\acode{forM}的结果是\acode{IO [[FilePath]]}。我们使用\acode{concat}将其打平
称为一个列表。

\subsubsection*{重访匿名与命名函数}

在之前的匿名（lambda）函数的章节中，我们列举了一些不要使用匿名函数的原因，然而在这里我们使用了一个匿名函数作为 loop 的本体。这就是
Haskell 中最常见的匿名函数使用方法。

我们已经从\acode{forM}与\acode{mapM}的类型中得知它们接受函数作为参数。大多数的 loop 本体会是一个在程序中出现一次的代码块。因为
我们只会在一处使用这个 loop 本体，那么为什么要给它一个名称呢？

当然了，有时我们需要在若干地方部署同样的代码。这种情况下与其复制黏贴一个匿名函数，不如给已存在的函数一个名称。

\subsubsection*{为什么同时提供了\acode{mapM}与\acode{forM}？}

同时存在两个除了参数顺序不同功能却一样的函数看起来有点奇怪，实际上它们适用于不同的场景。

考虑上述例子，使用匿名函数作为函数体。如果我们使用\acode{mapM}而不是\acode{forM}，那么则需要将变量\acode{properNames}放置在
函数体之后。为了让代码能被正确的解析，我们还需要将整个匿名函数体用圆括号包裹起来，或者是用一个命名函数来代替。

相反，如果 loop 本体就是一个命名函数，且需要遍历的列表是由一个复杂的表达式计算而得的时候，那么就有更好的理由使用\acode{mapM}了。

\subsection*{一个简单的查询函数}

我们可以是用\acode{getRecursiveContents}函数作为一个简单的文件查询的基础：

\begin{lstlisting}[language=Haskell]
  import RecursiveContents (getRecursiveContents)

  simpleFind :: (FilePath -> Bool) -> FilePath -> IO [FilePath]
  simpleFind p path = do
    names <- getRecursiveContents path
    return $ filter p names
\end{lstlisting}

这个函数接受一个谓词，用于筛选\acode{getRecursiveContents}所返回的名称。每个传递到谓词的名称都是一个完整的路径，那么我们该如何执行
一个类似“找到所有后缀为\acode{.c}的文件”这样的常规操作呢？

\acode{System.FilePath}模块包含了大量的宝贵的函数可以帮助我们操作文件名。上述案例可以用\acode{takeExtension}。

\begin{lstlisting}[language=Haskell]
  ghci> :m +System.FilePath
  ghci> :t takeExtension
  takeExtension :: FilePath -> String
  ghci> takeExtension "foo/bar.c"
  ".c"
  ghci> takeExtension "quux"
  ""
\end{lstlisting}

这样我们就可以编写一个接受路径并提取后缀再与\acode{.c}进行比较的函数了：

\begin{lstlisting}[language=Haskell]
  ghci> :l SimpleFinder
  [1 of 2] Compiling RecursiveContents ( RecursiveContents.hs, interpreted )
  [2 of 2] Compiling Main             ( SimpleFinder.hs, interpreted )
  Ok, two modules loaded.
  ghci> :t simpleFind (\p -> takeExtension p == ".c")
  simpleFind (\p -> takeExtension p == ".c")
    :: FilePath -> IO [FilePath]
\end{lstlisting}

虽然\acode{simpleFind}可以工作，不过还有一些瑕疵。首先是谓词并没有很强的表达力。它只能查看一个路径名称，而不能知晓输入的是一个
文件还是路径。这就意味着尝试使用\acode{simpleFind}将列出\acode{.c}结尾的目录已经具有相同扩展名的文件。

其次就是\acode{simpleFind}没有提供该如何遍历文件系统的控制。为什么这点很重要，可以考虑一下在拥有子版本管理的树形文件系统下，
进行源文件的搜索。子版本在每个它管理的路径下都会维护一个私有的\acode{.svn}路径；它们每一个包含了若干我们不需要考虑的子文件夹与文件。
虽然我们可以简单的过滤掉任何包含\acode{.svn}的情况，不过更有效的方式则是在第一时间就避免这些文件夹的遍历。

最后就是\acode{simpleFind}是严格执行的，因为它包含了一系列在\acode{IO}单子中所执行的 actions。如果我们有上百万的文件需要遍历，
我们则需要等待很久并且还会得到一个巨大的包含了百万名称的结果。这对于资源管理与响应速度而言都非常的不好。我们更加倾向于一个惰性流式的
结果。

\subsection*{谓词：从贫穷到富裕，同时保持 pure}

我们的谓词只能查看文件名称。这就包含了大量有趣的行为：例如当我们想要展示的文件大于给定的大小时。

一个比较简单的做法就是修改\acode{IO}：谓词的类型不再是\acode{FilePath -> Bool}，而改为\acode{FilePath -> IO Bool}。
这使得我们可以用任意 I/O 作为谓词函数的一部分。尽管这看起来很吸引人，但它也有潜在的问题：这样的谓词可能会有任意的副作用，因为返回
类型为 I/O a 的函数可以拥有任意的副作用。

让我们利用类型系统来编写更加可以预测，更是 bug 的代码：我们将通过避免 “IO” 污染来保持谓词的纯粹性。这样可以确保它们不会产生任何
讨厌的副作用。同时我们还会喂给它们更多的信息，这样它们就能获得我们想要的表达能力，而不会成为潜在的危险。

Haskell 的\acode{System.Directory}模块提供了一组有用的文件元数据。

\begin{lstlisting}[language=Haskell]
  ghci> :m +System.Director
\end{lstlisting}

\begin{itemize}
  \item 我们可以使用\acode{doesFileExist}与\acode{doesDirectoryExist}来判断一个输入是否是文件还是路径。近些年暂时还没有
        便捷的方法来查看其它的文件类型，例如命名通道，软硬链接等。

        \begin{lstlisting}[language=Haskell]
          ghci> :t doesFileExist
          doesFileExist :: FilePath -> IO Bool
          ghci> doesFileExist "."
          False
          ghci> :t doesDirectoryExist
          doesDirectoryExist :: FilePath -> IO Bool
          ghci> doesDirectoryExist "."
          True
        \end{lstlisting}
  \item \acode{getPermissions}函数允许我们得知对于一个文件或者路径的操作是否合法

        \begin{lstlisting}[language=Haskell]
          ghci> :t getPermissions
          getPermissions :: FilePath -> IO Permissions
          ghci> :i Permissions
          type Permissions :: *
          data Permissions
            = directory-1.3.6.2:System.Directory.Internal.Common.Permissions {readable :: Bool,
                                                                              writable :: Bool,
                                                                              executable :: Bool,
                                                                              searchable :: Bool}
                  -- Defined in ‘directory-1.3.6.2:System.Directory.Internal.Common’
          instance [safe] Eq Permissions
            -- Defined in ‘directory-1.3.6.2:System.Directory.Internal.Common’
          instance [safe] Ord Permissions
            -- Defined in ‘directory-1.3.6.2:System.Directory.Internal.Common’
          instance [safe] Show Permissions
            -- Defined in ‘directory-1.3.6.2:System.Directory.Internal.Common’
          instance [safe] Read Permissions
            -- Defined in ‘directory-1.3.6.2:System.Directory.Internal.Common’
          ghci> getPermissions "."
          Permissions {readable = True, writable = True, executable = False, searchable = True}
          ghci> :t searchable
          searchable :: Permissions -> Bool
          ghci> searchable it
        \end{lstlisting}
  \item 最后则是\acode{getModificationTime}可以告诉我们输入是何时被修改的：
        \begin{lstlisting}[language=Haskell]
          ghci> :t getModificationTime
          getModificationTime
            :: FilePath
               -> IO time-1.11.1.1:Data.Time.Clock.Internal.UTCTime.UTCTime
          ghci> getModificationTime "."
          2023-10-14 13:58:10.895659105 UTC
        \end{lstlisting}
\end{itemize}

那么对于新的谓词而言有多少数据是需要知道的呢？由于可以通过\acode{Permissions}来查看一个输入是否为文件还是路径，因此我们不再需要
\acode{doesFileExist}与\acode{doesDirectoryExist}。这样我们有了四个需要查看的数据：

\begin{lstlisting}[language=Haskell]
  import Control.Exception (bracket, handle)
  import Control.Monad (filterM)
  import Data.Time.Clock (UTCTime)
  import RecursiveContents (getRecursiveContents)
  import System.Directory (Permissions (..), getModificationTime, getPermissions)
  import System.FilePath (takeExtensions)
  import System.IO (IOMode (..), hClose, hFileSize, openFile)

  type Predicate =
    FilePath ->
    Permissions ->
    Maybe Integer ->
    UTCTime ->
    Bool
\end{lstlisting}

与原文不同之处在于导入部分，由于\acode{import System.Time (ClockTime(..))}已经废弃了，根据\acode{getModificationTime}
可知需要使用\acode{import Data.Time.Clock (UTCTime)}。

我们的\acode{Predicate}类型就是一个有着四个参数函数的别名。

注意谓词的返回类型是\acode{Bool}而不是\acode{IO Bool}：谓词是纯的，并不运行 I/O。有了这个类型，编写一个更具表达性的查询函数就
好办了。

\begin{lstlisting}[language=Haskell]
  getFileSize :: FilePath -> IO (Maybe Integer)
  getFileSize = undefined

  betterFind :: Predicate -> FilePath -> IO [FilePath]
  betterFind p path = getRecursiveContents path >>= filterM check
    where
      check name = do
        perms <- getPermissions name
        size <- getFileSize name
        modified <- getModificationTime name
        return $ p name perms size modified
\end{lstlisting}

我们暂时先跳过\acode{getFileSize}函数，稍后会进行讲解。

我们不能使用\acode{filter}来调用谓词\acode{p}，因为\acode{p}的纯性意味着它不能执行收集所需元数据所需的 I/O。

这时就需要一个我们并不熟悉的\acode{filterM}函数了，它的行为类似于普通的\acode{filter}函数，不过是在\acode{IO}单子中对谓词进行
计算，即允许谓词执行 I/O。

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Monad
  ghci> :t filterM
  filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]
\end{lstlisting}

\subsection*{安全的调整文件大小}

虽然\acode{System.Directory}没有提供文件大小的查询，不过我们可以用\acode{System.IO}来做。它包含了一个名为\acode{hFileSize}
的函数，可以返回一个文件的字节大小。

\begin{lstlisting}[language=Haskell]
  simpleFileSize :: FilePath -> IO Integer
  simpleFileSize path = do
    h <- openFile path ReadMode
    size <- hFileSize h
    hClose h
    return size
\end{lstlisting}

虽然这个函数可以工作，但是它还不能为我们所用。在\acode{betterFind}中，我们可以无条件的对任何地址输入调用\acode{getFileSize}；
如果输入的不是一个文件它会返回\acode{Nothing}，否则返回\acode{Just}。实际上该函数的输入不是一个文件或者不能打开文件（权限不够）时
会抛出异常。

以下是一个安全版本：

\begin{lstlisting}[language=Haskell]
  saferFileSize :: FilePath -> IO (Maybe Integer)
  saferFileSize path = handle errorHandler $ do
    h <- openFile path ReadMode
    size <- hFileSize h
    hClose h
    return $ Just size
    where
      errorHandler :: SomeException -> IO (Maybe Integer)
      errorHandler _ = return Nothing
\end{lstlisting}

这里与原文不同在于匿名函数\acode{handle (\_ -> return Nothing)}改成了\acode{errorHandler}，并标注了类型
\acode{errorHandler :: SomeException -> IO (Maybe Integer)}。（与第八章的处理方式一致）

函数体内部几乎是一致的，除了\acode{handle}子句。

这里的异常处理是只要有异常发生就返回\acode{Nothing}，其余的改动就是返回值被包裹了\acode{Just}。

\acode{saferFileSize}函数现在拥有了正确的类型签名，也不会再抛出任何异常了，不过它仍然不完整。这里只处理了\acode{openFile}的异常，
但是\acode{hFileSize}仍然会抛出异常，比如说命名管道。这样的异常会被\acode{handle}捕获，但是我们的\acode{hClose}永远不会被执行。

Haskell 的实现会在文件句柄不再使用时自动关闭，但是这要在垃圾回收时才会发生，而接下来垃圾回收的时间却不能保证。

文件句柄是稀有资源，这份稀有性是由操作系统决定的，比如 Linux 系统中一个进程默认同时打开文件的最大数量是 1024 个。

这不难想象一个场景，在调用了使用了\acode{saferFileSize}的\acode{betterFind}函数因为穷尽了最大文件开启数，而垃圾回收还没开始时，
程序崩溃了。

这是一种特别危险的 bug：它会在若干条件组合在一起时变得难以追踪。在\acode{betterFind}访问了足够多数量的非文件时句柄没有被关闭而达到了
进程最大文件开启数的上限，然后在垃圾回收还未发生之前又打开了另外的文件。

更糟糕的是，任何后续错误都是由程序中无法访问数据而引起，并且还没有垃圾回收。出现这样的 bug 依赖于程序结构，文件系统内容，以及当前程序的
运行时还未触发垃圾回收。

这样的问题在开发的过程中很容易被忽视，然后后续发生时会让诊断变得异常困难。

\subsubsection*{获取-使用-释放}

我们需要\acode{openFile}成功时\acode{hClose}能总是被调用。\acode{Control.Exception}模块为此提供了\acode{bracket}函数。

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Exception
  ghci> :type bracket
  bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
\end{lstlisting}

\acode{bracket}函数接受三个 actions 参数。第一个 action 用于获取一个资源，第二个则是释放资源，第三个则是介于前面两者之间，让我们
称其为“使用” action。如果“获取” action 成功了，“释放” action \textit{总是}会被调用。这确保了资源总是能被释放。“使用”和“释放”
actions 分别传给了“获取” action。

当“使用” action 在执行时发生了异常，\acode{bracket}会调用“释放” action 然后再重新抛出异常。如果“使用” action 成功了，
\acode{bracket}会调用“释放” action 然后再返回”使用“ action 所返回的值。

我们现在可以编写一个完全安全的函数了：它不会抛出异常；也不会产生句柄垃圾而导致程序崩溃。

\begin{lstlisting}[language=Haskell]
  getFileSize :: FilePath -> IO (Maybe Integer)
  getFileSize path = handle errorHandler $
    bracket (openFile path ReadMode) hClose $ \h -> do
      size <- hFileSize h
      return (Just size)
    where
      errorHandler :: SomeException -> IO (Maybe Integer)
      errorHandler _ = return Nothing
\end{lstlisting}

让我们看一下这里的\acode{bracket}，首先是打开文件，返回打开文件的句柄，接着是关闭句柄，最后是对句柄调用\acode{hFileSize}并将结果
包装进\acode{Just}。

我们需要同时使用\acode{bracket}与\acode{handle}才能达成目的。前者能保证垃圾文件句柄不会堆积，后者确保异常被处理。

\subsection*{用于谓词的领域特定语言}

% TODO

\subsection*{控制遍历}

\subsection*{密度，可读性与学习过程}

\subsection*{另一个角度看待遍历}

\subsection*{有用的编码指导}

\end{document}
