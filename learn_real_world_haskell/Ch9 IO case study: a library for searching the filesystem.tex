\documentclass[./main.tex]{subfiles}

\begin{document}

略

\subsection*{简单开始：递归展示一个路径}

在设计我们的库之前，让我们先解决几个小问题。我们的第一个问题就是递归的列出一个路径的所有文件与子路径。

\begin{lstlisting}[language=Haskell]
  module RecursiveContents (getRecursiveContents) where

  import Control.Monad (forM)
  import System.Directory (doesDirectoryExist, getDirectoryContents)
  import System.FilePath ((</>))

  getRecursiveContents :: FilePath -> IO [FilePath]
  getRecursiveContents topdir = do
    names <- getDirectoryContents topdir
    let properNames = filter (`notElem` [".", ".."]) names
    paths <- forM properNames $ \name -> do
      let path = topdir </> name
      isDirectory <- doesDirectoryExist path
      if isDirectory
        then getRecursiveContents path
        else return [path]
    return (concat paths)
\end{lstlisting}

\acode{filter}表达式确保一个路径列表中不会包含特殊的路径名称，例如\acode{.}或者\acode{..}。如果没有过滤它们则会有无限的递归。

这里又遇到了上一章的\acode{forM}；它等同于\acode{mapM}只不过参数调转了：

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Monad
  ghci> :t mapM
  mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
  ghci> :t forM
  forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
\end{lstlisting}

与原文（如下）不同：

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Monad
  ghci> :type mapM
  mapM :: (Monad m) => (a -> m b) -> [a] -> m [b]
  ghci> :type forM
  forM :: (Monad m) => [a] -> (a -> m b) -> m [b]
\end{lstlisting}

函数体中会检查当前输入是否为一个路径：如果是，则递归调用\acode{getRecursiveContents}来列举该路径；否则，它返回一个单例列表，
即当前输入的名称。（别忘了\acode{return}函数在 Haskell 有独特的意义：它通过单子类型构造函数来包装一个值。）

另一个值得指出的点在于变量\acode{isDirectory}的使用。一个命令式的语言例如 Python，通常会表述为\acode{if os.path.isdir(path)}，
然而\acode{doesDirectoryExist}函数是一个\textit{action}；它的返回类型是\acode{IO Bool}而不是\acode{Bool}。又因为一个
\acode{if}表达式需要的是\acode{Bool}类型，我们需要使用\acode{<-}来获取被 \acode{IO} 所包裹着的 action 的\acode{Bool}返回，
这样才能在\acode{if}中使用解包过后的\acode{Bool}。

每个 loop 的便利都会返回一个名称列表，因此这里\acode{forM}的结果是\acode{IO [[FilePath]]}。我们使用\acode{concat}将其打平
称为一个列表。

\subsubsection*{重访匿名与命名函数}

在之前的匿名（lambda）函数的章节中，我们列举了一些不要使用匿名函数的原因，然而在这里我们使用了一个匿名函数作为 loop 的本体。这就是
Haskell 中最常见的匿名函数使用方法。

我们已经从\acode{forM}与\acode{mapM}的类型中得知它们接受函数作为参数。大多数的 loop 本体会是一个在程序中出现一次的代码块。因为
我们只会在一处使用这个 loop 本体，那么为什么要给它一个名称呢？

当然了，有时我们需要在若干地方部署同样的代码。这种情况下与其复制黏贴一个匿名函数，不如给已存在的函数一个名称。

\subsubsection*{为什么同时提供了\acode{mapM}与\acode{forM}？}

同时存在两个除了参数顺序不同功能却一样的函数看起来有点奇怪，实际上它们适用于不同的场景。

考虑上述例子，使用匿名函数作为函数体。如果我们使用\acode{mapM}而不是\acode{forM}，那么则需要将变量\acode{properNames}放置在
函数体之后。为了让代码能被正确的解析，我们还需要将整个匿名函数体用圆括号包裹起来，或者是用一个命名函数来代替。

相反，如果 loop 本体就是一个命名函数，且需要遍历的列表是由一个复杂的表达式计算而得的时候，那么就有更好的理由使用\acode{mapM}了。

\subsection*{一个简单的查询函数}

我们可以是用\acode{getRecursiveContents}函数作为一个简单的文件查询的基础：

\begin{lstlisting}[language=Haskell]
  import RecursiveContents (getRecursiveContents)

  simpleFind :: (FilePath -> Bool) -> FilePath -> IO [FilePath]
  simpleFind p path = do
    names <- getRecursiveContents path
    return $ filter p names
\end{lstlisting}

这个函数接受一个谓词，用于筛选\acode{getRecursiveContents}所返回的名称。每个传递到谓词的名称都是一个完整的路径，那么我们该如何执行
一个类似“找到所有后缀为\acode{.c}的文件”这样的常规操作呢？

\acode{System.FilePath}模块包含了大量的宝贵的函数可以帮助我们操作文件名。上述案例可以用\acode{takeExtension}。

\begin{lstlisting}[language=Haskell]
  ghci> :m +System.FilePath
  ghci> :t takeExtension
  takeExtension :: FilePath -> String
  ghci> takeExtension "foo/bar.c"
  ".c"
  ghci> takeExtension "quux"
  ""
\end{lstlisting}

这样我们就可以编写一个接受路径并提取后缀再与\acode{.c}进行比较的函数了：

\begin{lstlisting}[language=Haskell]
  ghci> :l SimpleFinder
  [1 of 2] Compiling RecursiveContents ( RecursiveContents.hs, interpreted )
  [2 of 2] Compiling Main             ( SimpleFinder.hs, interpreted )
  Ok, two modules loaded.
  ghci> :t simpleFind (\p -> takeExtension p == ".c")
  simpleFind (\p -> takeExtension p == ".c")
    :: FilePath -> IO [FilePath]
\end{lstlisting}

虽然\acode{simpleFind}可以工作，不过还有一些瑕疵。首先是谓词并没有很强的表达力。它只能查看一个路径名称，而不能知晓输入的是一个
文件还是路径。这就意味着尝试使用\acode{simpleFind}将列出\acode{.c}结尾的目录已经具有相同扩展名的文件。

其次就是\acode{simpleFind}没有提供该如何遍历文件系统的控制。为什么这点很重要，可以考虑一下在拥有子版本管理的树形文件系统下，
进行源文件的搜索。子版本在每个它管理的路径下都会维护一个私有的\acode{.svn}路径；它们每一个包含了若干我们不需要考虑的子文件夹与文件。
虽然我们可以简单的过滤掉任何包含\acode{.svn}的情况，不过更有效的方式则是在第一时间就避免这些文件夹的遍历。

最后就是\acode{simpleFind}是严格执行的，因为它包含了一系列在\acode{IO}单子中所执行的 actions。如果我们有上百万的文件需要遍历，
我们则需要等待很久并且还会得到一个巨大的包含了百万名称的结果。这对于资源管理与响应速度而言都非常的不好。我们更加倾向于一个惰性流式的
结果。

\subsection*{谓词：从贫穷到富裕，同时保持 pure}

我们的谓词只能查看文件名称。这就包含了大量有趣的行为：例如当我们想要展示的文件大于给定的大小时。

一个比较简单的做法就是修改\acode{IO}：谓词的类型不再是\acode{FilePath -> Bool}，而改为\acode{FilePath -> IO Bool}。
这使得我们可以用任意 I/O 作为谓词函数的一部分。尽管这看起来很吸引人，但它也有潜在的问题：这样的谓词可能会有任意的副作用，因为返回
类型为 I/O a 的函数可以拥有任意的副作用。

让我们利用类型系统来编写更加可以预测，更是 bug 的代码：我们将通过避免 “IO” 污染来保持谓词的纯粹性。这样可以确保它们不会产生任何
讨厌的副作用。同时我们还会喂给它们更多的信息，这样它们就能获得我们想要的表达能力，而不会成为潜在的危险。

Haskell 的\acode{System.Directory}模块提供了一组有用的文件元数据。

\begin{lstlisting}[language=Haskell]
  ghci> :m +System.Director
\end{lstlisting}

\begin{itemize}
  \item 我们可以使用\acode{doesFileExist}与\acode{doesDirectoryExist}来判断一个输入是否是文件还是路径。近些年暂时还没有
        便捷的方法来查看其它的文件类型，例如命名通道，软硬链接等。

        \begin{lstlisting}[language=Haskell]
          ghci> :t doesFileExist
          doesFileExist :: FilePath -> IO Bool
          ghci> doesFileExist "."
          False
          ghci> :t doesDirectoryExist
          doesDirectoryExist :: FilePath -> IO Bool
          ghci> doesDirectoryExist "."
          True
        \end{lstlisting}
  \item \acode{getPermissions}函数允许我们得知对于一个文件或者路径的操作是否合法

        \begin{lstlisting}[language=Haskell]
          ghci> :t getPermissions
          getPermissions :: FilePath -> IO Permissions
          ghci> :i Permissions
          type Permissions :: *
          data Permissions
            = directory-1.3.6.2:System.Directory.Internal.Common.Permissions {readable :: Bool,
                                                                              writable :: Bool,
                                                                              executable :: Bool,
                                                                              searchable :: Bool}
                  -- Defined in ‘directory-1.3.6.2:System.Directory.Internal.Common’
          instance [safe] Eq Permissions
            -- Defined in ‘directory-1.3.6.2:System.Directory.Internal.Common’
          instance [safe] Ord Permissions
            -- Defined in ‘directory-1.3.6.2:System.Directory.Internal.Common’
          instance [safe] Show Permissions
            -- Defined in ‘directory-1.3.6.2:System.Directory.Internal.Common’
          instance [safe] Read Permissions
            -- Defined in ‘directory-1.3.6.2:System.Directory.Internal.Common’
          ghci> getPermissions "."
          Permissions {readable = True, writable = True, executable = False, searchable = True}
          ghci> :t searchable
          searchable :: Permissions -> Bool
          ghci> searchable it
        \end{lstlisting}
  \item 最后则是\acode{getModificationTime}可以告诉我们输入是何时被修改的：
        \begin{lstlisting}[language=Haskell]
          ghci> :t getModificationTime
          getModificationTime
            :: FilePath
               -> IO time-1.11.1.1:Data.Time.Clock.Internal.UTCTime.UTCTime
          ghci> getModificationTime "."
          2023-10-14 13:58:10.895659105 UTC
        \end{lstlisting}
\end{itemize}

那么对于新的谓词而言有多少数据是需要知道的呢？由于可以通过\acode{Permissions}来查看一个输入是否为文件还是路径，因此我们不再需要
\acode{doesFileExist}与\acode{doesDirectoryExist}。这样我们有了四个需要查看的数据：

\begin{lstlisting}[language=Haskell]
  import Control.Exception (bracket, handle)
  import Control.Monad (filterM)
  import Data.Time.Clock (UTCTime)
  import RecursiveContents (getRecursiveContents)
  import System.Directory (Permissions (..), getModificationTime, getPermissions)
  import System.FilePath (takeExtensions)
  import System.IO (IOMode (..), hClose, hFileSize, openFile)

  type Predicate =
    FilePath ->
    Permissions ->
    Maybe Integer ->
    UTCTime ->
    Bool
\end{lstlisting}

与原文不同之处在于导入部分，由于\acode{import System.Time (ClockTime(..))}已经废弃了，根据\acode{getModificationTime}
可知需要使用\acode{import Data.Time.Clock (UTCTime)}。

我们的\acode{Predicate}类型就是一个有着四个参数函数的别名。

注意谓词的返回类型是\acode{Bool}而不是\acode{IO Bool}：谓词是纯的，并不运行 I/O。有了这个类型，编写一个更具表达性的查询函数就
好办了。

\begin{lstlisting}[language=Haskell]
  getFileSize :: FilePath -> IO (Maybe Integer)
  getFileSize = undefined

  betterFind :: Predicate -> FilePath -> IO [FilePath]
  betterFind p path = getRecursiveContents path >>= filterM check
    where
      check name = do
        perms <- getPermissions name
        size <- getFileSize name
        modified <- getModificationTime name
        return $ p name perms size modified
\end{lstlisting}

我们暂时先跳过\acode{getFileSize}函数，稍后会进行讲解。

我们不能使用\acode{filter}来调用谓词\acode{p}，因为\acode{p}的纯性意味着它不能执行收集所需元数据所需的 I/O。

这时就需要一个我们并不熟悉的\acode{filterM}函数了，它的行为类似于普通的\acode{filter}函数，不过是在\acode{IO}单子中对谓词进行
计算，即允许谓词执行 I/O。

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Monad
  ghci> :t filterM
  filterM :: Applicative m => (a -> m Bool) -> [a] -> m [a]
\end{lstlisting}

\subsection*{安全的调整文件大小}

虽然\acode{System.Directory}没有提供文件大小的查询，不过我们可以用\acode{System.IO}来做。它包含了一个名为\acode{hFileSize}
的函数，可以返回一个文件的字节大小。

\begin{lstlisting}[language=Haskell]
  simpleFileSize :: FilePath -> IO Integer
  simpleFileSize path = do
    h <- openFile path ReadMode
    size <- hFileSize h
    hClose h
    return size
\end{lstlisting}

虽然这个函数可以工作，但是它还不能为我们所用。在\acode{betterFind}中，我们可以无条件的对任何地址输入调用\acode{getFileSize}；
如果输入的不是一个文件它会返回\acode{Nothing}，否则返回\acode{Just}。实际上该函数的输入不是一个文件或者不能打开文件（权限不够）时
会抛出异常。

以下是一个安全版本：

\begin{lstlisting}[language=Haskell]
  saferFileSize :: FilePath -> IO (Maybe Integer)
  saferFileSize path = handle errorHandler $ do
    h <- openFile path ReadMode
    size <- hFileSize h
    hClose h
    return $ Just size
    where
      errorHandler :: SomeException -> IO (Maybe Integer)
      errorHandler _ = return Nothing
\end{lstlisting}

这里与原文不同在于匿名函数\acode{handle (\_ -> return Nothing)}改成了\acode{errorHandler}，并标注了类型
\acode{errorHandler :: SomeException -> IO (Maybe Integer)}。（与第八章的处理方式一致）

函数体内部几乎是一致的，除了\acode{handle}子句。

这里的异常处理是只要有异常发生就返回\acode{Nothing}，其余的改动就是返回值被包裹了\acode{Just}。

\acode{saferFileSize}函数现在拥有了正确的类型签名，也不会再抛出任何异常了，不过它仍然不完整。这里只处理了\acode{openFile}的异常，
但是\acode{hFileSize}仍然会抛出异常，比如说命名管道。这样的异常会被\acode{handle}捕获，但是我们的\acode{hClose}永远不会被执行。

Haskell 的实现会在文件句柄不再使用时自动关闭，但是这要在垃圾回收时才会发生，而接下来垃圾回收的时间却不能保证。

文件句柄是稀有资源，这份稀有性是由操作系统决定的，比如 Linux 系统中一个进程默认同时打开文件的最大数量是 1024 个。

这不难想象一个场景，在调用了使用了\acode{saferFileSize}的\acode{betterFind}函数因为穷尽了最大文件开启数，而垃圾回收还没开始时，
程序崩溃了。

这是一种特别危险的 bug：它会在若干条件组合在一起时变得难以追踪。在\acode{betterFind}访问了足够多数量的非文件时句柄没有被关闭而达到了
进程最大文件开启数的上限，然后在垃圾回收还未发生之前又打开了另外的文件。

更糟糕的是，任何后续错误都是由程序中无法访问数据而引起，并且还没有垃圾回收。出现这样的 bug 依赖于程序结构，文件系统内容，以及当前程序的
运行时还未触发垃圾回收。

这样的问题在开发的过程中很容易被忽视，然后后续发生时会让诊断变得异常困难。

\subsubsection*{获取-使用-释放}

我们需要\acode{openFile}成功时\acode{hClose}能总是被调用。\acode{Control.Exception}模块为此提供了\acode{bracket}函数。

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Exception
  ghci> :type bracket
  bracket :: IO a -> (a -> IO b) -> (a -> IO c) -> IO c
\end{lstlisting}

\acode{bracket}函数接受三个 actions 参数。第一个 action 用于获取一个资源，第二个则是释放资源，第三个则是介于前面两者之间，让我们
称其为“使用” action。如果“获取” action 成功了，“释放” action \textit{总是}会被调用。这确保了资源总是能被释放。“使用”和“释放”
actions 分别传给了“获取” action。

当“使用” action 在执行时发生了异常，\acode{bracket}会调用“释放” action 然后再重新抛出异常。如果“使用” action 成功了，
\acode{bracket}会调用“释放” action 然后再返回”使用“ action 所返回的值。

我们现在可以编写一个完全安全的函数了：它不会抛出异常；也不会产生句柄垃圾而导致程序崩溃。

\begin{lstlisting}[language=Haskell]
  getFileSize :: FilePath -> IO (Maybe Integer)
  getFileSize path = handle errorHandler $
    bracket (openFile path ReadMode) hClose $ \h -> do
      size <- hFileSize h
      return (Just size)
    where
      errorHandler :: SomeException -> IO (Maybe Integer)
      errorHandler _ = return Nothing
\end{lstlisting}

让我们看一下这里的\acode{bracket}，首先是打开文件，返回打开文件的句柄，接着是关闭句柄，最后是对句柄调用\acode{hFileSize}并将结果
包装进\acode{Just}。

我们需要同时使用\acode{bracket}与\acode{handle}才能达成目的。前者能保证垃圾文件句柄不会堆积，后者确保异常被处理。

\subsection*{用于谓词的领域特定语言}

让我们尝试着写一个谓词，我们的谓词将会检查一个 C++ 源文件是否超过了 128KB。

\begin{lstlisting}[language=Haskell]
  myTest path _ (Just size) _ = takeExtension path == ".cpp" && size > 131072
  myTest _ _ _ _ = False
\end{lstlisting}

这看起来并不怎么样。谓词有四个参数，总是忽略其中两个，定义另外两个。我们当然可以做的更好，让我们编写一些让谓词变得更简洁的代码。

有时这类库被认为是\textit{内嵌领域特定语言}：我们使用编程语言的工具（因此是\textit{内嵌的}）来编写代码用以优雅的解决特类问题
（因此是\textit{领域特定的}）。

第一步首先是编写一个返回某个参数的函数。下面是从传入至\acode{Predicate}的参数中提取 path：

\begin{lstlisting}[language=Haskell]
  pathP path _ _ _ = path
\end{lstlisting}

如果不提供一个类型签名，Haskell 则会为该函数推导出一个非常通用的类型。这在未来可能会带来错误而难以解析，因此我们给\acode{pathP}
一个类型。

\begin{lstlisting}[language=Haskell]
  type InfoP a =
    FilePath -> -- path to directory entry
    Permissions -> -- permissions
    Maybe Integer -> -- file size (Nothing if not file)
    UTCTime -> -- last modified
    a

  pathP :: InfoP FilePath
  pathP path _ _ _ = path
\end{lstlisting}

我们创建了一个类型同义词使得可以将其用于其它类似结构函数。该类型同义词接受一个类型参数，这样我们就可以指定不同的结果类型。

\begin{lstlisting}[language=Haskell]
  sizeP :: InfoP Integer
  sizeP _ _ (Just size) _ = size
  sizeP _ _ Nothing _ = -1
\end{lstlisting}

实际上，本章较早之前所定义的\acode{Predicate}类型与\acode{InfoP Bool}是一致的。（因此我们可以去除\acode{Predicate}类型。）

那么\acode{pathP}与\acode{sizeP}怎么用呢？通过一点点粘合，可以将它们放入谓词中使用（\acode{P}后缀即意味着“predicate”）。

\begin{lstlisting}[language=Haskell]
  equalP :: (Eq a) => InfoP a -> a -> InfoP Bool
  -- equalP f k = \w x y z -> f w x y z == k
  equalP f k w x y z = f w x y z == k
\end{lstlisting}

\acode{equalP}的类型签名值得注意。它接受一个\acode{InfoP a}，同时兼容\acode{pathP}与\acode{sizeP}。它接受一个\acode{a}，
返回一个\acode{InfoP Bool}，即\acode{Predicate}的同义词。换言之，\acode{equalP}构建一个谓语。

\acode{equalP}函数通过返回一个匿名函数来工作。该匿名函数接受一个谓词作为参数，将其传递给\acode{f}，接着将其返回与\acode{k}作比较。

由于 Haskell 的所有函数都是柯里化的，这么编写\acode{equalP}实际上并不必要。我们可以省略匿名函数接着依赖柯里化来完成剩下的部分，
现在让我们来编写一个相同效果的函数。

\begin{lstlisting}[language=Haskell]
  equalP' :: (Eq a) => InfoP a -> a -> InfoP Bool
  equalP' f k w x y z = f w x y z == k
\end{lstlisting}

在继续探索之前，让我们将我们的模块加载至\textbf{ghci}。

\begin{lstlisting}[language=Haskell]
  ghci> :l BetterPredicate.hs
  [1 of 2] Compiling RecursiveContents ( RecursiveContents.hs, interpreted )
  [2 of 2] Compiling Main             ( BetterPredicate.hs, interpreted )
  Ok, two modules loaded.
\end{lstlisting}

让我们看看由这些函数所构建的谓词是否生效。

\begin{lstlisting}[language=Haskell]
  ghci> :t betterFind (sizeP `equalP` 1024)
  betterFind (sizeP `equalP` 1024) :: FilePath -> IO [FilePath]
\end{lstlisting}

注意我们并没有真正的调用\acode{betterFind}，不过却能确认表达式的类型。我们现在拥有了一个更具表现力的方式来展示所有相同大小的文件。

\subsubsection*{通过 lifting 避免重复}

除开\acode{equalP}，我们还可以编写其它的二元函数。我们倾向于不为每个定义都编写一个完整的定义，因为这看起来啰嗦而没有必要。

为此让我们使用 Haskell 的抽象能力。我们将\acode{equalP}的定义而不是直接调用\acode{(==)}，将其作为参数传递给希望调用的二元函数中。

\begin{lstlisting}[language=Haskell]
  liftP :: (a -> b -> c) -> InfoP a -> b -> InfoP c
  liftP q f k w x y z = f w x y z `q` k

  greaterP, lesserP :: (Ord a) => InfoP a -> a -> InfoP Bool
  greaterP = liftP (>)
  lesserP = liftP (<)
\end{lstlisting}

这里接受如\acode{(>)}这样的函数，转换它为另一个作用于不同上下文的函数，如\acode{greaterP}，这意味着将其\textit{提升 lifting}
至该上下文。这解释了函数名中带有\acode{lift}。Lifting 让我们复用代码并且减少重复的模式。在本书的后续章节中，我们将大量的使用它。

我们在提升一个函数时，通常会分别将其原始版本以及新版本称为\textit{unlifted}与\textit{lifted}。

通过这种方式，我们的\acode{q}（需要提升的函数）作为\acode{liftP}的第一个参数是经过深思熟虑的。这使得可以编写如\acode{greaterP}
以及\acode{lesserP}这样简洁的定义。相较于其它的语言，偏应用使得寻找“最佳”的参数顺序成为了 Haskell 中 API 设计中更为重要的环节。
在没有偏应用的语言中，参数的顺序在于使用习惯与方便性。而在 Haskell 中将参数设计在错误的位置，则会丢失偏应用所带来的简洁性。

我们可以通过组合子来复现一下这样的简洁性。例如，\acode{forM}在 2007 年之前并没有被加入至\acode{Control.Monad}模块中，更早之前人们
则会使用\acode{flip mapM}来替代。

\begin{lstlisting}[language=Haskell]
  ghci> :m +Control.Monad
  ghci> :t mapM
  mapM :: (Traversable t, Monad m) => (a -> m b) -> t a -> m (t b)
  ghci> :t forM
  forM :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
  ghci> :t flip mapM
  flip mapM
    :: (Traversable t, Monad m) => t a -> (a -> m b) -> m (t b)
\end{lstlisting}

与原文不同之处在于上述函数变得更加泛化了，从之前的只对列表生效变为了对所有满足\acode{Traversable} typeclass 的类型生效。

\subsubsection*{将谓词们粘合在一起}

如果我们希望组合谓词们，那么就可以遵循之前所做的那样：

\begin{lstlisting}[language=Haskell]
  simpleAndP :: InfoP Bool -> InfoP Bool -> InfoP Bool
  simpleAndP f g w x y z = f w x y z && g w x y z
\end{lstlisting}

现在我们了解了 lifting，那么减少之前必须为布尔值操作符所编写的代码量就变得很自然了。

\begin{lstlisting}[language=Haskell]
  liftP2 :: (a -> b -> c) -> InfoP a -> InfoP b -> InfoP c
  liftP2 q f g w x y z = f w x y z `q` g w x y z

  andP2 = liftP (&&)
  orP2 = liftP (||)
\end{lstlisting}

注意\acode{liftP2}跟之前的\acode{liftP}很像。实际上前者更通用，因为我们可以根据\acode{liftP2}来编写\acode{liftP}：

\begin{lstlisting}[language=Haskell]
  constP :: a -> InfoP a
  constP k _ _ _ _ = k

  liftP' q f k w x y z = f w x y z `q` constP k w x y z
\end{lstlisting}

\begin{anote}
  组合子 Combinators

  Haskell 中，我们将接受函数作为参数并返回新函数的函数成为组合子。
\end{anote}

现在我们有了些帮助函数，可以回到较早之前定义的\acode{myTest}函数了。

\begin{lstlisting}[language=Haskell]
  myTest :: (Ord a, Num a) => FilePath -> p1 -> Maybe a -> p2 -> Bool
  myTest path _ (Just size) _ = takeExtension path == ".cpp" && size > 131072
  myTest _ _ _ _ = False
\end{lstlisting}

那么该函数使用新的组合子会长什么样呢？

\begin{lstlisting}[language=Haskell]
  liftPath :: (FilePath -> a) -> InfoP a
  liftPath f w _ _ _ = f w

  myTest2 = (liftPath takeExtension `equalP` ".cpp") `andP` (sizeP `greaterP` 131072)
\end{lstlisting}

我们添加了一个最终的组合子，\acode{liftPath}，因为操作文件名是一个常用的操作。

\subsubsection*{定义与使用新的操作符}

我们还可以通过定义新的中缀操作符来让我们的领域特定语言更进一步。

\begin{lstlisting}[language=Haskell]
  -- explicit annotation
  (==?) :: InfoP String -> String -> InfoP Bool
  (==?) = equalP

  (&&?) :: InfoP Bool -> InfoP Bool -> InfoP Bool
  (&&?) = andP

  -- explicit annotation
  (>?) :: InfoP Integer -> Integer -> InfoP Bool
  (>?) = greaterP

  myTest3 = (liftPath takeExtension ==? ".cpp") &&? (sizeP >? 131072)
\end{lstlisting}

注意与原文不同之处在于\acode{(==?)}以及\acode{(>?)}加上了显式类型签名，因为在没有\acode{myTest3}时，编译器无法正确的进行类型推导
而导致编译错误。

我们选择如\acode{(==?)}这样的名称作为提升函数，这样可以在视觉上与原始函数对应。

上面定义中的圆括号是必要的，因为我们没有告诉 Haskell 新操作符的优先级或结合性。语言规定没有固定声明的操作符应被视为\acode{infixl 9}，
即在最高优先级从左到右求值。

我们可以通过为新操作符编写固定声明，第一步是找出未提升的操作符使得可以模拟它们。

\begin{lstlisting}[language=Haskell]
  ghci> :i ==
  type Eq :: * -> Constraint
  class Eq a where
    (==) :: a -> a -> Bool
    ...
          -- Defined in ‘GHC.Classes’
  infix 4 ==
  ghci> :i &&
  (&&) :: Bool -> Bool -> Bool    -- Defined in ‘GHC.Classes’
  infixr 3 &&
  ghci> :i >
  type Ord :: * -> Constraint
  class Eq a => Ord a where
    ...
    (>) :: a -> a -> Bool
    ...
          -- Defined in ‘GHC.Classes’
  infix 4 >
\end{lstlisting}

有了它们以后，我们可以编写一个不带圆括号的表达式，解析后与\acode{myTest3}一致：

\begin{lstlisting}[language=Haskell]
  infix 4 ==?
  infixr 3 &&?
  infix 4 >?

  myTest4 = liftPath takeExtension ==? ".cpp" &&? sizeP >? 131072
\end{lstlisting}

\subsection*{控制遍历}

\subsection*{密度，可读性与学习过程}

\subsection*{另一个角度看待遍历}

\subsection*{有用的编码指导}

\end{document}
