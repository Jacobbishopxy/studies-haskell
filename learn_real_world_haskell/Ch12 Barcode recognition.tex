\documentclass[./main.tex]{subfiles}

\begin{document}

本章我们将会使用第十章所编写的图像解析库来构建一个识别条形码的应用。

\subsection*{关于条形码}

绝大多数包装好的和批量生产的消费品上面都会有条形码。尽管在各个专门的领域都有若干的条形码系统，但消费品通常使用 UPC-A 或 EAN-13。前者是在美国
开发的，而后者则起源于欧洲。

EAN-13 开发晚于 UPC-A，它是 UPC-A 的超集。（实际上，UPC-A 已经在 2005 年宣布废弃了，尽管在美国它仍然被大量的使用。）任何可以识别 EAN-13
的软件或硬件也会自动处理 UPC-A 条形码。

正如其名，EAN-13 描述了一个 13 位数的序列，它被划分成四个组：

\begin{itemize}
  \item 开头的两位数描述了\textit{数字系统}。它可以表明制造商的国家，或是其它的一些分类，例如 ISBN（书籍身份）。
  \item 接下来的五位数则是生产商的 ID，通过国家的授权进行指定。
  \item 再接下来的五位数则是产品 ID，通过制造商指定。（小型的制造商可能有更长的制造商 ID 以及更短的产品 ID，但是它们加在一起仍然是十位数。）
  \item 最后一位则是\textit{校验数}，允许一个扫描器验证它扫描的位数字符串。
\end{itemize}

\subsubsection*{EAN-13 编码}

在我们关心 EAN-13 条形码的解码之前，我们需要理解它们是如何被编码的。EAN-13 所使用的系统有一点复杂。让我们首先从校验数开始，也就是字符串的
最后一个位数。

\begin{lstlisting}[language=Haskell]
  checkDigit :: (Integral a) => [a] -> a
  checkDigit ds = 10 - (sum products `mod` 10)
    where
      products = mapEveryOther (* 3) (reverse ds)

  mapEveryOther :: (a -> a) -> [a] -> [a]
  mapEveryOther f = zipWith ($) (cycle [f, id])
\end{lstlisting}

这是一种通过代码比口头描述更容易理解的算法。从字符串的右侧开始计算，每个连续的数字要么乘以 3，要么不动（\acode{cycle}函数会无限的重复它的输入
列表）。校验数则是它们的和（以 10 取模）与数字 10 之间的差。

条形码是一系列固定宽度的条码，黑色代表二元 “1” 位，白色代表 “0” 位。因此，相同数字的运行看前来像一个更粗的条码。

条形码中的位序列如下所示：

\begin{itemize}
  \item 前导保护序列，编码为 101.
  \item 一组六位数字，每个有七位宽。
  \item 另一个保护序列，编码为 01010.
  \item 一组六位以上的数字。
  \item 尾部的保护序列，编码为 101。
\end{itemize}

左边和右边组中的数字有单独的编码。左边用奇偶校验位编码，奇偶校验位编码条形码的第 13 位。

\subsection*{数组介绍}

在继续之前，以下是本章所需的模块导入：

\begin{lstlisting}[language=Haskell]
  import Control.Applicative ((<$>))
  import Control.Monad (forM_)
  import Data.Array (Array (..), bounds, elems, indices, ixmap, listArray, (!))
  import Data.ByteString.Lazy.Char8 qualified as L
  import Data.Char (digitToInt)
  import Data.Ix (Ix (..))
  import Data.List (foldl', group, sort, sortBy, tails)
  import Data.Map qualified as M
  import Data.Maybe (catMaybes, listToMaybe)
  import Data.Ratio (Ratio)
  import Data.Word (Word8)
  import Parse                                -- from Chapter 10
  import System.Environment (getArgs)
\end{lstlisting}

\textbf{注}：\acode{Parse}库从第十章而来。

条形码的编码过程很大程度上是表格驱动的，即使用位模式的小表来决定如何对每个数字进行编码。Haskell 基本的数据类型中列表和元组都不适合用于表格，
其包含的元素需要能被随机访问。列表需要线性的遍历才能访问第 k 个元素。元组没有这个问题，但是 Haskell 的类型系统使得很难编写一个函数来接受
元组和元素偏移量，并返回元组中偏移量处的元素。

常用的数据类型可供常数耗时的随机访问就是数组了。Haskell 提供了若干数字类型。这里我们将编码表格表达为字符串数组。

最简单的数组类型位于\acode{Data.Array}模块中，也正是我们现在所用的。与其它 Haskell 通常的类型一样，这些数组也都是不可变的。不可变数组
只有在创建时才能用值填充一次，其它时候是不能修改其内容的。（标准库同样提供了其它的数组类型，有些是可变的，只不过现在我们暂时还用不上。）

\begin{lstlisting}[language=Haskell]
  leftOddList =
    [ "0001101",
      "0011001",
      "0010011",
      "0111101",
      "0100011",
      "0110001",
      "0101111",
      "0111011",
      "0110111",
      "0001011"
    ]

  rightList = map complement <$> leftOddList
    where
      complement '0' = '1'
      complement '1' = '0'

  leftEvenList = map reverse rightList

  parityList =
    [ "111111",
      "110100",
      "110010",
      "110001",
      "101100",
      "100110",
      "100011",
      "101010",
      "101001",
      "100101"
    ]

  listToArray :: [a] -> Array Int a
  listToArray xs = listArray (0, l - 1) xs
    where
      l = length xs

  leftOddCodes, leftEvenCodes, rightCodes, parityCodes :: Array Int String
  leftOddCodes = listToArray leftOddList
  leftEvenCodes = listToArray leftEvenList
  rightCodes = listToArray rightList
  parityCodes = listToArray parityList
\end{lstlisting}

\acode{Data.Array}模块的\acode{listArray}函数将列表转为数组。第一个参数是数组所需的边界；第二个参数则是列表。

\acode{Array}的一个不寻常特征是，它的类型在它包含的数据和索引类型上都是参数化的。一维\acode{String}数组的类型是\acode{Array Int String}，
而二维则是\acode{Array (Int,Int) String}。

\begin{lstlisting}[language=Haskell]
  ghci> :m +Data.Array
  ghci> :t listArray
  listArray :: Ix i => (i, i) -> [e] -> Array i e
\end{lstlisting}

构造一个数组：

\begin{lstlisting}[language=Haskell]
  ghci> listArray (0,2) "foo"
  array (0,2) [(0,'f'),(1,'o'),(2,'o')]
\end{lstlisting}

注意我们指定了数组的上下界。这些界是包含边界的，即从 0 至 2 的数组包含了 0，1 以及 2。

\begin{lstlisting}[language=Haskell]
  ghci> listArray (0,3) [True,False,False,True,False]
  array (0,3) [(0,True),(1,False),(2,False),(3,True)]
  ghci> listArray (0,10) "too short"
  array (0,10) [(0,'t'),(1,'o'),(2,'o'),(3,' '),(4,'s'),(5,'h'),(6,'o'),(7,'r'),(8,'t'),(9,*** Exception: (Array.!): undefined array element
\end{lstlisting}

当数组被构建后，可以使用\acode{(!)}操作符根据索引来访问元素。

\begin{lstlisting}[language=Haskell]
  ghci> let a = listArray (0,14) ['a'..]
  ghci> a ! 2
  'c'
  ghci> a ! 100
  *** Exception: Ix{Integer}.index: Index (100) out of range ((0,14))
\end{lstlisting}

由于数组的构造函数允许指定数组的边界，我们无需使用类似于 C 语言那样基于零的边界。

\begin{lstlisting}[language=Haskell]
  ghci> let a = listArray (-9,5) ['a'..]
  ghci> a ! (-2)
  'h'
\end{lstlisting}

索引类型可以是任意\acode{Ix}类型的成员。例如\acode{Char}作为索引：

\begin{lstlisting}[language=Haskell]
  ghci> let a = listArray ('a','h') [97..]
  ghci> a ! 'e'
  101
\end{lstlisting}

创建一个高阶维度数组，我们可以使用\acode{Ix}实例的元组作为索引类型。以下是一个三维数组：

\begin{lstlisting}[language=Haskell]
  ghci> let a = listArray ((0,0,0),(9,9,9)) [0..]
  ghci> a ! (4,3,7)
  437
\end{lstlisting}

\subsubsection*{数组与惰性}

用于构造数组的列表，其元素数必须大于等于数组所需的元素。如果没有提供足够的元素则会在运行时抛出异常。该异常将何时出现取决于数组的具体实现。

这里我们使用的是一个非严格的数组类型。

\begin{lstlisting}[language=Haskell]
  ghci> let a = listArray (0,5) "bar"
  ghci> a ! 2
  'r'
  ghci> a ! 4
  *** Exception: (Array.!): undefined array element
\end{lstlisting}

Haskell 同样提供了严格数组，其行为就不同了。我们将在后续小节中讨论两者的优劣。

\subsubsection*{折叠数组}

\acode{bounds}函数返回一个描述了创建数组时的边界元组。\acode{indices}函数返回列表的每个索引。我们可以用其定义一些有用的折叠，因为
\acode{Data.Array}模块并没有定义任何折叠函数。

\begin{lstlisting}[language=Haskell]
  -- Strict left fold, similar to foldl' on lists
  foldA :: (Ix k) => (a -> b -> a) -> a -> Array k b -> a
  foldA f s a = go s (indices a)
    where
      go s (j : js) = let s' = f s (a ! j) in s' `seq` go s' js
      go s _ = s

  -- Strict left fold using the first element of the array as its starting value, similar to fold1 on lists
  foldA1 :: (Ix k) => (a -> a -> a) -> Array k a -> a
  foldA1 f a = foldA f (a ! fst (bounds a)) a
\end{lstlisting}

你可能会疑惑为什么数组模块并没有提供如此有用的折叠函数。这是因为一维数组与列表之间有一些显著的差异。例如自然而言，折叠有两个方向：从左向右，
从右向左。除此之外，每次只能折叠一个元素。

而对于二维的数组来说这根本行不通。首先，这时的折叠可以有多种方案。我们可能还是想每次只折叠单个元素，但是现在有了列折叠或行折叠的可能性。
最重要的是，对于一次一个元素的折叠，不再只有两个序列需要遍历。

换言之，对于二维数组，就存在若干可能的折叠方式组合，因此没有太多令人信服的理由为标准库选择少量排列。这个问题在高维情况下会更加复杂，因此最好
让开发人员编写适合自身应用需求的折叠。

\subsubsection*{修改数组元素}

对于不变数组而言，虽然存在“修改”函数，实际上并不常用。例如，\acode{accum}函数接受一个数组，以及一个\acode{(index, value)}对的列表，
返回一个新的被替换后的数组。

由于数组是不变的，修改一个元素就需要拷贝整个数组，这实际上是相当昂贵的。

另一个数组类型，\acode{Data.Array.Diff}模块中的\acode{DiffArray}，尝试在少量修改时减少消耗，但是在编写这本书的时候，它在实际运用中
还是太慢了。

\begin{anote}
  不要放弃希望

  在 Haskell 中实际上高效的修改一个数组是可能的，即通过\acode{ST}单子。我们将在第 26 章对其进行学习。
\end{anote}

\subsection*{对 EAN-13 条形码进行编码}

尽管我们的目标是\textit{解码}条形码，不过拥有一个编码器作为引用是很有帮助的。例如通过\acode{decode . encode}来检查输出是否正确，确保
我们代码的正确性。

\begin{lstlisting}[language=Haskell]
  encodeEAN13 :: String -> String
  encodeEAN13 = concat . encodeDigits . map digitToInt

  -- this function computes the check digit; don't pass one in.
  encodeDigits :: [Int] -> [String]
  encodeDigits s@(first : rest) =
    outerGuard : lefties ++ centerGuard : righties ++ [outerGuard]
    where
      (left, right) = splitAt 5 rest
      lefties = zipWith leftEncode (parityCodes ! first) left
      righties = map rightEncode (right ++ [checkDigit s])

  leftEncode :: Char -> Int -> String
  leftEncode '1' = (leftOddCodes !)
  leftEncode '0' = (leftEvenCodes !)

  rightEncode :: Int -> String
  rightEncode = (rightCodes !)

  outerGuard = "101"

  centerGuard = "01010"
\end{lstlisting}

字符串的编码长度是十二位数字，通过\acode{encodeDigits}来添加第十三个校验位数字。

条形码由两组六位数字进行编码，由守护序列位于两组其中以及两侧。那么其它数字呢？

左侧组的每个数字通过奇数或偶数编码，奇偶的选择取决于字符串中的第一位数字。如果第一位为零，那么左侧组则是由偶数进行编码；为一，则是由奇数进行
编码。这种方式的编码很优雅，它使得 EAN-13 条形码变得向后兼容旧的 UPC-A 标准。

\subsection*{解码器的约束}

在讨论解码钱，需要为条形码可以工作的类别设定一些约束。

手机相机或者网络相机输出的是 JPEG 图像，但是编写一个 JPEG 解码器需要占用若干章节。因此我们通过处理 netpbm 文件格式简化解析问题。我们将使用
第十章节所开发的解析组合子。

\subsection*{分治法}

我们的任务是将一个有效的条形码从相机图片中提取出来。我们可以将这个大问题切分成几个有序的子问题，它们每个都是独立可追溯的。

\begin{itemize}
  \item 将颜色数据转换成可处理的数据。
  \item 从图像中采样一个扫描线，并提取一组猜测数据，用以确定这一行中的编码数字可能会是什么。
  \item 从猜测数据中创建一个有效的解码列表。
\end{itemize}

更多的子问题将会在后续进行分割。

\subsection*{将彩色图像转换成易于处理的东西}

条形码实际上是黑白条的序列，我们希望编写一个简单的解析器，一个简单的表示是单色图像，其中每个像素不是黑色就是白色。

\subsubsection*{解析一个彩色图像}

Netbpm 彩色图像格式仅仅比第十章所提到的灰度图像格式更复杂一点。文件头的识别字符串是“P6”，剩下的头文件与灰度格式一致。图像的文件体内，每个像素都代表
三个字节，它们是红，绿，蓝。

我们将图像数据表示为二维的像素数组。这里使用数组是为了更好的学习它。对于应用而言，当然可以使用列表的列表。这里使用数组的唯一优点就是：可以高效的提取
一行数据。

\begin{lstlisting}[language=Haskell]
  type Pixel = Word8

  type RGB = (Pixel, Pixel, Pixel)

  type Pixmap = Array (Int, Int) RGB
\end{lstlisting}

我们提供了一些类型同义词使得类型签名更可读。

由于 Haskell 在布局数组方面给了我们相当大的自由，我们必须选择一种来表示。我们无需显式的存储图像的维度，因为可以使用\acode{bounds}函数来提取它们。

实际上解析器非常简短，感谢我们在第十章所开发的组合子。

\begin{lstlisting}[language=Haskell]
  parseRawPPM :: Parse Pixmap
  parseRawPPM =
    parseWhileWith w2c (/= '\n') ==> \header ->
      skipSpaces
        ==>& assert (header == "P6") "invalid raw header"
        ==>& parseNat
        ==> \width ->
          skipSpaces
            ==>& parseNat
            ==> \height ->
              skipSpaces
                ==>& parseNat
                ==> \maxValue ->
                  assert (maxValue == 255) "max value out of spec"
                    ==>& parseByte
                    ==>& parseTimes (width * height) parseRGB
                    ==> \pxs ->
                      identity (listArray ((0, 0), (width - 1, height - 1)) pxs)

  parseRGB :: Parse RGB
  parseRGB =
    parseByte ==> \r ->
      parseByte ==> \g ->
        parseByte ==> \b ->
          identity (r, g, b)

  parseTimes :: Int -> Parse a -> Parse [a]
  parseTimes 0 _ = identity []
  parseTimes n p = p ==> \x -> (x :) <$> parseTimes (n - 1) p
\end{lstlisting}

上述代码中仅需要注意的是\acode{parseTimes}，它调用其它解析器来解析一个给定的时间，再构建一个结果的列表。

\subsubsection*{灰度转化}

现在我们有了彩色图像的解析，我们需要将彩色数据转换成单色的。一个中间步骤就是转换数据为灰度。将 RGB 图像转换成灰度图像有一个广泛运用的公式，即基于每个颜色通道的
感知亮度。

\begin{lstlisting}[language=Haskell]
  luminance :: (Pixel, Pixel, Pixel) -> Pixel
  luminance (r, g, b) = round (r' * 0.30 + g' * 0.59 + b' * 0.11)
    where
      r' = fromIntegral r
      g' = fromIntegral g
      b' = fromIntegral b
\end{lstlisting}

Haskell 的数组是\acode{Functor} typeclass 的成员，所以我们可以使用\acode{fmap}来讲整个图像，或是单个扫描行，从彩色转为灰度。

\begin{lstlisting}[language=Haskell]
  type Greymap = Array (Int, Int) Pixel

  pixmapToGreymap :: Pixmap -> Greymap
  pixmapToGreymap = fmap luminance
\end{lstlisting}

\acode{pixmapToGreymap}函数仅用于解释。因为我们将仅检查一个条形码图像的某几行，没有必要做额外的工作来转换我们永远用不上的序列。

\subsubsection*{灰度至二进制以及类型安全}

下一个子问题是将灰度图像转换为一个二值图像，即每个像素要么是开要么是闭。

在一个图像处理应用中，需要处理大量的数字，因此很容易为了几个不同的目的重用相同的数字类型。例如使用\acode{Pixel}类型来表述 on/off 状态，使用转换将数字一来代表“on”
数字零“off”。

然而像这样为了多个目的而重用类型很快会带来潜在的混乱。为了判断一个“Pixel”是否为一个数值或是一个 on/off 值，我们不再可以简单的通过观察类型签名而知。在某些上下文中，
我们可以很容易使用包含“错误类型的数字”的值，并且编译器不会对其捕获，因为类型是正确的。

我们可以尝试引入类型别称来解决这个问题。同样的声明\acode{Pixel}作为\acode{Word8}的同义词，再使用\acode{Bit}类型作为\acode{Pixel}的同义词。虽然这可以提高可读性，
但是类型同义词仍然无法令编译器为我们做为何有效的检查。

编译器会将\acode{Pixel}与\acode{Bit}视为同样的类型，所以它不能捕获，例如在期望\acode{Bit}值为零或一这样的函数中使用\acode{Pixel}或是 253 值，这样的异常。

如果我们自定义单色类型，编译器则会阻止我们不小心混合了其它的类型。

\begin{lstlisting}[language=Haskell]
  data Bit = Zero | One deriving (Eq, Show)

  threshold :: (Ix k, Integral a) => Double -> Array k a -> Array k Bit
  threshold n a = binary <$> a
    where
      binary i
        | i < pivot = Zero
        | otherwise = One
      pivot = round $ least + (greatest - least) * n
      least = fromIntegral $ choose (<) a
      greatest = fromIntegral $ choose (>) a
      choose f = foldA1 $ \x y -> if f x y then x else y
\end{lstlisting}

我们的\acode{threshold}函数计算了作为输入的数组的最大最小值。它接受这些值和一个介于 0 到 1 之间的阈值，并计算一个“枢轴”值。接着数组中的每个值，如果其值小于枢轴值，返回
\acode{Zero}，否则\acode{One}。

\subsection*{我们对图像做了什么}

\subsection*{寻找匹配的位数}

\subsubsection*{运行长度编码}

\subsubsection*{缩放运行长度并找到近似匹配}

\subsubsection*{列表表达式}

\subsubsection*{记住匹配的奇偶}

\subsubsection*{另一种惰性，键盘上的}

\subsubsection*{列表切分}

\subsubsection*{生成候选位数列表}

\subsection*{没有数组或哈希表的生活}

\subsubsection*{解决方案的森林}

\subsubsection*{maps 的简介}

\subsubsection*{类型约束}

\subsubsection*{部分应用程序的笨拙}

\subsubsection*{从 API 开始}

\subsection*{将位数变为答案}

\subsubsection*{并行的校验数}

\subsubsection*{通过第一位数完成求解 map}

\subsubsection*{寻找正确的序列}

\subsection*{处理行数据}

\subsection*{合并所有}

\subsection*{一些开发风格的评论}

\end{document}
