\documentclass[./main.tex]{subfiles}

\begin{document}

本章我们将会使用第十章所编写的图像解析库来构建一个识别条形码的应用。

\subsection*{关于条形码}

绝大多数包装好的和批量生产的消费品上面都会有条形码。尽管在各个专门的领域都有若干的条形码系统，但消费品通常使用 UPC-A 或 EAN-13。前者是在美国
开发的，而后者则起源于欧洲。

EAN-13 开发晚于 UPC-A，它是 UPC-A 的超集。（实际上，UPC-A 已经在 2005 年宣布废弃了，尽管在美国它仍然被大量的使用。）任何可以识别 EAN-13
的软件或硬件也会自动处理 UPC-A 条形码。

正如其名，EAN-13 描述了一个 13 位数的序列，它被划分成四个组：

\begin{itemize}
  \item 开头的两位数描述了\textit{数字系统}。它可以表明制造商的国家，或是其它的一些分类，例如 ISBN（书籍身份）。
  \item 接下来的五位数则是生产商的 ID，通过国家的授权进行指定。
  \item 再接下来的五位数则是产品 ID，通过制造商指定。（小型的制造商可能有更长的制造商 ID 以及更短的产品 ID，但是它们加在一起仍然是十位数。）
  \item 最后一位则是\textit{校验数}，允许一个扫描器验证它扫描的位数字符串。
\end{itemize}

\subsubsection*{EAN-13 编码}

在我们关心 EAN-13 条形码的解码之前，我们需要理解它们是如何被编码的。EAN-13 所使用的系统有一点复杂。让我们首先从校验数开始，也就是字符串的
最后一个位数。

\begin{lstlisting}[language=Haskell]
  checkDigit :: (Integral a) => [a] -> a
  checkDigit ds = 10 - (sum products `mod` 10)
    where
      products = mapEveryOther (* 3) (reverse ds)

  mapEveryOther :: (a -> a) -> [a] -> [a]
  mapEveryOther f = zipWith ($) (cycle [f, id])
\end{lstlisting}

这是一种通过代码比口头描述更容易理解的算法。从字符串的右侧开始计算，每个连续的数字要么乘以 3，要么不动（\acode{cycle}函数会无限的重复它的输入
列表）。校验数则是它们的和（以 10 取模）与数字 10 之间的差。

条形码是一系列固定宽度的条码，黑色代表二元 “1” 位，白色代表 “0” 位。因此，相同数字的运行看前来像一个更粗的条码。

条形码中的位序列如下所示：

\begin{itemize}
  \item 前导保护序列，编码为 101.
  \item 一组六位数字，每个有七位宽。
  \item 另一个保护序列，编码为 01010.
  \item 一组六位以上的数字。
  \item 尾部的保护序列，编码为 101。
\end{itemize}

左边和右边组中的数字有单独的编码。左边用奇偶校验位编码，奇偶校验位编码条形码的第 13 位。

\subsection*{数组介绍}

在继续之前，以下是本章所需的模块导入：

\begin{lstlisting}[language=Haskell]
  import Control.Applicative ((<$>))
  import Control.Monad (forM_)
  import Data.Array (Array (..), bounds, elems, indices, ixmap, listArray, (!))
  import Data.ByteString.Lazy.Char8 qualified as L
  import Data.Char (digitToInt)
  import Data.Ix (Ix (..))
  import Data.List (foldl', group, sort, sortBy, tails)
  import Data.Map qualified as M
  import Data.Maybe (catMaybes, listToMaybe)
  import Data.Ratio (Ratio)
  import Data.Word (Word8)
  import Parse                                -- from Chapter 10
  import System.Environment (getArgs)
\end{lstlisting}

\textbf{注}：\acode{Parse}库从第十章而来。

条形码的编码过程很大程度上是表格驱动的，即使用位模式的小表来决定如何对每个数字进行编码。Haskell 基本的数据类型中列表和元组都不适合用于表格，
其包含的元素需要能被随机访问。列表需要线性的遍历才能访问第 k 个元素。元组没有这个问题，但是 Haskell 的类型系统使得很难编写一个函数来接受
元组和元素偏移量，并返回元组中偏移量处的元素。

常用的数据类型可供常数耗时的随机访问就是数组了。Haskell 提供了若干数字类型。这里我们将编码表格表达为字符串数组。

最简单的数组类型位于\acode{Data.Array}模块中，也正是我们现在所用的。与其它 Haskell 通常的类型一样，这些数组也都是不可变的。不可变数组
只有在创建时才能用值填充一次，其它时候是不能修改其内容的。（标准库同样提供了其它的数组类型，有些是可变的，只不过现在我们暂时还用不上。）

\begin{lstlisting}[language=Haskell]
  leftOddList =
    [ "0001101",
      "0011001",
      "0010011",
      "0111101",
      "0100011",
      "0110001",
      "0101111",
      "0111011",
      "0110111",
      "0001011"
    ]

  rightList = map complement <$> leftOddList
    where
      complement '0' = '1'
      complement '1' = '0'

  leftEvenList = map reverse rightList

  parityList =
    [ "111111",
      "110100",
      "110010",
      "110001",
      "101100",
      "100110",
      "100011",
      "101010",
      "101001",
      "100101"
    ]

  listToArray :: [a] -> Array Int a
  listToArray xs = listArray (0, l - 1) xs
    where
      l = length xs

  leftOddCodes, leftEvenCodes, rightCodes, parityCodes :: Array Int String
  leftOddCodes = listToArray leftOddList
  leftEvenCodes = listToArray leftEvenList
  rightCodes = listToArray rightList
  parityCodes = listToArray parityList
\end{lstlisting}

\acode{Data.Array}模块的\acode{listArray}函数将列表转为数组。第一个参数是数组所需的边界；第二个参数则是列表。

\acode{Array}的一个不寻常特征是，它的类型在它包含的数据和索引类型上都是参数化的。一维\acode{String}数组的类型是\acode{Array Int String}，
而二维则是\acode{Array (Int,Int) String}。

\begin{lstlisting}[language=Haskell]
  ghci> :m +Data.Array
  ghci> :t listArray
  listArray :: Ix i => (i, i) -> [e] -> Array i e
\end{lstlisting}

构造一个数组：

\begin{lstlisting}[language=Haskell]
  ghci> listArray (0,2) "foo"
  array (0,2) [(0,'f'),(1,'o'),(2,'o')]
\end{lstlisting}

注意我们指定了数组的上下界。这些界是包含边界的，即从 0 至 2 的数组包含了 0，1 以及 2。

\begin{lstlisting}[language=Haskell]
  ghci> listArray (0,3) [True,False,False,True,False]
  array (0,3) [(0,True),(1,False),(2,False),(3,True)]
  ghci> listArray (0,10) "too short"
  array (0,10) [(0,'t'),(1,'o'),(2,'o'),(3,' '),(4,'s'),(5,'h'),(6,'o'),(7,'r'),(8,'t'),(9,*** Exception: (Array.!): undefined array element
\end{lstlisting}

当数组被构建后，可以使用\acode{(!)}操作符根据索引来访问元素。

\begin{lstlisting}[language=Haskell]
  ghci> let a = listArray (0,14) ['a'..]
  ghci> a ! 2
  'c'
  ghci> a ! 100
  *** Exception: Ix{Integer}.index: Index (100) out of range ((0,14))
\end{lstlisting}

由于数组的构造函数允许指定数组的边界，我们无需使用类似于 C 语言那样基于零的边界。

\begin{lstlisting}[language=Haskell]
  ghci> let a = listArray (-9,5) ['a'..]
  ghci> a ! (-2)
  'h'
\end{lstlisting}

索引类型可以是任意\acode{Ix}类型的成员。例如\acode{Char}作为索引：

\begin{lstlisting}[language=Haskell]
  ghci> let a = listArray ('a','h') [97..]
  ghci> a ! 'e'
  101
\end{lstlisting}

创建一个高阶维度数组，我们可以使用\acode{Ix}实例的元组作为索引类型。以下是一个三维数组：

\begin{lstlisting}[language=Haskell]
  ghci> let a = listArray ((0,0,0),(9,9,9)) [0..]
  ghci> a ! (4,3,7)
  437
\end{lstlisting}

\subsubsection*{数组与惰性}

用于构造数组的列表，其元素数必须大于等于数组所需的元素。如果没有提供足够的元素则会在运行时抛出异常。该异常将何时出现取决于数组的具体实现。

这里我们使用的是一个非严格的数组类型。

\begin{lstlisting}[language=Haskell]
  ghci> let a = listArray (0,5) "bar"
  ghci> a ! 2
  'r'
  ghci> a ! 4
  *** Exception: (Array.!): undefined array element
\end{lstlisting}

Haskell 同样提供了严格数组，其行为就不同了。我们将在后续小节中讨论两者的优劣。

\subsubsection*{折叠数组}

\acode{bounds}函数返回一个描述了创建数组时的边界元组。\acode{indices}函数返回列表的每个索引。我们可以用其定义一些有用的折叠，因为
\acode{Data.Array}模块并没有定义任何折叠函数。

\begin{lstlisting}[language=Haskell]
  -- Strict left fold, similar to foldl' on lists
  foldA :: (Ix k) => (a -> b -> a) -> a -> Array k b -> a
  foldA f s a = go s (indices a)
    where
      go s (j : js) = let s' = f s (a ! j) in s' `seq` go s' js
      go s _ = s

  -- Strict left fold using the first element of the array as its starting value, similar to fold1 on lists
  foldA1 :: (Ix k) => (a -> a -> a) -> Array k a -> a
  foldA1 f a = foldA f (a ! fst (bounds a)) a
\end{lstlisting}

你可能会疑惑为什么数组模块并没有提供如此有用的折叠函数。这是因为一维数组与列表之间有一些显著的差异。例如自然而言，折叠有两个方向：从左向右，
从右向左。除此之外，每次只能折叠一个元素。

而对于二维的数组来说这根本行不通。首先，这时的折叠可以有多种方案。我们可能还是想每次只折叠单个元素，但是现在有了列折叠或行折叠的可能性。
最重要的是，对于一次一个元素的折叠，不再只有两个序列需要遍历。

换言之，对于二维数组，就存在若干可能的折叠方式组合，因此没有太多令人信服的理由为标准库选择少量排列。这个问题在高维情况下会更加复杂，因此最好
让开发人员编写适合自身应用需求的折叠。

\subsubsection*{修改数组元素}

% TODO

\subsection*{对 EAN-13 条形码进行编码}

\subsection*{解码器的约束}

\subsection*{分治法}

\subsection*{将彩色图像转换成易于处理的东西}

\subsubsection*{解析一个彩色图像}

\subsubsection*{灰度转化}

\subsubsection*{灰度至二进制以及类型安全}

\subsection*{我们对图像做了什么}

\subsection*{寻找匹配的位数}

\subsubsection*{运行长度编码}

\subsubsection*{缩放运行长度并找到近似匹配}

\subsubsection*{列表表达式}

\subsubsection*{记住匹配的奇偶}

\subsubsection*{另一种惰性，键盘上的}

\subsubsection*{列表切分}

\subsubsection*{生成候选位数列表}

\subsection*{没有数组或哈希表的生活}

\subsubsection*{解决方案的森林}

\subsubsection*{maps 的简介}

\subsubsection*{类型约束}

\subsubsection*{部分应用程序的笨拙}

\subsubsection*{从 API 开始}

\subsection*{将位数变为答案}

\subsubsection*{并行的校验数}

\subsubsection*{通过第一位数完成求解 map}

\subsubsection*{寻找正确的序列}

\subsection*{处理行数据}

\subsection*{合并所有}

\subsection*{一些开发风格的评论}

\end{document}
