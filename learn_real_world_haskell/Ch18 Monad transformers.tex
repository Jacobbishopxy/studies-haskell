\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{动机：避免样板}

单子提供了一种强大的方式来构建具有效果的计算。每个标准单子都专门做一件事。在实际代码中，我们经常需要能够一次使用几个效果。

回忆一下第十章开发的\acode{Parse}类型。在介绍单子的时候，我们提到了这个类型是一个伪装的状态单子。我们的单子比标准的\acode{State}单子更加的复杂，因为它使用了
\acode{Either}类型来容忍解析错误。这个例子中，如果一个解析提前出现了，我们是希望停止解析而不是继续带着破损的状态。我们的单子结合了携带状态的效果和提前退出的效果。

正常的\acode{State}单子不允许我们以这种方式逃离；它仅携带状态。它使用\acode{fail}的默认实现：即调用\acode{error}，它跑出一个在纯代码中无法捕获的异常。因此，
\acode{State}单子允许失败，而这种能力实际上没有任何用处。（再次声明，我们建议尽量避免使用\acode{fail}！）

如果能够以某种方式采用标准的\acode{State}单子，并在其中添加错误处理，而不需要大量手工构建自定义单子，那将是最为理想的。\acode{mtl}库中的标准单子不允许我们组合
它们。相反，该库提供了一组\textit{单子转换}来实现相同的结果。

一个单子转换类似于普通的单子，但它不是一个独立的实体：相反，它修改底层单子的行为。\acode{mtl}库中的大多数单子都有等效的转换。根据惯例，单子转换的版本具有相同的名称，
末尾有一个\acode{T}。例如，与\acode{State}等价的转换就是\acode{StateT}；它将可变状态添加到底层单子中。\acode{WriterT}单子转换使得在堆叠在另一个单子上时
写入数据成为可能。

\subsection*{简单单子转换案例}

在介绍单子转换之前，看一下用已经熟悉的技术编写的函数。下面的函数递归到一个目录树，并返回它在树的每级找到的条目数列表。

\begin{lstlisting}[language=Haskell]

  module CountEntries
    ( listDirectory,
      countEntriesTrad,
    )
  where

  import Control.Monad (forM, liftM)
  import System.Directory (doesDirectoryExist, getDirectoryContents)
  import System.FilePath ((</>))

  listDirectory :: FilePath -> IO [FilePath]
  listDirectory = liftM (filter notDots) . getDirectoryContents
    where
      notDots p = p /= "." && p /= ".."

  countEntriesTrad :: FilePath -> IO [(FilePath, Int)]
  countEntriesTrad path = do
    contents <- listDirectory path
    rest <- forM contents $ \name -> do
      let newName = path </> name
      isDir <- doesDirectoryExist newName
      if isDir
        then countEntriesTrad newName
        else return []
    return $ (path, length contents) : concat rest
\end{lstlisting}

现在我们来看看如何使用 writer 单子来实现同样的目的。由于这个单子允许我们记录任何需要的值，因此不需要显式的构建结果。

因为我们的函数必须在\acode{IO}单子中执行，这样它才能遍历目录，所以不能直接使用\acode{Writer}单子。相反，我们使用\acode{WriterT}向\acode{IO}添加记录功能。

普通的\acode{Writer}单子有两个类型参数，因此这里更为合适的写法是\acode{Writer w a}。第一个参数\acode{w}是要记录的值的类型，而\acode{a}则是\acode{Monad}
typeclass 通常所需要的类型。因此\acode{Writer [(FilePath, Int)] a}是一个记录目录名称和大小列表的 writer 单子。

\acode{WriterT}转换拥有类似的结构，不过它添加了另一个类型参数\acode{m}：这正是增强其行为的底层单子。\acode{WriterT}的完整签名为\acode{WriterT w m a}。

因为要遍历目录，这需要访问\acode{IO}单子，所以将 Writer 堆栈在\acode{IO}单子的顶部。单子转换和底层单子的组合将具有\acode{WriterT [(FilePath, Int)] IO a}
类型。这个单子转换和单子的堆栈本身就是一个单子。

\begin{lstlisting}[language=Haskell]
  module CountEntriesT
    ( countEntries,
    )
  where

  import Control.Monad
  import Control.Monad.Trans
  import Control.Monad.Writer
  import CountEntries (listDirectory)
  import System.Directory (doesDirectoryExist)
  import System.FilePath ((</>))

  countEntries :: FilePath -> WriterT [(FilePath, Int)] IO ()
  countEntries path = do
    contents <- liftIO . listDirectory $ path
    tell [(path, length contents)]
    forM_ contents $ \name -> do
      let newName = path </> name
      isDir <- liftIO . doesDirectoryExist $ newName
      when isDir $ countEntries newName
\end{lstlisting}

这段代码与之前的版本没有太大的不同。我们使用\acode{liftIO}在必要的地方公开\acode{IO}单子，并使用\acode{tell}来记录对目录的访问。

要使代码能被运行还必须使用\acode{WriterT}的一个执行函数：

\begin{lstlisting}[language=Haskell]
  ghci> :t runWriterT
  runWriterT :: WriterT w m a -> m (a, w)
  ghci> :t execWriterT
  execWriterT :: Monad m => WriterT w m a -> m w
\end{lstlisting}

这些函数执行操作，移除\acode{WriteT}包装并给出一个封装在底层单子中的结果。\acode{runWriterT}函数既提供操作的结果也提供运行时记录的内容，而\acode{execWriteT}
会丢弃结果，值提供记录的内容。

\begin{lstlisting}[language=Haskell]
  ghci> :l CountEntriesT.hs
  [1 of 2] Compiling CountEntries     ( CountEntries.hs, interpreted )
  [2 of 2] Compiling CountEntriesT    ( CountEntriesT.hs, interpreted )
  Ok, two modules loaded.
  ghci> :t countEntries ".."
  countEntries ".." :: WriterT [(FilePath, Int)] IO ()
  ghci> :t execWriterT (countEntries "..")
  execWriterT (countEntries "..") :: IO [(FilePath, Int)]
  ghci> take 4 `liftM` execWriterT (countEntries "..")
  [("..",6),("../dist-newstyle",2),("../dist-newstyle/cache",8),("../dist-newstyle/tmp",0)]
\end{lstlisting}

我们在\acode{IO}上使用\acode{WriterT}，因为没有\acode{IOT}单子转换。每当我们使用一个或多个单子转换的\acode{IO}单子时，\acode{IO}总是在堆栈的底部。

\subsection*{单子和单子转换中的常见模式}

\acode{mtl}库中大多数的单子和单子转换都遵循着一些关于名称和 typeclasses 的通用模式。

为了解释这些规则，我们将专注于一个单子：reader 单子。reader 的 API 由\acode{MonadReader} typeclass 详细说明。大多数\acode{mtl}单子都有着类似命名的
typeclasses：\acode{MonadWriter}定义了 writer 单子，以此类推。

\begin{lstlisting}[language=Haskell]
  class (Monad m) => MonadReader r m | m -> r where
    ask   :: m r
    local :: (r -> r) -> m a -> m a
\end{lstlisting}

类型变量\acode{r}表示 reader 单子所携带的不可变状态。\acode{Reader r}单子是\acode{MonadReader}类的一个实例，即\acode{ReaderT r m}单子转换。这个模式同样
也被其他\acode{mtl}单子所用：通常存在实体单子以及一个单子转换，它们每个都是用来定义单子 API 的 typeclass 实例。

回到 reader 单子，我们尚未接触到\acode{local}函数。它通过\acode{r -> r}函数临时改变当前环境，同时在修改后的环境中执行其操作。为了更好的理解，以下是一个简单的
示例：

\begin{lstlisting}[language=Haskell]
  {-# LANGUAGE FlexibleContexts #-}

  import Control.Monad.Reader

  myName :: (MonadReader String m) => String -> m String
  myName step = do
    name <- ask
    return (step ++ ", I am " ++ name)

  localExample :: Reader String (String, String, String)
  localExample = do
    a <- myName "First"
    b <- local (++ "dy") (myName "Second")
    c <- myName "Third"
    return (a, b, c)
\end{lstlisting}

注：需要添加\acode{FlexibleContexts}扩展，否则\acode{myName}无法编译。

在\textbf{ghci}中执行\acode{localExample}操作时，我们可以看到改变环境的效果局限于一处：

\begin{lstlisting}[language=Haskell]
  ghci> :l LocalReader.hs
  [1 of 2] Compiling Main             ( LocalReader.hs, interpreted )
  Ok, one module loaded.
  ghci> runReader localExample "Fred"
  ("First, I am Fred","Second, I am Freddy","Third, I am Fred")
\end{lstlisting}

当底层单子\acode{m}是\acode{MonadIO}的一个实例时，\acode{mtl}库提供了\acode{ReaderT r m}的实例，以及其它的一些 typeclasses。例如：

\begin{lstlisting}[language=Haskell]
  instance (Monad m) => Functor (ReaderT r m) where
    ...

  instance (MonadIO m) => MonadIO (ReaderT r m) where
    ...

  instance (MonadPlus m) => MonadPlus (ReaderT r m) where
    ...
\end{lstlisting}

再次声明，大多数\acode{mtl}单子转换都定义了这样的实例，以便我们更容易的使用它们。

\subsection*{堆叠多个单子转换}

正如之前提到的，当我们将单子转换堆叠在普通单子上时，结果便是另一个单子。这表明我们可以再次将单子转换堆叠在合并的单子之上，以提供新的单子，实际上这是一件很常见的事。
在什么情况下可能需要创建这样一个堆栈？

\begin{enumerate}
  \item 如果需要与外界沟通，我们将在堆栈的基础上使用\acode{IO}；否则得到的是一些正常的单子。
  \item 如果添加了一层\acode{ReaderT}，我们将获得对配置信息只读的权限。
  \item 添加了一层\acode{StateT}，将会得到可控修改的全局状态。
  \item 当需要将事件输出到日志时，添加一层\acode{WriterT}。
\end{enumerate}

这个方法的强大之处在于，我们可以根据确切需求定制堆栈，指定我们想要支持的效果类型。

下面是一个堆叠单子转换操作的例子，这里是之前开发的\acode{countEntries}函数。我们将修改它，使其递归到目录树的深度不超过给定的量，并记录它达到的最大深度。

\begin{lstlisting}[language=Haskell]
  import Control.Monad.Reader
  import Control.Monad.State
  import System.Directory
  import System.FilePath

  data AppConfig = AppConfig
    { cfgMaxDepth :: Int
    }
    deriving (Show)

  data AppState = AppState
    { stDeepestReached :: Int
    }
    deriving (Show)
\end{lstlisting}

我们使用\acode{ReaderT}来存储配置数据，即将要实现的最大的递归深度。同样使用\acode{StateT}来记录递归过程时所达到的最大深度。

\begin{lstlisting}[language=Haskell]
  type App = ReaderT AppConfig (StateT AppState IO)
\end{lstlisting}

我们的转换堆叠由\acode{IO}打底，接着是\acode{StateT}，最后是\acode{ReaderT}在最上层。这种情况下无论是\acode{ReaderT}还是\acode{WriterT}在上层都没有区别，
但是\acode{IO}必须在最底层。

即使是一小堆单子转换也会很快产生一个笨拙的类型名称。我们可以使用类型别名来减少编写类型签名的长度。

\begin{anote}
  缺失的类型参数去哪里了？

  你可能已经注意到了\acode{type}别名并没有通常的类型参数\acode{a}用于 monadic 类型：

  \begin{lstlisting}[language=Haskell]
    type App2 a = ReaderT AppConfig (StateT AppState IO) a
  \end{lstlisting}

  \acode{App}与\acode{App2}两者作为普通的类型签名都是能正常工作。差别出现在当我们尝试使用它们去构建另一个类型时：假设我们希望添加另一个单子转换到堆栈上：编译器将
  允许\acode{WriterT [String] App a}，但拒绝\acode{WriterT [String] App2 a}。

  这是因为 Haskell 并不允许我们偏应用一个类型别名。\acode{App}的别名并不带有一个类型参数，这就不会造成问题。但是由于\acode{App2}接受一个类型参数，那么当我们希望
  使用\acode{App2}来创建另一个类型时，我们就必须为此提供某些类型用于类型参数。

  这个约束仅局限于类型别名。当创建一个单子转换堆栈是，我们通常会通过\acode{newtype}（将在后面见到）来包装。这样的话，我们就杜绝了此类型的问题。
\end{anote}

单子堆栈的执行函数很简单：

\begin{lstlisting}[language=Haskell]
  runApp :: App a -> Int -> IO (a, AppState)
  runApp k maxDepth =
    let cfg = AppConfig maxDepth
        stt = AppState 0
     in runStateT (runReaderT k cfg) stt
\end{lstlisting}

应用中的\acode{runReaderT}移除了\acode{ReaderT}转换的包装，而\acode{runStateT}移除了\acode{StateT}的包装，最后将结果放置到\acode{IO}单子上。

\begin{lstlisting}[language=Haskell]
  constrainedCount :: Int -> FilePath -> App [(FilePath, Int)]
  constrainedCount curDepth path = do
    contents <- liftIO . listDirectory $ path
    cfg <- ask
    rest <- forM contents $ \name -> do
      let newPath = path </> name
      isDir <- liftIO $ doesDirectoryExist newPath
      if isDir && curDepth < cfgMaxDepth cfg
        then do
          let newDepth = curDepth + 1
          st <- get
          when (stDeepestReached st < newDepth) $ put st {stDeepestReached = newDepth}
          constrainedCount newDepth newPath
        else return []
    return $ (path, length contents) : concat rest
\end{lstlisting}

我们可以在单子堆栈中编写应用程序的大部分命令式代码，类似于我们的\acode{App}单子。在实际的程序中，我们会携带更复杂的配置数据，但是我们仍然会使用\acode{ReaderT}来
使其保持只读和需要时的隐藏。我们将有更多的可变状态需要管理，但我们仍然使用\acode{StateT}来封装它。

\subsubsection*{隐藏工序}

%

\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}



\begin{lstlisting}[language=Haskell]

\end{lstlisting}

\subsection*{向下移动堆栈}

\subsubsection*{当需要显式 lifting 时}

\subsection*{通过构建一个单子转换来了解它}

\subsubsection*{创建一个单子转换}
\subsubsection*{更多的 typeclass 实例}

\subsubsection*{将 Parse 类型替换为单子堆栈}

\subsection*{转换堆栈的顺序很重要}

\subsection*{透视单子和单子转换}

\subsubsection*{对于纯代码的干扰}

\subsubsection*{超出定义的顺序}

\subsubsection*{运行时开支}

\subsubsection*{笨拙的接口}

\subsubsection*{将全部合起来}

\end{document}
