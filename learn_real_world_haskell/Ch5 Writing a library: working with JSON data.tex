\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{在 Haskell 中表示 JSON}

首先是在 Haskell 中定义 JSON 这个数据，这里使用代数数据类型来表达 JSON 类型的范围。

\begin{lstlisting}[language=Haskell]
  data JValue
    = JString String
    | JNumber Double
    | JBool Bool
    | JNull
    | JObject [(String, JValue)]
    | JArray [JValue]
    deriving (Eq, Ord, Show)
\end{lstlisting}

对于每种 JSON 类型，我们都提供了独立的值构造函数。测试：

\begin{lstlisting}[language=Haskell]
  ghci> :l SimpleJSON
  [1 of 1] Compiling Main             ( SimpleJSON.hs, interpreted )
  Ok, one module loaded.
  ghci> JString "foo"
  JString "foo"
  ghci> JNumber 2.7
  JNumber 2.7
  ghci> :type JBool True
  JBool True :: JValue
\end{lstlisting}

构造一个从\acode{JValue}获取字符串的函数：

\begin{lstlisting}[language=Haskell]
  getString :: JValue -> Maybe String
  getString (JString s) = Just s
  getString _ = Nothing
\end{lstlisting}

测试：

\begin{lstlisting}[language=Haskell]
  ghci> :reload
  [1 of 1] Compiling Main             ( SimpleJSON.hs, interpreted )
  Ok, one module loaded.
  ghci> getString (JString "hello")
  Just "hello"
  ghci> getString (JNumber 3)
  Nothing
\end{lstlisting}

接下来是其它类型的访问函数：

\begin{lstlisting}[language=Haskell]
  getInt (JNumber n) = Just n
  getInt _ = Nothing

  getDouble (JNumber n) = Just n
  getDouble _ = Nothing

  getBool (JBool n) = Just n
  getBool _ = Nothing

  getObject (JObject o) = Just o
  getObject _ = Nothing

  getArray (JArray a) = Just a
  getArray _ = Nothing

  isNull v = v == JNull
\end{lstlisting}

\acode{truncate}函数可以让浮点类型或者有理数去掉小数点后变为整数：

\begin{lstlisting}[language=Haskell]
  ghci> truncate 5.8
  5
  ghci> :module +Data.Ratio
  ghci> truncate (22 % 7)
  3
\end{lstlisting}

\subsection*{Haskell 模块详解}

一个 Haskell 源文件包含了单个\textit{模块}的定义。模块允许我们在它其内部进行定义，并由其它模块访问：

\begin{lstlisting}[language=Haskell]
  module SimpleJSON
    ( JValue (..),
      getString,
      getInt,
      getDouble,
      getBool,
      getObject,
      getArray,
      isNull,
    )
  where
\end{lstlisting}

如果省略了导出（即圆括号以及其所包含的名称），那么该模块中的所有名称都会被导出。

\subsection*{编译 Haskell 源}

编译一个源文件：

\begin{lstlisting}[language=Bash]
  ghc -c SimpleJSON.hs
\end{lstlisting}

\acode{-c}选项告诉\textbf{ghc}仅生成对象代码。如果省略了该选项，那么编译器则会尝试生成一整个可执行文件。这会导致失败，因为
我们并没有一个\acode{main}函数，即 GHC 所认为的一个独立程序的执行入口。

编译后会得到两个新文件：\acode{SimpleJSON.hi}与\acode{SimpleJSON.o}。前者是一个\textit{接口 interface}文件，即
\textbf{ghc}以机器码的形式存储模块导出的名称信息；后者是一个\textit{对象 object}文件，其包含了生产的机器码。

\subsection*{生成一个 Haskell 程序，导入模块}

添加一个\acode{Main.hs}文件，其内容如下：

\begin{lstlisting}[language=Haskell]
  module Main where

  import SimpleJSON

  main = print (JObject [("foo", JNumber 1), ("bar", JBool False)])
\end{lstlisting}

与原文\acode{module Main () where}的不同之处在于，现在的\acode{Main}后不再需要一个\acode{()}。

接下来是编译\acode{main}函数：

\begin{lstlisting}[language=Bash]
  ghc -o simple Main.hs
\end{lstlisting}

与原文\acode{ghc -o simple Main.hs SimpleJSON.o}不同，现在没了\acode{SimpleJSON.o}这个文件，加上后会报错重复
symbol 的编译错误（因为在\acode{Main.hs}中已经做了\acode{import SimpleJSON}导入了）。

这次省略掉了\acode{-c}选项，因此编译器尝试生成一个可执行。生成可执行的这个过程被称为\textit{链接 linking}（与 C++ 一样），
即在一次编译中链接源文件与可执行文件。

这里给了\textbf{ghc}一个新选项\acode{-o}，其接受一个参数：可执行文件的名称，这里是\acode{simple}，执行它：

\begin{lstlisting}[language=Bash]
  ./simple
  JObject [("foo",JNumber 1.0),("bar",JBool False)]
\end{lstlisting}

\subsection*{打印 JSON 数据}

现在我们希望将 Haskell 的值渲染成 JSON 数据，创建一个\acode{PutJSON.hs}文件：

\begin{lstlisting}[language=Haskell]
  module PutJSON where

  import Data.List (intercalate)
  import SimpleJSON

  renderJValue :: JValue -> String
  renderJValue (JString s) = show s
  renderJValue (JNumber n) = show n
  renderJValue (JBool True) = "true"
  renderJValue (JBool False) = "false"
  renderJValue JNull = "null"
  renderJValue (JObject o) = "{" ++ pairs o ++ "}"
    where
      pairs [] = ""
      pairs ps = intercalate ", " (map renderPair ps)
      renderPair (k, v) = show k ++ ": " ++ renderJValue v
  renderJValue (JArray a) = "[" ++ values a ++ "]"
    where
      values [] = ""
      values vs = intercalate ", " (map renderJValue vs)
\end{lstlisting}

好的 Haskell 风格需要分隔纯代码与 I/O 代码。我们的\acode{renderJValue}函数不会与外界交互，但是仍然需要一个打印的函数：

\begin{lstlisting}[language=Haskell]
  putJValue :: JValue -> IO ()
  putJValue = putStrLn . renderJValue
\end{lstlisting}

\subsection*{类型推导是把双刃剑}

假设我们编写了一个自认为返回\acode{String}的函数，但是并不为其写类型签名：

\begin{lstlisting}[language=Haskell]
  upcaseFirst (c:cs) = toUpper c -- forgot ":cs" here
\end{lstlisting}

这里希望的是单词首字母大写，但是忘记了将剩余的字符放进结果中。我们认为函数的类型是\acode{String -> String}，但是编译器则会
将其视为\acode{String -> Char}。假设我们尝试在其他地方调用该函数：

\begin{lstlisting}[language=Haskell]
  camelCase :: String -> String
  camelCase xs = concat (map upcaseFirst (words xs))
\end{lstlisting}

那么当我们尝试编译该代码或者是加载进\textbf{ghci}，我们并不会得到明显的错误信息：

\begin{lstlisting}[language=Haskell]
  ghci> :load Trouble
  [1 of 1] Compiling Main             ( Trouble.hs, interpreted )

  Trouble.hs:9:27:
      Couldn't match expected type `[Char]' against inferred type `Char'
        Expected type: [Char] -> [Char]
        Inferred type: [Char] -> Char
      In the first argument of `map', namely `upcaseFirst'
      In the first argument of `concat', namely
          `(map upcaseFirst (words xs))'
  Failed, modules loaded: none.
\end{lstlisting}

注意这里的报错是在使用\acode{upcaseFirst}函数处，那么假设我们认为\acode{upcaseFirst}的定义与类型是正确的，那么查找到真正的
错误可能会花掉一些时间。

\subsection*{更加泛用的渲染}

% TODO

\end{document}
