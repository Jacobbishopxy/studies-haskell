\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{简介}

在第七章 I/O 中，我们讨论了\acode{IO}单子，然而当时只局限于如何它与外界进行交互，并没有讨论什么是单子。

...

\subsection*{重构早期代码}

\subsubsection*{Maybe 链}

回忆一下第十章的\acode{PNM.hs}代码中的\acode{parseP5}函数：

\begin{lstlisting}[language=Haskell]
  -- header
  matchHeader :: L.ByteString -> L.ByteString -> Maybe L.ByteString
  matchHeader prefix str
    | prefix `L8.isPrefixOf` str = Just (L8.dropWhile isSpace (L.drop (L.length prefix) str))
    | otherwise = Nothing

  -- nat = natural number
  getNat :: L.ByteString -> Maybe (Int, L.ByteString)
  getNat s = case L8.readInt s of
    Nothing -> Nothing
    Just (num, rest)
      | num <= 0 -> Nothing
      | otherwise -> Just (fromIntegral num, rest)

  getBytes :: Int -> L.ByteString -> Maybe (L.ByteString, L.ByteString)
  getBytes n str =
    let count = fromIntegral n
        both@(prefix, _) = L.splitAt count str
     in if L.length prefix < count
          then Nothing
          else Just both

  -- parse function
  parseP5 :: L.ByteString -> Maybe (Greymap, L.ByteString)
  parseP5 s =
    case matchHeader (L8.pack "PS") s of
      Nothing -> Nothing
      Just s1 ->
        case getNat s1 of
          Nothing -> Nothing
          Just (width, s2) ->
            case getNat (L8.dropWhile isSpace s2) of
              Nothing -> Nothing
              Just (height, s3) ->
                case getNat (L8.dropWhile isSpace s3) of
                  Nothing -> Nothing
                  Just (maxGrey, s4)
                    | maxGrey > 255 -> Nothing
                    | otherwise ->
                        case getBytes 1 s4 of
                          Nothing -> Nothing
                          Just (_, s5) ->
                            case getBytes (width * height) s5 of
                              Nothing -> Nothing
                              Just (bitmap, s6) ->
                                Just (Greymap width height maxGrey bitmap, s6)
\end{lstlisting}

接着又使用了\acode{(>>?)}函数来减少模式匹配：

\begin{lstlisting}[language=Haskell]
  (>>?) :: Maybe a -> (a -> Maybe b) -> Maybe b
  Nothing >>? _ = Nothing
  Just v >>? f = f v
\end{lstlisting}

...

\subsubsection*{隐式状态}

简化后的代码如下：

\begin{lstlisting}[language=Haskell]
  parseP5_take2 :: L.ByteString -> Maybe (Greymap, L.ByteString)
  parseP5_take2 s =
    matchHeader (L8.pack "P5") s
      >>? \s ->
        skipSpace ((), s)
          >>? (getNat . snd)
          >>? skipSpace
          >>? \(width, s) ->
            getNat s
              >>? skipSpace
              >>? \(height, s) ->
                getNat s
                  >>? \(maxGrey, s) ->
                    getBytes 1 s
                      >>? (getBytes (width * height) . snd)
                      >>? \(bitmap, s) -> Just (Greymap width height maxGrey bitmap, s)
\end{lstlisting}

我们仍然遇到了重复的行为模式：消费一些字符串，返回一个结果，接着将剩下的字符串传入下一个函数进行消费。然而这套模式有隐藏的风险：如果希望将其余部分的信息在链中传递，
那么就需要将链中的每个元素都进行修改，将每个二元元组改为三元元组！

我们解决这个问题的方法是将管理当前字符串的责任从链中的单个函数移动到将函数进行串联的函数中：

\begin{lstlisting}[language=Haskell]
  (==>) :: Parse a -> (a -> Parse b) -> Parse b
  firstParser ==> secondParser = Parse chainedParser
    where
      chainedParser initState =
        case runParse firstParser initState of
          Left errMessage ->
            Left errMessage
          Right (firstResult, newState) ->
            runParse (secondParser firstResult) newState
\end{lstlisting}

我们同样将解析状态的细节隐藏进\acode{ParseState}类型中。即使\acode{getState}与\acode{putState}函数都不会检查解析状态，因此对\acode{ParseState}的任何修改
都不会影响现有的代码。

\subsection*{寻找共有模式}

...

\subsection*{单子 typeclass}

我们可以在 Haskell 的 typeclass 中捕获链接和注入的概念，同时又希望它们具有类型。标准的 Prelude 已经定义了这样的一个 typeclass，即\acode{Monad}。

\begin{lstlisting}[language=Haskell]
  class Monad m where
    -- chain
    (>>=)  :: m a -> (a -> m b) -> m b
    -- inject
    return :: a -> m a
\end{lstlisting}

注：新的 Haskell 版本中 Monad 还需要先实现\acode{Applicative}实例，而\acode{Applicative}又需要先实现\acode{Functor}实例。

这里的\acode{>>=}是链接函数，而\acode{return}则是注入函数。

...

\subsection*{行话时间}

\begin{itemize}
  \item "Monadic" 即为“与单子有关”。一个 monadic \textit{类型}就是\acode{Monad} typeclass 的一个实例；一个 monadic \textit{值}拥有一个 monadic 类型。
  \item 当我们说一个类型“是一个单子”，这实际上在简述它是\acode{Monad} typeclass 的一个实例。作为\acode{Monad}的一个实例则拥有必要的 monadic 的类型构造函数，
        注入函数，以及链接函数。
  \item 同样的，引用“\acode{Foo}单子”意味着正在谈论名为\acode{Foo}的类型，且它是\acode{Monad}的一个实例。
  \item “动作 action”则是一个 monadic 值的别称。这个词的这种用法可能起源于用于 I/O 单子的引入，其中像\acode{print "foo"}这样的单子值可能具有可观察到的副作用。
        具有 monadic 返回类型的函数也可以称为操作，尽管这种情况不太常见。
\end{itemize}

\subsection*{使用一个新的单子：展示你的成果！}

在介绍单子时，我们展示了一些已经具备 monadic 形态的预定义代码。现在让我们定义其接口。

纯 Haskell 代码编写很简单，但是它不能执行 I/O。有时我们希望在记录一些决策时，不必将 log 信息写入文件中。现在来开发一个这样的库。

回忆在之前将 glob 模式转为正则表达式的小节中所开发的\acode{globToRegex}函数。我们将修改它，使其保存它所翻译的每个特殊模式序列的记录。

作为开始，首先将返回类型通过\acode{Logger}类型构造函数进行包装。

\begin{lstlisting}[language=Haskell]
  globToRegex :: String -> Logger String
\end{lstlisting}

\subsubsection*{隐藏信息}

\begin{lstlisting}[language=Haskell]
  module Logger
    ( Logger,
      Log,
      runLogger,
      record,
    )
  where
\end{lstlisting}

像这样隐藏细节有两个好处：它为我们实现单子提供了相当大的灵活性，更重要的是，它为用户提供了一个简单的界面。

我们的\acode{Logger}类型存粹是一个\textit{类型}构造函数。没有导出用户创建这种类型的值所需的值构造函数，用户仅仅可以使用 \acode{Logger} 来编写类型签名。

\acode{Log} 类型即字符串列表的同义词，将若干签名变得更有可读性。使用列表字符串是为了实现起来更加的方便。

\begin{lstlisting}[language=Haskell]
  type Log = [String]
\end{lstlisting}

相较于提供用户一个值构造函数，更好的是提供一个\acode{runLogger}函数，用于记录操作。它将同时返回操作的结果，以及计算时的日志。

\begin{lstlisting}[language=Haskell]
  runLogger :: Logger a -> (a, Log)
\end{lstlisting}

\subsubsection*{控制退出}

\acode{Monad} typeclass 不提供任何方法让值脱离它们的 monadic 束缚。可以使用\acode{return}将值注入进一个单子中，可以使用\acode{(>>=)}将值从单子中提取出来，
而位于其右侧的函数将会得到解包的值，该函数再将其结果重新进行包装。

多数单子拥有一个或多个类似\acode{runLogger}的函数。最典型的就是\acode{IO}，通常只会在退出程序时才退出。

一个单子执行函数会将代码运行在单子内部并展开其结果。这样的函数通常是提供给值从其一元包装器中转义的唯一方法。因此单子的作者可以完全控制单子内发生的任何事物。

\subsubsection*{留痕}

当在一个\acode{Logger}中操作时，用户代码调用\acode{record}来记录事物。

\begin{lstlisting}[language=Haskell]
  record :: String -> Logger ()
\end{lstlisting}

由于记录发生在单子的管道中，所以操作的结果不提供任何信息。

通常来说，一个单子会提供一个或多个像\acode{record}一样的帮助函数。它们是访问该单子的特殊行为的方法。

模块中也为\acode{Logger}类型提供了\acode{Monad}实例。它们是客户端模块为了能使用这个单子所需的全部定义。

\subsubsection*{使用 Logger 单子}

下面是将 glob-to-regexp 在\acode{Logger}单子中转换的方法：

\begin{lstlisting}[language=Haskell]
  globToRegex :: String -> Logger String
  globToRegex cs =
    globToRegex' cs >>= \ds -> return $ '^' : ds
\end{lstlisting}

注意\acode{(>>=)}的类型：它从左侧的\acode{Logger}包裹中中提取值，然后将解包的值传递给右侧的函数。在其右侧的函数则需要使用\acode{Logger}包装其结果。这也正是
\acode{return}所做的：获取一个纯值，包裹该值进入一个单子类型的构造函数中。

\begin{lstlisting}[language=Haskell]
  ghci> :type (>>=)
  (>>=) :: (Monad m) => m a -> (a -> m b) -> m b
  ghci> :type (globToRegex "" >>=)
  (globToRegex "" >>=) :: (String -> Logger b) -> Logger b
\end{lstlisting}

即使编写一个不做任何事情的函数也要调用\acode{return}将结果包装成正确的类型。

\begin{lstlisting}[language=Haskell]
  globToRegex' :: String -> Logger String
  globToRegex' "" = return "$"
\end{lstlisting}

当调用\acode{record}来存储一个日志，需要用\acode{(>>)}而不是\acode{(>>=)}来进行串联。

\begin{lstlisting}[language=Haskell]
  globToRegex' ('?' : cs) =
  record "any"
    >> globToRegex' cs
    >>= \ds -> return ('.' : ds)
\end{lstlisting}

记住它是\acode{(>>=)}的一种变体，它会忽略左侧的结果。我们知道\acode{record}的结果总是\acode{()}，因此无需捕获该结果。

我们可以使用\acode{do}符号来整洁一下代码：

\begin{lstlisting}[language=Haskell]
  globToRegex'' ('*' : cs) = do
    record "kleene star"
    ds <- globToRegex'' cs
    return $ ".*" ++ ds
\end{lstlisting}

解析字符类主要遵循以上这种模式：

\begin{lstlisting}[language=Haskell]
  globToRegex' ('[' : '!' : c : cs) =
    record "character class, negative"
      >> charClass cs
      >>= \ds -> return $ "[^" ++ c : ds
  globToRegex' ('[' : c : cs) =
    record "character class"
      >> charClass cs
      >>= \ds -> return $ "[" ++ c : ds
  globToRegex' ('[' : _) =
    fail "unterminated character class"
\end{lstlisting}

\subsection*{混合纯代码与单子代码}

根据目前所见到的代码，单子看起来有一个很大的缺点：使用普通的纯函数处理被包装后的值时，会变得很棘手。以下是这个浅显问题的一个简单说明。假设有一个简单的代码运行在
\acode{Logger}单子中并返回一个字符串。

\begin{lstlisting}[language=Haskell]
  ghci> let m = return "foo" :: Logger String
\end{lstlisting}

如果希望得知该字符串的长度，我们无法直接调用\acode{length}：因为字符串被封装了，类型并不匹配。

迄今为止我们所能做的就是类似这样：

\begin{lstlisting}[language=Haskell]
  ghci> :type   m >>= \s -> return (length s)
  m >>= \s -> return (length s) :: Logger Int
\end{lstlisting}

通过\acode{(>>=)}解包该字符串，接着用一个小的匿名函数来调用\acode{length}并通过\acode{return}重新进行包装。

由于\acode{Monad} typeclass 已经提供了\acode{(>>=)}与\acode{return}函数用于解包与打包一个值，\acode{liftM}函数则不需要知道任何单子实现的细节。

\begin{lstlisting}[language=Haskell]
  liftM :: (Monad m) => (a -> b) -> m a -> m b
  liftM f m = m >>= \i -> return $ f i
\end{lstlisting}

当我们为一个类型声明\acode{Functor} typeclass 实例时，我们需要编写自己的\acode{fmap}。相反的，\acode{liftM}不需要了解单子的内部，因为它们抽象出来了
\acode{(>>=)}与\acode{return}。我们只需要通过适当的类型约束编写它一次。

\acode{liftM}函数预定义在\acode{Control.Monad}模块中。

为了检测\acode{liftM}是如何提高可读性的，我们来比较连个相同作用的代码。首先是不使用\acode{liftM}的情况：

\begin{lstlisting}[language=Haskell]
  charClass_wordy (']' : cs) =
    globToRegex' cs >>= \ds -> return $ ']' : ds
  charClass_wordy (c : cs) =
    charClass_wordy cs >>= \ds -> return $ c : ds
\end{lstlisting}

然后是使用\acode{liftM}来去除\acode{(>>=)}以及匿名函数：

\begin{lstlisting}[language=Haskell]
  charClass (']' : cs) = (']' :) `liftM` globToRegex' cs
  charClass (c : cs) = (c :) `liftM` globToRegex' cs
\end{lstlisting}

与\acode{fmap}一样，我们经常以中缀形式使用\acode{liftM}。阅读这种表达式的一种简单方法是“将左侧的纯函数应用于右侧一元操作的结果”。

\acode{liftM}太有用了以致于\acode{Control.Monad}定义了若干变体，用于结合更长的操作链。来看一下\acode{globToRegex'}函数的最后一个分句：

\begin{lstlisting}[language=Haskell]
  globToRegex' (c : cs) = liftM2 (++) (escape c) (globToRegex' cs)

  escape :: Char -> Logger String
  escape c
    | c `elem` regexChars = record "escape" >> return ['\\', c]
    | otherwise = return [c]
    where
      regexChars = "\\+()^$.{}]|"
\end{lstlisting}

而上述的\acode{liftM2}函数定义如下：

\begin{lstlisting}[language=Haskell]
  liftM2 :: (Monad m) => (a -> b -> c) -> m a -> m b -> m c
  liftM2 f m1 m2 =
    m1 >>= \a ->
      m2 >>= \b ->
        return (f a b)
\end{lstlisting}

它首先执行第一个操作，接着第二个，再使用纯函数\acode{f}组合它们的结果，并封装该结果。除了\acode{liftM2}，\acode{Control.Monad}中的变体达到了\acode{liftM5}。

\subsection*{消除一些误解}

略。

\subsection*{构建一个 Logger 单子}

\acode{Logger}类型的定义非常简单：

\begin{lstlisting}[language=Haskell]
  newtype Logger a = Logger {execLogger :: (a, Log)}
\end{lstlisting}

它一个二元元组，第一个元素是具体操作的结果，而第二个元素则是该操作中产生的所有日志的列表。

我们将该元组包装进了一个\acode{newtype}中使其变为独立类型。\acode{runLogger}函数则是从包装中提取出该元组。而暴露出来执行一个日志行为的函数，\acode{runLogger}，
则是\acode{execLogger}的一个别名。

\begin{lstlisting}[language=Haskell]
  runLogger = execLogger
\end{lstlisting}

\acode{record}帮助函数则是通过传入的信息，创建了一个单例列表：

\begin{lstlisting}[language=Haskell]
  record s = Logger ((), [s])
\end{lstlisting}

该操作的结果为\acode{()}，这也是为什么在结果位置放置它的缘故。

现在开始\acode{Monad}实例的\acode{return}，它很简单：不记录日志，并将其入参存储值结果位置。

\begin{lstlisting}[language=Haskell]
  instance Functor Logger where
    fmap f (Logger (a, l)) = Logger (f a, l)

  instance Applicative Logger where
    pure a = Logger (a, [])
    (<*>) (Logger (h, w)) (Logger (a, x)) = Logger (h a, w ++ x)

  instance Monad Logger where
    m >>= k =
      let (a, w) = execLogger m
          n = k a
          (b, x) = execLogger n
      in Logger (b, w ++ x)
\end{lstlisting}

注：现代版本 Haskell 在实现 Monad 实例之前还需要先实现 Functor 与 Applicative 实例。

\subsubsection*{序列化日志，而不是序列化计算}

我们定义的\acode{(>>=)}确保了左侧的日志信息将会附加到右侧的新的日志信息中。然而，它并没有涉及\acode{a}与\acode{b}的计算：\acode{(>>=)}是惰性的。

正如其它大多数的单子行为一样，严格程度是由单子的实现者所控制的。它不是所有单子都共享的常量。实际上一些单子由多种风格，每一种都会有不同的严格程度。

\subsubsection*{Writer 单子}

我们的\acode{Logger}单子实际上是标准\acode{Writer}单子的特殊版本，可以在\acode{mtl}库的\acode{Control.Monad.Writer}模块中找到。关于\acode{Writer}的例子
将会在下一章中讲到。

\subsection*{Maybe 单子}

\acode{Maybe}类型是最简单的\acode{Monad}实例。它代表着计算可能不会返回一个结果。

当我们将一系列返回\acode{Maybe}的计算通过\acode{(>>=)}或\acode{>>}串联起时，它们任意一个返回\acode{Nothing}时，后续的计算都不再进行。

注意，尽管链条并不是完全短路的。链路中的每个\acode{(>>=)}或\acode{(>>)}仍然会匹配左侧的\acode{Nothing}，并生产一个\acode{Nothing}在右侧，直至最后。容易
遗忘的点：当链路中的一个计算失败时，剩下的链路以及\acode{Nothing}值的消费在运行时是廉价的，但并不是全免。

\subsubsection*{执行 Maybe 单子}

执行\acode{Maybe}单子的函数名为\acode{maybe}。（记住“执行”一个单子包括对单子求值并返回一个去掉单子类型包装的结果。）

\begin{lstlisting}[language=Haskell]
  maybe :: b -> (a -> b) -> Maybe a -> b
  maybe n _ Nothing  = n
  maybe _ f (Just x) = f x
\end{lstlisting}

它第一个参数是当结果为\acode{Nothing}时，给定的返回；第二个参数则是当结果为\acode{Just}时，应用到解包值上的函数。

\subsubsection*{Maybe 作为优秀的 API 设计}

下面是一个\acode{Maybe}作为单子使用的例子。给定一个用户名，希望通过移动电话运营商找到账单地址。

\begin{lstlisting}[language=Haskell]
  import Data.Map qualified as M

  type PersonName = String

  type PhoneNumber = String

  type BillingAddress = String

  data MobileCarrier
    = Honest_Bobs_Phone_Network
    | Morrisas_Marvelous_Mobiles
    | Petes_Plutocratic_Phones
    deriving (Eq, Ord)

  findCarrierBillingAddress ::
    PersonName ->
    M.Map PersonName PhoneNumber ->
    M.Map PhoneNumber MobileCarrier ->
    M.Map MobileCarrier BillingAddress ->
    Maybe BillingAddress
\end{lstlisting}

我们的第一个版本是可怕的梯形代码，带着一堆\acode{case}表达式：

\begin{lstlisting}[language=Haskell]
  variation1 :: (Ord k1, Ord k2, Ord k3) => k1 -> M.Map k1 k2 -> M.Map k2 k3 -> M.Map k3 a -> Maybe a
  variation1 person phoneMap carrierMap addressMap =
    case M.lookup person phoneMap of
      Nothing -> Nothing
      Just number ->
        case M.lookup number carrierMap of
          Nothing -> Nothing
          Just carrier -> M.lookup carrier addressMap
\end{lstlisting}

\acode{Data.Map}模块的\acode{lookup}函数拥有一个 monadic 返回类型

\begin{lstlisting}[language=Haskell]
  ghci> :module +Data.Map
  ghci> :type Data.Map.lookup
  Data.Map.lookup :: (Ord k, Monad m) => k -> Map k a -> m a
\end{lstlisting}

换言之，如果给定的键在 map 中，\acode{lookup}通过\acode{return}将值注入至单子；反之，调用\acode{fail}。这是很有意思的 API 设计，尽管我们会认为这是一个糟糕的
选择。

\begin{itemize}
  \item 正面来看，成功与失败的行为是根据调用\acode{lookup}所产生的单子自动定值的。更妙的的是，\acode{lookup}本身并不需要知道或关系这些行为。
  \item 反面来看，问题在于错误的单子中使用\acode{file}会抛出令人厌恶的异常。
\end{itemize}

使用\acode{do}简化：

\begin{lstlisting}[language=Haskell]
  variation2 :: (Ord k1, Ord k2, Ord k3) => k1 -> M.Map k1 k2 -> M.Map k2 k3 -> M.Map k3 b -> Maybe b
  variation2 person phoneMap carrierMap addressMap = do
    number <- M.lookup person phoneMap
    carrier <- M.lookup number carrierMap
    M.lookup carrier addressMap
\end{lstlisting}

如果这些 lookup 中任意一个失败了，那么\acode{(>>=)}以及\acode{(>>)}的定义意味着函数的整个结果将会变为\acode{Nothing}，正如第一次尝试中显式的使用\acode{case}
那样。

通过\acode{flip}还可以将函数体变为一行：

\begin{lstlisting}[language=Haskell]
  variation3 :: Ord a => a -> M.Map a a -> M.Map a a -> M.Map a b -> Maybe b
  variation3 person phoneMap carrierMap addressMap =
    lookup phoneMap person >>= lookup carrierMap >>= lookup addressMap
    where
      lookup = flip M.lookup
\end{lstlisting}

\subsection*{列表单子}

% TODO

\subsubsection*{理解列表单子}

\subsubsection*{列表单子生效}

\subsection*{do 块的脱糖}

\subsubsection*{单子作为可编程的分号}

\subsubsection*{为何选择无糖？}

\subsection*{State 单子}

\subsubsection*{状态单子}

\subsubsection*{读取与修改状态}

\subsubsection*{真正的状态单子可用吗？}

\subsubsection*{使用状态单子：生成随机值}

\subsubsection*{尝试纯粹性}

\subsubsection*{状态单子中的随机值}

\subsubsection*{允许状态单子}

\subsubsection*{更多特性}

\subsection*{单子与函子}

\subsubsection*{看待单子的另一种方式}

\subsection*{单子律，以及优良的代码风格}

\end{document}
