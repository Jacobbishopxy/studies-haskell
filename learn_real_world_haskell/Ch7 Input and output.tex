\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{Haskell 中的经典 I/O}

略

\subsection*{处理文件以及句柄}

Haskell 为 I/O 定义了相当多的基本函数，其中许多函数与其它编程语言中的函数相似。\acode{System.IO}库中提供了所有的基础 I/O 函数。

使用\acode{openFile}会返回一个文件的\acode{Handle}，它用于对文件执行指定的操作。Haskell 提供了例如\acode{hPutStrLn}这样的
函数，其类似于\acode{putStrLn}，不同在于接受一个额外的参数 -- 一个\acode{Handle} -- 指定哪个文件被操作。当我们结束时，需要用
\acode{hClose}来结束\acode{Handle}。这些函数都定义在\acode{System.IO}中，“h” 开头的函数对应了几乎所有的非 “h” 开头的函数；
例如\acode{print}打印在屏幕上，而\acode{hPrint}打印至一个文件。

一个例子：

\begin{lstlisting}[language=Haskell]
  import Data.Char (toUpper)
  import System.IO

  main :: IO ()
  main = do
    inh <- openFile "input.txt" ReadMode
    outh <- openFile "output.txt" WriteMode
    mainloop inh outh
    hClose inh
    hClose outh

    putStrLn "whatever"

  mainloop :: Handle -> Handle -> IO ()
  mainloop inh outh = do
    ineof <- hIsEOF inh
    if ineof
      then return ()
      else do
        inpStr <- hGetLine inh
        hPutStrLn outh (map toUpper inpStr)
        mainloop inh outh
\end{lstlisting}

\acode{mainloop}首先检查输入是否结束（EOF），如果没有则读取一行，将该行转为大写后写入输出文件中，再递归的调用\acode{mainloop}。

略

\begin{center}
  \begin{tabular}{|l|l|l|l|l|}
    \hline
    \multicolumn{5}{|c|}{\textbf{可能的 IOMode 值}}                                     \\
    \hline
    IOMode        & \textbf{可读？} & \textbf{可写？} & \textbf{起始位置} & \textbf{说明}       \\
    \hline
    ReadMode      & Yes          & No           & 文件起始          & 文件必须存在            \\
    WriteMode     & No           & Yes          & 文件起始          & 文件存在时会被清空         \\
    ReadWriteMode & Yes          & Yes          & 文件起始          & 文件不存在时创建；否则现有数据保留 \\
    AppendMode    & No           & Yes          & 文件尾部          & 文件不存在时创建；否则现有数据保留 \\
    \hline
  \end{tabular}
\end{center}

\subsubsection*{关闭句柄}

上述例子中我们已经见到了\acode{hClose}用于关闭文件的句柄。在之后的小节中我们将了解缓存 Buffering 这个概念，即 Haskell 在内部
为文件维护了缓存。这样做能显著的提升性能，然而这就意味着在对打开的文件调用\acode{hClose}之前，数据可能不会被刷新到操作系统中。

另一个原因是打开着的文件消耗系统的资源。如果程序运行的时间很长，开开了很多文件但是并没有关闭它们，那么程序很可能会因为资源枯竭而
导致崩溃。

\subsubsection*{Seek 与 Tell}

从一个关联了磁盘文件的\acode{Handle}读写时，操作系统会维护一个关于当前位置的内部记录。每当进行下一层读取的时，操作系统返回下一个
数据块，其起始点为当前位置，且增加的位置反应了读取了多少数据。

你可以使用\acode{hTell}来找到文件中当前的位置。当文件被创建时，它是空的且你的位置将会是 0。在编写 5 个字节后，你的位置则变为了
5，以此类推。\acode{hTell}接受一个\acode{Handle}并返回一个\acode{IO Integer}来表示你的位置。

\acode{hTell}的同伴是\acode{hSeek}，它允许你更改文件的位置，其三个参数为：\acode{Handle}，\acode{SeekMode}以及一个位置。

\acode{SeekMode}有三个不同类型，用于指定如何解析给定的位置。\acode{AbsoluteSeek}为文件中的精确位置，等同于\acode{hTell}；
\acode{RelativeSeek}意为当前位置开始的多少位置，正值向后，负值向前；\acode{SeekFromEnd}则是从文件末尾往前多少的位置。

并不是所有的\acode{Handle}都是可以 seek 的。一个\acode{Handle}通常关联一个文件，但是它还可以关联其它的东西，比如网络连接，
磁带机，或者终端。可以使用\acode{hIsSeekable}来查看给定的\acode{Handle}是否可以 seek。

\subsubsection*{标准输入，输出以及错误}

较早之前我们指出每个非“h”函数通常都会有与其关联的“h”函数用作于任何\acode{Handle}上。实际上非“h”函数只不过是“h”函数的一种缩写。

在\acode{System.IO}中有三个预定义的\acode{Handle}：\acode{stdin}标准输入，通常是键盘；\acode{stdout}标准输出，通常是
显示器；\acode{stderr}标准错误，通常也是显示器。

像是\acode{getLine}类似的函数可以简单的定义成：

\begin{lstlisting}[language=Haskell]
  getLine = hGetLine stdin
  putStrLn = hPutStrLn stdout
  print = hPrint stdout
\end{lstlisting}

\subsubsection*{删除与文件重命名}

\acode{System.Directory}模块提供了两个比较有用的函数：\acode{removeFile}接受单个参数，即文件名，然后删除该文件；
\acode{renameFile}接受两个文件名，一个旧名称以及一个新的名称，如果新的文件名是一个不同的路径，那么可以认为这是一个移动。
旧的文件名必须在调用\acode{renameFile}之前就存在，另外如果新文件已经存在，则重命名后将其删除。

跟很多其它接受一个文件名的函数一样，如果“旧”名称不存在，\acode{renameFile}则会抛出异常。

\acode{System.Directory}模块中还有很多其他的函数，像是创建或移除文件夹，在路径中查找文件列表，测试文件是否存在，等等。

\subsubsection*{临时文件}

程序员频繁的需要临时文件。这些文件被用于存储大量等待计算的数据，可被其它程序所用的数据，等等。

通过名为\acode{openTempFile}的函数（以及相关联的\acode{openBinaryTempFile}）可以帮助我们解决不少问题。

\acode{openTempFile}接受两个参数：创建文件的路径，以及一个“template”用于命名文件。路径可以是\acode{.}来代表当前路径，或者
也可以使用\acode{System.Directory.getTemporaryDirectory}来找到操作系统所给出的最佳放置临时文件的位置。template 则将一些
随机字符添加至文件，用以确保结果是真正唯一的。实际上它保证了可以在一个唯一的文件名上工作。

\acode{openTempFile}的返回类型是\acode{IO (FilePath, Handle)}。元组的第一部分是被创建文件的名称，第二部分则是一个模式为
\acode{ReadWriteMode}的打开了文件的\acode{Handle}。当我们使用完文件，我们希望用\acode{hClose}来操作\acode{Handle}用于
关闭文件，接着调用\acode{removeFile}来删除它。接下来我们会看到一个例子用于展示这些函数的用法。

\subsection*{扩展案例：函数式 I/O 以及临时文件}



\begin{lstlisting}[language=Haskell]
  import Control.Exception
  import System.Directory (getTemporaryDirectory, removeFile)
  import System.IO

  main :: IO ()
  main = withTempFile "mytemp.txt" myAction

  myAction :: FilePath -> Handle -> IO ()
  myAction tempname temph = do
    -- Start by displaying a greeting on the terminal
    putStrLn "Welcome to tempfile.hs"
    putStrLn $ "I have a temporary file at " ++ tempname

    -- Let's see what the initial position is
    pos <- hTell temph
    putStrLn $ "My initial position is " ++ show pos

    -- Now, write some data to the temporary file
    let tempdata = show [1 .. 10]
    putStrLn $ "Writing one line containing " ++ show (length tempdata) ++ " bytes: " ++ tempdata
    hPutStrLn temph tempdata

    -- Get our new position. This doesn't actually modify pos in memory,
    -- but makes the name "pos" correspond to a different value for
    -- the remainder of the "do" block.
    pos <- hTell temph
    putStrLn $ "After writing, my new position is " ++ show pos

    -- Seek to the beginning of the file and display it
    putStrLn "The file content is: "
    hSeek temph AbsoluteSeek 0

    -- hGetContents performs a lazy read of the entire file
    c <- hGetContents temph

    -- Copy the file byte-for-byte to stdout, followed by \n
    putStrLn $ "c: " ++ c

    -- Let's also display it as a Haskell literal
    putStrLn "Which could be expressed as this Haskell literal:"
    print c

  {-
    This function takes two parameters: a filename pattern and another function.
    It will create a temporary file, and pass the name and Handle of that file to
    the given function.

    The temporary file is created with openTempFile. The directory is the one
    indicated by getTemporaryDirectory, or, if the system has no notion of a temporary
    directory, "." is used. The given pattern is passed to openTempFile.

    After the given function terminates, even if it terminates due to an exception,
    the Handle is closed and the file is deleted.
  -}
  withTempFile :: String -> (FilePath -> Handle -> IO a) -> IO a
  withTempFile pattern func = do
    -- The library ref says that getTemporaryDirectory may raise on exception on
    -- systems that have no notion of a temporary directory. So, we run
    -- getTemporaryDirectory under catch. catch takes two functions: one to run,
    -- and a different one to run if the first raised an exception.
    -- If getTemporaryDirectory raised an exception, just use "." (the current
    -- working directory).
    tempdir <-
      catch
        getTemporaryDirectory
        (\(_ :: IOException) -> return ".") -- explicit annotates exception type
    (tempfile, temph) <- openTempFile tempdir pattern

    -- Call (func tempfile temph) to perform the action on the temporary file.
    -- finally takes two actions. The first is the action to run, the second is an action
    -- to run after the first, regardless of the temporary file is always deleted.
    -- The return value from finally is the first action's return value.
    finally
      (func tempfile temph)
      ( do
          hClose temph
          removeFile tempfile
      )
\end{lstlisting}

首先\acode{withTempFile}函数证明了 Haskell 在 I/O 时也没有忘记其函数式的天性。该函数接受一个\acode{String}与另一个函数。
传递给\acode{withTempFile}的函数带着临时文件的\acode{Handle}被调用，当该函数退出时，临时文件关闭并被删除。

异常处理可以让程序变得更加健壮。通常我们希望在程序结束后删除临时文件，即使程序的执行过程中出现了错误。更多的错误处理会在第十九章
讲述。

现在回到程序，\acode{main}做的事情很简单，调用函数\acode{withTempFile}并传入临时文件名以及\acode{myAction}函数。

\acode{myAction}展示了一些信息到终端上，写入了一些数据到文件中，seek 到文件的起始位置，通过\acode{hGetContents}进行数据
读取，接着按照字节展示文件内容，同时通过\acode{print c}进行打印。这等同于\acode{putStrLn (show c)}。

现在看看输出：

\begin{lstlisting}[language=Bash]
  % runhaskell tempfiles.hs
  Welcome to tempfile.hs
  I have a temporary file at /var/folders/nb/w1q3ztlj139_vz9pqglmbks80000gn/T/mytemp3709-0.txt
  My initial position is 0
  Writing one line containing 22 bytes: [1,2,3,4,5,6,7,8,9,10]
  After writing, my new position is 23
  The file content is:
  c: [1,2,3,4,5,6,7,8,9,10]

  Which could be expressed as this Haskell literal:
  "[1,2,3,4,5,6,7,8,9,10]\n"
\end{lstlisting}

\subsection*{Lazy I/O}

Haskell 还提供了另一种方式处理 I/O。由于 Haskell 是 lazy 语言，意味着任何数据只会在其值必须被知道时才会被计算，那么就有了一些
新颖的 I/O 处理方法。

\subsubsection*{hGetContents}

一个新颖的 I/O 方式就是\acode{hGetContents}函数，其类型\acode{Handle -> IO String}，这里的\acode{String}代表着由文件的
\acode{Handle}所返回的所有数据。

在严格求值的语言中，使用这样的函数通常是一个坏主意。假设读一个 500GB 的文件，那么就有可能因为内存不足而导致程序崩溃。在这些语言中，
传统的做法就是使用循环来处理文件的所有数据。

但是\acode{hGetContents}不一样，它返回的\acode{String}是惰性的，即在调用\acode{hGetContents}时，并没有读取任何数据。
只有在处理列表的元素（字符）时才会从\acode{Handle}中读取数据。当\acode{String}的元素不再使用时，Haskell 的垃圾收集器则会自动
释放内存。

来看一个例子：

\begin{lstlisting}[language=Haskell]
  import Data.Char (toUpper)
  import System.IO

  main :: IO ()
  main = do
    inh <- openFile "input.txt" ReadMode
    outh <- openFile "output.txt" WriteMode
    inpStr <- hGetContents inh
    let result = processData inpStr
    hPutStr outh result
    hClose inh
    hClose outh

  processData :: String -> String
  processData = map toUpper
\end{lstlisting}

测试：

\begin{lstlisting}[language=Haskell]
  ghci> :load toupper-lazy1.hs
  [1 of 1] Compiling Main             ( toupper-lazy1.hs, interpreted )
  Ok, modules loaded: Main.
  ghci> processData "Hello, there!  How are you?"
  "HELLO, THERE!  HOW ARE YOU?"
  ghci> :type processData
  processData :: String -> String
  ghci> :type processData "Hello!"
  processData "Hello!" :: String
\end{lstlisting}

\begin{awarn}
  如果我们在上述例子中尝试在使用\acode{inpStr}的地方（对\acode{processData}的调用）之后继续使用\acode{inpStr}，那么程序
  则会失去其内存效率。这是因为编译器将会强制保留\acode{inpStr}值在内存中供未来使用。在这里编译器知道\acode{inpStr}不会再被
  使用，那么就在其使用结束后尽快的释放内存。这里需要记住：内存只有在最后一次使用后才会被释放。
\end{awarn}

这段代码有点啰嗦，我们可以让它变得更简洁一些：

\begin{lstlisting}[language=Haskell]
  import Data.Char (toUpper)
  import System.IO

  main :: IO ()
  main = do
    inh <- openFile "input.txt" ReadMode
    outh <- openFile "output.txt" WriteMode
    inpStr <- hGetContents inh
    hPutStr outh (map toUpper inpStr)
    hClose inh
    hClose outh
\end{lstlisting}

在使用\acode{hGetContents}时，我们甚至不需要从输入文件中消费所有的数据。每当 Haskell 系统确定\acode{hGetContents}所返回的
整个字符可以被垃圾回收时 -- 意味着它不会再被使用 -- 文件将自动被关闭。同样的原则也适用于从文件中读取的数据。每当给定的数据不再
需要时，Haskell 环境就会释放存储该数据的内存。严格来说我们完全都不需要调用\acode{hClose}。然而这是一个好的习惯，因为之后对程序
的改动会使得\acode{hClose}变得很重要。

\begin{awarn}
  在使用\acode{hGetContents}时，必须记住即使在之后的程序可能不再显式的引用\acode{Handle}，但还是要保持\acode{Handle}
  不被关闭，直到\acode{hGetContents}的结果被消费掉了。不这么做的话就可能会导致丢失部分或者全部文件数据。这是因为 Haskell
  是惰性的，所以通常可以假设只有在输出了涉及输入的计算结果之后才消费了输入。
\end{awarn}

\subsubsection*{readFile 与 writeFile}

Haskell 程序员经常使用\acode{hGetContents}作为筛选。从一个文件读取数据，处理数据，接着将数据写到别的地方。这非常的通用所以有了
一些快捷的方式：\acode{readFile}以及\acode{writeFile}就是这样的函数，以字符串的方式处理文件。它们处理了所有关于打开文件，
关闭文件，读取数据，以及写入数据的细节。\acode{readFile}在内部使用了\acode{hGetContents}。

通过\textbf{ghci}查看这些函数的类型：

\begin{lstlisting}[language=Haskell]
  ghci> :type readFile
  readFile :: FilePath -> IO String
  ghci> :type writeFile
  writeFile :: FilePath -> String -> IO ()
\end{lstlisting}

使用\acode{readFile}与\acode{writeFile}改造之前的代码：

\begin{lstlisting}[language=Haskell]
  import Data.Char (toUpper)

  main :: IO ()
  main = do
    inpStr <- readFile "input.txt"
    writeFile "output.txt" $ map toUpper inpStr
\end{lstlisting}

\subsubsection*{关于 Lazy Output}

现在我们能理解惰性输入是如何在 Haskell 中工作的。那么惰性输出又是怎么样呢？

我们知道 Haskell 中所有计算都是在其值被需要时才会进行。由于函数例如\acode{writeFile}以及\acode{putStr}会输出所有传给它们的
\acode{String}，那么整个\acode{String}必须被计算。因此可以保证\acode{putStr}的参数将被完整求值。

那么输入惰性的意义呢？上述例子中，对\acode{putStr}或\acode{writeFile}的调用是否会强制将整个输入字符串立刻加载到内存中，仅仅
只是为了输出？

回答是不。\acode{putStr}（以及其它类似的所有输出函数）在数据可同时，输出数据。它们同样也不需要保留已经输出了的数据，因此只要程序
中没有其它东西需要它，内存就可以立刻释放。在某种意义上，可以将\acode{readFile}与\acode{writeFile}之间的\acode{String}视为
连接两者的管道。数据进入一端，以某种方式转换后，从另一端流出。

\subsubsection*{interact}

通过\acode{interact}函数可以进一步简化我们的程序：

\begin{lstlisting}[language=Haskell]
  import Data.Char (toUpper)

  main :: IO ()
  main = interact $ map toUpper
\end{lstlisting}

仅用了一行！测试：

\begin{lstlisting}[language=Haskell]
  $ runghc toupper-lazy4.hs < input.txt > output.txt
\end{lstlisting}

或者想要打印到屏幕上：

\begin{lstlisting}[language=Haskell]
  $ runghc toupper-lazy4.hs < input.txt
\end{lstlisting}

如果想要看到 Haskell 的输出确实是在接收到数据块后立刻输出到数据块，可以不加任何参数运行\acode{runghc toupper-lazy4.hs}，
这样就可以看到在敲击输入回车后，所有字符都会被立刻以大写的形式输出。

我们同样还可以通过\acode{interact}编写在输出前添加新行的程序：

\begin{lstlisting}[language=Haskell]
  import Data.Char (toUpper)

  main = interact $ map toUpper . (++) "Your data, in uppercase, is:\n\n"
\end{lstlisting}

由于我们在\acode{(++)}后调用的\acode{map}，那么新行也会变为大写，修改一下：

\begin{lstlisting}[language=Haskell]
  import Data.Char (toUpper)

  main = interact $ (++) "Your data, in uppercase, is:\n\n" . map toUpper
\end{lstlisting}

这就将新行移到\acode{map}外去了。

\subsubsection*{interact 加上过滤}

\acode{interact}的另一个常用方法就是过滤。比如打印带有字符“a”的每行：

\begin{lstlisting}[language=Haskell]
  main = interact $ unlines . filter (elem 'a') . lines
\end{lstlisting}

通过\textbf{ghci}查看上述的三个新函数：

\begin{lstlisting}[language=Haskell]
  ghci> :type lines
  lines :: String -> [String]
  ghci> :type unlines
  unlines :: [String] -> String
  ghci> :type elem
  elem :: (Eq a) => a -> [a] -> Bool
\end{lstlisting}

测试：

\begin{lstlisting}[language=Haskell]
  $ runghc filter.hs < input.txt
  I like Haskell
  Haskell is great
\end{lstlisting}

\subsection*{IO 单子}

% TODO

\begin{lstlisting}[language=Haskell]

\end{lstlisting}

\end{document}
