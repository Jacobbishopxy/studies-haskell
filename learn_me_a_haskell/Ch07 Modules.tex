\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{加载模块}

Haskell 模块是一系列关联的函数，类型以及 typeclasses 的集合。一个 Haskell 的程序是模块的集合，其中主模块加载若干模块并使用这些模块。

Haskell 的标准库也被分成了若干模块，每个模块所包含的函数与类型服务于某些共同的目的。迄今为止我们所有接触到的函数，类型，typeclasses
都位于\acode{Prelude}模块，也是默认加载的模块。

Haskell 加载模块的语法就是\acode{import <module name>}。现在尝试一下加载\acode{Data.List}这个模块：

\begin{lstlisting}[language=Haskell]
  import Data.List

  numUniques :: (Eq a) => [a] -> Int
  numUniques = length . nub
\end{lstlisting}

当\acode{import Data.List}后，所有在\acode{Data.List}中的函数在公共命名空间中变为可用，也就是说可以在脚本中任意处调用这些函数。
\acode{nub}是一个定义在\acode{Data.List}中的函数，接受一个列表并去除其中的重复元素。将\acode{length}与\acode{num}组合起来
\acode{length . nub}产生的函数等同于\acode{\xs -> length (nub xs)}。

在使用 GHCI 的时候同样也可以加载模块至全局命名空间内，只需：

\begin{lstlisting}[language=Haskell]
  ghci> :m + Data.List
\end{lstlisting}

如果想要加载多个模块，仅需：

\begin{lstlisting}[language=Haskell]
  ghci> :m + Data.List Data.Map Data.Set
\end{lstlisting}

如果加载的脚本（通过\acode{:l <xxx script>}）中已经加载过模块了，那么便不再需要通过\acode{:m +}进行加载。

如果只是想要从模块中加载几个函数，那么可以这样做：

\begin{lstlisting}[language=Haskell]
  import Data.List (nub, sort)
\end{lstlisting}

如果想加载模块，却不包括某些函数，可以这样：

\begin{lstlisting}[language=Haskell]
  import Data.List hiding (nub)
\end{lstlisting}

为了避免重名，可以使用\acode{qualified}，譬如这样：

\begin{lstlisting}[language=Haskell]
  import qualified Data.Map
\end{lstlisting}

这样的话如果想要调用\acode{Data.Map}的\acode{filter}函数时，就必须要\acode{Data.Map.filter}，这样的话\acode{filter}仍然会引用
普通的\acode{filter}。不过每次都要写\acode{Data.Map}就很麻烦，因此可以这么写：

\begin{lstlisting}[language=Haskell]
  import qualified Data.Map as M
\end{lstlisting}

现在再要调用\acode{Data.Map}的\acode{filter}时，仅需\acode{M.filter}。

可以在\href{https://downloads.haskell.org/ghc/latest/docs/libraries/}{这里}找到标准库中有哪些模块。

通过\href{https://hoogle.haskell.org/}{Hoogle}可以查看函数的位置，这是一个非常棒的 Haskell 搜索引擎，可以通过名称，模块名称甚至
是类型签名来进行搜索。

\subsection*{Data.List}

\acode{Data.List}模块显然都是关于列表的，它提供了些很有用的函数用于列表处理。我们已经学习到了一些（例如\acode{map}与\acode{filter}）
这是因为\acode{Prelude}已经从\acode{Data.List}中加载了不少函数。无需再通过 qualified import 导入\acode{Data.List}，因为它并不会
与任何的\acode{Prelude}名称重名（除开那些已经被\acode{Prelude}从\acode{Data.List}中偷走的）。现在让我们看一下其中一些还没有用到过的
函数：

\acode{intersperse}接受一个元素以及一个列表，将该元素插入至列表中每个元素之间：

\begin{lstlisting}[language=Haskell]
  ghci> intersperse '.' "MONKEY"
  "M.O.N.K.E.Y"
  ghci> intersperse 0 [1..6]
  [1,0,2,0,3,0,4,0,5,0,6]
\end{lstlisting}

\acode{intercalate}接受一个列表以及一个列表的列表，将前者插入至后者之间在打平结果：

\begin{lstlisting}[language=Haskell]
  ghci> intercalate " " ["hey","there","guys"]
  "hey there guys"
  ghci> intercalate [0,0,0] [[1,2,3],[4,5,6],[7,8,9]]
  [1,2,3,0,0,0,4,5,6,0,0,0,7,8,9]
\end{lstlisting}

\acode{transpose}接受一个列表的列表，如果将其视为一个二维的矩阵，那么就是列变为行，行变位列：

\begin{lstlisting}[language=Haskell]
  ghci> transpose [[1,2,3],[4,5,6],[7,8,9]]
  [[1,4,7],[2,5,8],[3,6,9]]
  ghci> transpose ["hey", "there", "guys"]
  ["htg","ehu","yey","rs","e"]
\end{lstlisting}

假设我们有一些多项式 $3x^2 + 5x + 9, 10x^3 + 9$ 以及 $ 8x^3 + 5x^2 + x - 1$，我们希望对它们求和，那么可以使用列表\acode{[0,3,5,9]}，
\acode{[10,0,0,9]}以及\acode{[8,5,1,-1]}来代表它们的系数（分别为 $x^3,x^2,x^1,x^0$ 的系数），那么可以这样：

\begin{lstlisting}[language=Haskell]
  ghci> map sum $ transpose [[0,3,5,9],[10,0,0,9],[8,5,1,-1]]
  [18,8,6,17]
\end{lstlisting}

上述做法就是先转置整个列表\acode{transpose}，这就代表着每个同幂的系数在一个列表中，再将\acode{sum}映射至这个转置后的列表中的每个元素（列表）。

\acode{foldl'}与\acode{foldl1'}相对于它们的懒加载的原版是更严格的版本，当使用原版的懒加载 fold 用于一个很大的列表，很有可能就会得到一个
堆栈溢出的错误。罪魁祸首就是因为 fold 的懒加载特性，累加器的值并不会在 folding 时真正的去计算，相反是在需要结果时才去进行计算（这也被称为一个
型实转换程序 thunk）。这发生在每个中间累加器上，且所有的这些 thunk 都会导致堆栈溢出。strict 版本由于不是懒加载的，是真实的计算中间值而不是
一直在栈上堆叠。因此当使用懒加载的 folds 时遇到了堆栈溢出，可以尝试一下用它们的严格版本。

\acode{concat}打平一个列表的列表：

\begin{lstlisting}[language=Haskell]
  ghci> concat ["foo", "bar", "car"]
  "foobarcar"
  ghci> concat [[3,4,5],[2,3,4],[2,1,1]]
  [3,4,5,2,3,4,2,1,1]
\end{lstlisting}

\acode{concatMap}首先映射一个函数至列表接着将该列表进行\acode{concat}：

\begin{lstlisting}[language=Haskell]
  ghci> concatMap (replicate 4) [1..3]
  [1,1,1,1,2,2,2,2,3,3,3,3]
\end{lstlisting}

\acode{and}接受一个布尔值的列表，当所有值皆为\acode{True}时返回\acode{True}：

\begin{lstlisting}[language=Haskell]
  ghci> and $ map (>4) [5,6,7,8]
  True
  ghci> and $ map (==4) [4,4,3,4,4]
  False
\end{lstlisting}

\acode{or}与\acode{and}类似，只不过是任意元素为\acode{True}时返回\acode{True}：

\begin{lstlisting}[language=Haskell]
  ghci> or $ map (==4) [2,3,4,5,6,7]
  True
  ghci> or $ map (>4) [1,2,3]
  False
\end{lstlisting}

\acode{any}与\acode{all}接受一个子句，然后检查列表中的所有元素，通常而言我们会使用这两个函数而不是像上面那样先\acode{map}接着\acode{and}
或是\acode{or}。

\begin{lstlisting}[language=Haskell]
  ghci> any (==4) [2,3,5,6,1,4]
  True
  ghci> all (>4) [6,9,10]
  True
  ghci> all (`elem` ['A'..'Z']) "HEYGUYSwhatsup"
  False
  ghci> any (`elem` ['A'..'Z']) "HEYGUYSwhatsup"
  True
\end{lstlisting}

\acode{iterate}接受一个函数以及一个起始值，将函数应用在这个起始值得到结果后，再将函数应用至该结果，以此类推，返回一个无限列表。

\begin{lstlisting}[language=Haskell]
  ghci> take 10 $ iterate (*2) 1
  [1,2,4,8,16,32,64,128,256,512]
  ghci> take 3 $ iterate (++ "haha") "haha"
  ["haha","hahahaha","hahahahahaha"]
\end{lstlisting}

\acode{splitAt}接受一个数值与一个列表，将列表从数值作为的索引出切分为两部分，返回一个包含了切分后两个列表的二元元组：

\begin{lstlisting}[language=Haskell]
  ghci> splitAt 3 "heyman"
  ("hey","man")
  ghci> splitAt 100 "heyman"
  ("heyman","")
  ghci> splitAt (-3) "heyman"
  ("","heyman")
  ghci> let (a,b) = splitAt 3 "foobar" in b ++ a
  "barfoo"
\end{lstlisting}

\acode{takeWhile}是一个非常有用的小函数，它从一个列表中从头开始获取元素，直到元素不再满足子句的条件，返回之前所有满足元素的列表：

\begin{lstlisting}[language=Haskell]
  ghci> takeWhile (>3) [6,5,4,3,2,1,2,3,4,5,4,3,2,1]
  [6,5,4]
  ghci> takeWhile (/=' ') "This is a sentence"
  "This"
\end{lstlisting}

假设我们想要所有三次方都小于 10,000 的值之和，将\acode{(^3)}映射至\acode{[1..]}，然后应用一个过滤函数再进行求和这是做不到的，
因为过滤一个无限长的列表将永远都不会结束。虽然我们知道列表里的元素是递增的，但是 Haskell 并不知道，因此需要这么做：

\begin{lstlisting}[language=Haskell]
  ghci> sum $ takeWhile (<10000) $ map (^3) [1..]
  53361
\end{lstlisting}

将\acode{(^3)}应用至一个无限列表，然后一旦元素超过 10,000 那么列表将被截断，这样才可以求和。

\acode{dropWhile}也类似，它扔掉所有子句中条件判断为真的元素，一旦子句返回\acode{False}，则返回剩余的列表。

\begin{lstlisting}[language=Haskell]
  ghci> dropWhile (/=' ') "This is a sentence"
  " is a sentence"
  ghci> dropWhile (<3) [1,2,2,2,3,4,5,4,3,2,1]
  [3,4,5,4,3,2,1]
\end{lstlisting}

\acode{span}有点像\acode{takeWhile}，不过它返回的是一对列表。第一个列表包含了所有\acode{takeWhile}所返回的元素，第二个列表则是
剩余的部分：

\begin{lstlisting}[language=Haskell]
  ghci> let (fw, rest) = span (/=' ') "This is a sentence" in "First word:" ++ fw ++ ", the rest:" ++ rest
  "First word: This, the rest: is a sentence"
\end{lstlisting}

\acode{break}则是列表中第一个元素令子句条件为真时，切分并返回一对列表。\acode{break p}等同于\acode{span (not . p)}。

\begin{lstlisting}[language=Haskell]
  ghci> break (==4) [1,2,3,4,5,6,7]
  ([1,2,3],[4,5,6,7])
  ghci> span (/=4) [1,2,3,4,5,6,7]
  ([1,2,3],[4,5,6,7])
\end{lstlisting}

使用\acode{break}时，第一个满足条件的元素将会放在第二个列表的头部。

\acode{sort}则是对一个列表排序。元素的类型必须属于\acode{Ord} typeclass：

\begin{lstlisting}[language=Haskell]
  ghci> sort [8,5,3,2,1,6,4,2]
  [1,2,2,3,4,5,6,8]
  ghci> sort "This will be sorted soon"
  "    Tbdeehiillnooorssstw"
\end{lstlisting}

\acode{group}接受一个列表，并将相邻的相同的元素组成子列表：

\begin{lstlisting}[language=Haskell]
  ghci> group [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
  [[1,1,1,1],[2,2,2,2],[3,3],[2,2,2],[5],[6],[7]]
\end{lstlisting}

如果在 group 一个列表之前进行排序，那么我们就可以知道每个元素在列表中出现了多少次：

\begin{lstlisting}[language=Haskell]
  ghci> map (\l@(x:xs) -> (x,length l)) . group . sort $ [1,1,1,1,2,2,2,2,3,3,2,2,2,5,6,7]
  [(1,4),(2,7),(3,2),(5,1),(6,1),(7,1)]
\end{lstlisting}

\acode{inits}与\acode{tails}类似于\acode{init}与\acode{tail}，不同之处在于前者们会递归的应用至一个列表直到空：

\begin{lstlisting}[language=Haskell]
  ghci> inits "w00t"
  ["","w","w0","w00","w00t"]
  ghci> tails "w00t"
  ["w00t","00t","0t","t",""]
  ghci> let w = "w00t" in zip (inits w) (tails w)
  [("","w00t"),("w","00t"),("w0","0t"),("w00","t"),("w00t","")]
\end{lstlisting}

尝试一下使用 fold 来实现查找子列表：

\begin{lstlisting}[language=Haskell]
  search :: (Eq a) => [a] -> [a] -> Bool
  -- search needle haystack =
  --   let nlen = length needle
  --    in foldl (\acc x -> if take nlen x == needle then True else acc) False (tails haystack)
  search needle haystack =
    let nlen = length needle
     in foldl (\acc x -> (take nlen x == needle) || acc) False (tails haystack)
\end{lstlisting}

首先调用\acode{tails}来处理需要查找的列表，接着查找每个 tail 直到该 tail 的头是期望找到的。

上述代码的行为实际上就是\acode{isInfixOf}函数，该函数在一个列表中查找子列表，在发现了该子列表时返回\acode{True}：

\begin{lstlisting}[language=Haskell]
  ghci> "cat" `isInfixOf` "im a cat burglar"
  True
  ghci> "Cat" `isInfixOf` "im a cat burglar"
  False
  ghci> "cats" `isInfixOf` "im a cat burglar"
  False
\end{lstlisting}

\acode{isPrefixOf}与\acode{isSuffixOf}则是从前往后进行查找与从后往前进行查找：

\begin{lstlisting}[language=Haskell]
  ghci> "hey" `isPrefixOf` "hey there!"
  True
  ghci> "hey" `isPrefixOf` "oh hey there!"
  False
  ghci> "there!" `isSuffixOf` "oh hey there!"
  True
  ghci> "there!" `isSuffixOf` "oh hey there"
  False
\end{lstlisting}

\acode{elem}与\acode{notElem}则是查找元素是否在列表中。

\acode{partition}接受一个列表以及一个子句，返回一对列表，第一个列表包含了所有符合子句条件的元素，其余的在第二个列表：

\begin{lstlisting}[language=Haskell]
  ghci> partition (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"
  ("BOBMORGAN","sidneyeddy")
  ghci> partition (>3) [1,3,5,6,3,2,1,0,3,7]
  ([5,6,7],[1,3,3,2,1,0,3])
\end{lstlisting}

理解\acode{partition}有别于\acode{span}与\acode{break}是非常重要的：

\begin{lstlisting}[language=Haskell]
  ghci> span (`elem` ['A'..'Z']) "BOBsidneyMORGANeddy"
  ("BOB","sidneyMORGANeddy")
\end{lstlisting}

因为\acode{span}与\acode{break}两者是一旦元素满足子句条件便停止，而\acode{partition}则是根据子句判断遍历整个列表。

\acode{find}接受一个子句以及一个列表，返回首个满足子句条件的元素。不过它返回的元素是被包含在\acode{Maybe}值之中。我们将会在下一节
深入讲解代数数据类型，不过现在我们需要知道的是：一个\acode{Maybe}值可以是\acode{Just something}或是\acode{Nothing}。这就像是
一个列表既可以是空列表也可以是带有元素的列表，而\acode{Maybe}即可以是无元素又可以是一个元素。

\begin{lstlisting}[language=Haskell]
  ghci> find (>4) [1,2,3,4,5,6]
  Just 5
  ghci> find (>9) [1,2,3,4,5,6]
  Nothing
  ghci> :t find
  find :: (a -> Bool) -> [a] -> Maybe a
\end{lstlisting}

这里需要注意的是\acode{find}的类型，它返回的是\acode{Maybe a}。

\acode{elemIndex}有点像\acode{elem}，不过它返回的不是布尔值，而是一个由\acode{Maybe}包含的索引，如果元素不在列表中，则返回
\acode{Nothing}：

\begin{lstlisting}[language=Haskell]
  ghci> :t elemIndex
  elemIndex :: Eq a => a -> [a] -> Maybe Int
  ghci> 4 `elemIndex` [1,2,3,4,5,6]
  Just 3
  ghci> 10 `elemIndex` [1,2,3,4,5,6]
  Nothing
\end{lstlisting}

\acode{elemIndices}类似于\acode{elemIndex}，不过它返回的是索引的列表，因为是列表，所以即使找不到元素也可以返回一个空列表，
这样就不需要一个\acode{Maybe}类型了：

\begin{lstlisting}[language=Haskell]
  ghci> ' ' `elemIndices` "Where are the spaces?"
  [5,9,13]
\end{lstlisting}

\acode{finxIndex}像\acode{find}，不过返回的是索引：

\begin{lstlisting}[language=Haskell]
  ghci> findIndex (==4) [5,3,2,1,6,4]
  Just 5
  ghci> findIndex (==7) [5,3,2,1,6,4]
  Nothing
  ghci> findIndices (`elem` ['A'..'Z']) "Where Are The Caps?"
  [0,6,10,14]
\end{lstlisting}

我们已经尝试过了\acode{zip}与\acode{zipWith}，那么对于多个列表就可以使用\acode{zip3}，\acode{zip4}等等，以及\acode{zipWith3}，
\acode{zipWith4}等等，这里最高可以是 zip 七个列表。不过有更好的办法可以 zip 无穷多个列表，只不过我们现有的知识暂时还没有办法到那儿。

\begin{lstlisting}[language=Haskell]
  ghci> zipWith3 (\x y z -> x + y + z) [1,2,3] [4,5,2,2] [2,2,3]
  [7,9,8]
  ghci> zip4 [2,3,3] [2,2,2] [5,5,3] [2,2,2]
  [(2,2,5,2),(3,2,5,2),(3,2,3,2)]
\end{lstlisting}

跟普通的\acode{zip}一样，计算到最短的列表结束为止。

当处理文件或者是其他地方而来的输入，\acode{lines}则是一个非常有用的函数：

\begin{lstlisting}[language=Haskell]
  ghci> lines "first line\nsecond line\nthird line"
  ["first line","second line","third line"]
\end{lstlisting}

\acode{'\\n'}是 unix 的换行符。

\acode{unlines}则是与\acode{lines}相反，将字符串列表变回一个由\acode{'\\n'}分隔的大字符串：

\begin{lstlisting}[language=Haskell]
  ghci> unlines ["first line", "second line", "third line"]
  "first line\nsecond line\nthird line\n"
\end{lstlisting}

\acode{words}与\acode{unwords}则是分隔与组装一行字符串：

\begin{lstlisting}[language=Haskell]
  ghci> words "hey these are the words in this sentence"
  ["hey","these","are","the","words","in","this","sentence"]
  ghci> words "hey these           are    the words in this\nsentence"
  ["hey","these","are","the","words","in","this","sentence"]
  ghci> unwords ["hey","there","mate"]
  "hey there mate"
\end{lstlisting}

\acode{nub}我们已经见识过了，移除列表中的重复元素：

\begin{lstlisting}[language=Haskell]
  ghci> nub [1,2,3,4,3,2,1,2,3,4,3,2,1]
  [1,2,3,4]
  ghci> nub "Lots of words and stuff"
  "Lots fwrdanu"
\end{lstlisting}

\acode{delete}接受一个元素以及一个列表，删除列表中第一个出现的元素。

\begin{lstlisting}[language=Haskell]
  ghci> delete 'h' "hey there ghang!"
  "ey there ghang!"
  ghci> delete 'h' . delete 'h' $ "hey there ghang!"
  "ey tere ghang!"
  ghci> delete 'h' . delete 'h' . delete 'h' $ "hey there ghang!"
  "ey tere gang!"
\end{lstlisting}

\acode{\\\\}是一个列表比较函数，类似于集合比较，根据右侧的列表中的元素，移除左边列表中匹配的元素。

\begin{lstlisting}[language=Haskell]
  ghci> [1..10] \\ [2,5,9]
  [1,3,4,6,7,8,10]
  ghci> "Im a big baby" \\ "big"
  "Im a  baby"
\end{lstlisting}

处理\acode{[1..10] \\\\ [2,5,9]}类似于\acode{delete 2 . delete 5 . delete 9 \$ [1..10]}。

\acode{union}类似于集合的并集，它返回的是两个列表的集合，做法是将第二个列表中没有在第一个列表中出现的元素，添加至第一个列表的尾部。
注意第二个列表中重复的元素会被移除。

\begin{lstlisting}[language=Haskell]
  ghci> "hey man" `union` "man what's up"
  "hey manwt'sup"
  ghci> [1..7] `union` [5..10]
  [1,2,3,4,5,6,7,8,9,10]
\end{lstlisting}

\acode{intersect}类似于集合的交集，它返回两个列表同时存在的元素：

\begin{lstlisting}[language=Haskell]
  ghci> [1..7] `intersect` [5..10]
  [5,6,7]
\end{lstlisting}

\acode{insert}接受一个元素以及一个可以被排序的列表，将该元素插入到最后一个仍然小于或等于下一个元素的位置，\acode{insert}将会
从列表的头开始，直到找到一个元素大于等于它，接着插入到找到的这个元素之前并结束。

\begin{lstlisting}[language=Haskell]
  ghci> insert 4 [3,5,1,2,8,2]
  [3,4,5,1,2,8,2]
  ghci> insert 4 [1,3,4,4,1]
  [1,3,4,4,4,1]
\end{lstlisting}

如果我们对一个排序后的列表使用\acode{insert}，那么返回的列表仍然是排序好的：

\begin{lstlisting}[language=Haskell]
  ghci> insert 4 [1,2,3,5,6,7]
  [1,2,3,4,5,6,7]
  ghci> insert 'g' $ ['a'..'f'] ++ ['h'..'z']
  "abcdefghijklmnopqrstuvwxyz"
  ghci> insert 3 [1,2,4,3,2,1]
  [1,2,3,4,3,2,1]
\end{lstlisting}

% \acode{genericLength}\acode{genericTake}\acode{genericDrop}\acode{genericSplitAt}\acode{genericIndex}\acode{genericReplicate}

% \begin{lstlisting}[language=Haskell]

% \end{lstlisting}

% \acode{nubBy}\acode{deleteBy}\acode{unionBy}\acode{intersectBy}\acode{groupBy}

% \begin{lstlisting}[language=Haskell]

% \end{lstlisting}

% \acode{on}

% \begin{lstlisting}[language=Haskell]

% \end{lstlisting}

% \acode{sortBy}\acode{insertBy}\acode{maximumBy}\acode{minimumBy}

% \begin{lstlisting}[language=Haskell]

% \end{lstlisting}

\subsection*{Data.Char}

% TODO

\end{document}
