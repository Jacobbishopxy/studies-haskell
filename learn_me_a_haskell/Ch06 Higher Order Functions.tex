\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{柯里化函数}

在 Haskell 中每个函数实质上仅接受一个参数。那么迄今为止定义的那么多函数是怎么接受多个参数的呢？这是就是\textbf{柯里化函数 curried functions}。

\begin{lstlisting}[language=Haskell]
  ghci> max 4 5
  5
  ghci> (max 4) 5
  5
\end{lstlisting}

两个参数间用空格间隔就是简单的\textbf{函数应用 function application}。空格类似于一个操作符，其拥有最高的优先级。例如\acode{max}，其签名为
\acode{max :: (Ord a) => a -> a -> a}，可以被重写为\acode{max :: (Ord a) => a -> (a -> a)}，可以这么理解：\acode{max}接受一个
\acode{a}并返回（即\acode{->}）一个函数，该函数接受一个\acode{a}并返回一个\acode{a}。这就是为什么返回值类型以及函数的参数都是由箭头符
进行分隔的。

那么这样做有什么便利？简单来说如果调用一个仅几个参数的函数，我们得到的是一个\textbf{部分应用 partially applied}的函数，即一个函数接受的参数
与留下未填的参数一样多。

来观测一个简单的函数：

\begin{lstlisting}[language=Haskell]
  multThree :: (Num a) => a -> a -> a -> a
  multThree x y z = x * y * z
\end{lstlisting}

当使用\acode{multThree 3 5 9}或者\acode{((multThree 3) 5) 9}时到底发生了什么？首先，\acode{3}应用至\acode{multThree}，因为它们由空格
进行了分隔（最高优先级）。这就创建了一个接受一个参数的函数，并返回了一个函数。接下来\acode{5}被应用至该函数，以此类推。记住我们的函数类型同样也
可以重写成\acode{multThree :: (Num a) => a -> (a -> (a -> a))}。接下来观察：

\begin{lstlisting}[language=Haskell]
  ghci> let multTwoWithNine = multThree 9
  ghci> multTwoWithNine 2 3
  54
  ghci> let multWithEighteen = multTwoWithNine 2
  ghci> multWithEighteen 10
  180
\end{lstlisting}

调用函数时输入不足的参数，实际上实在创造新的函数。那么如果希望创建一个函数接受一个值并将其与\acode{100}进行比较呢？

\begin{lstlisting}[language=Haskell]
  compareWithHundred :: (Num a, Ord a) => a -> Ordering
  compareWithHundred x = compare 100 x
\end{lstlisting}

如果带着\acode{99}调用它，返回一个\acode{GT}。注意\acode{x}同时位于等式的右侧。那么调用\acode{compare 100}返回的是什么呢？它返回一个接受
一个数值参数并将其与\acode{100}进行比较的函数。现在将其重写：

\begin{lstlisting}[language=Haskell]
  compareWithHundred :: (Num a, Ord a) => a -> Ordering
  compareWithHundred = compare 100
\end{lstlisting}

类型声明仍然相同，因为\acode{compare 100}返回一个函数。\acode{compare}的类型是\acode{(Ord a) -> a -> (a -> Ordering)}，带着
\acode{100}调用它返回一个\acode{(Num a, Ord a) => a -> Ordering}。这里额外的类约束溜走了，这是因为\acode{100}同样也是\acode{Num}
类的一部分。

中缀函数同样可以通过使用分割被部分应用。要分割中缀函数，只需将其用圆括号括起来，并只在一侧提供参数：

\begin{lstlisting}[language=Haskell]
  divideByTen :: (Floating a) => a -> a
  divideByTen = (/10)
\end{lstlisting}

调用\acode{divideByTen 200}等同于\acode{200 / 10}，等同于\acode{(/10) 200}。

那么如果在 GHCI 中尝试\acode{multThree 3 4}而不是通过\textit{let}将其与名称绑定，或是将其传递至另一个函数呢？

\begin{lstlisting}[language=Haskell]
  ghci> multThree 3 4
  <interactive>:1:0:
      No instance for (Show (t -> t))
        arising from a use of `print' at <interactive>:1:0-12
      Possible fix: add an instance declaration for (Show (t -> t))
      In the expression: print it
      In a 'do' expression: print it
\end{lstlisting}

GHCI 会提示我们表达式生成了一个类型为\acode{a -> a}的函数，但是并不知道该如何将其打印至屏幕。函数并不是\acode{Show} typeclass 的实例，
因此我们并不会得到一个函数的展示。

\subsection*{来点高阶函数}

函数可以接受函数作为其参数，也可以返回函数。

\begin{lstlisting}[language=Haskell]
  applyTwice :: (a -> a) -> a -> a
  applyTwice f x = f (f x)
\end{lstlisting}

首先注意的是类型声明。之前我们是不需要圆括号的，因为\acode{->}是自然地右结合。然而在这里却是强制性的，它们表明了第一个参数是一个接受某物并
返回某物的函数，第二个参数同上所述。我们可以用柯里化函数的方式来进行解读，不过为了避免头疼，我们仅需要说该函数接受两个参数并返回一个值。
这里第一个参数是一个函数（即类型\acode{a -> a}），而第二个参数则是\acode{a}。

函数体非常的简单，仅需要使用参数\acode{f}作为一个函数，通过一个空格将\acode{x}应用至其，接着再应用一次\acode{f}。

\begin{lstlisting}[language=Haskell]
  ghci> applyTwice (+3) 10
  16
  ghci> applyTwice (++ " HAHA") "HEY"
  "HEY HAHA HAHA"
  ghci> applyTwice ("HAHA " ++) "HEY"
  "HAHA HAHA HEY"
  ghci> applyTwice (multThree 2 2) 9
  144
  ghci> applyTwice (3:) [1]
  [3,3,1]
\end{lstlisting}

可以看到单个高阶函数可以被用以多种用途。而在命令式编程中，通常使用的是 for 循环、while 循环、将某物设置为一个变量、检查其状态等等，为了达到
某些行为，还需要用接口将其封装，类似于函数；而函数式编程则使用高阶函数来抽象出相同的模式。

现在让我们实现一个名为\acode{flip}的标准库已经存在的函数，其接受一个函数并返回一个类似于原来函数的函数，仅前两个参数被翻转。简单的实现：

\begin{lstlisting}[language=Haskell]
  filp' :: (a -> b -> c) -> (b -> a -> c)
  filp' f = g
    where
      g x y = f y x
\end{lstlisting}

观察类型声明，\acode{flip'}接受一个函数，该函数接受一个\acode{a}与\acode{b}，并返回一个函数，该返回的函数接受一个\acode{b}与\acode{a}。
然而默认情况下函数是柯里化的，第二个圆括号是没有必要的，因为\acode{->}默认是右结合的。\acode{(a -> b -> c) -> (b -> a -> c)}等同于
\acode{(a -> b -> c) -> (b -> (a -> c))}，等同于\acode{(a -> b -> c) -> b -> a -> c}。我们可以用更简单方式来定义该函数：

\begin{lstlisting}[language=Haskell]
  filp'' :: (a -> b -> c) -> b -> a -> c
  filp'' f y x = f x y
\end{lstlisting}

这里我们利用了函数都是柯里化的便利。当不带参数\acode{y}与\acode{x}时调用\acode{flip'' f}时，它将返回一个\acode{f}，该函数接受两个参数，
只不过它们的位置是翻转的。

\begin{lstlisting}[language=Haskell]
  ghci> flip' zip [1,2,3,4,5] "hello"
  [('h',1),('e',2),('l',3),('l',4),('o',5)]
  ghci> zipWith (flip' div) [2,2..] [10,8,6,4,2]
  [5,4,3,2,1]
\end{lstlisting}

\subsection*{Maps \& filters}

\acode{map}接受一个函数以及一个列表，将该函数应用至列表中的每一个元素中，生产一个新的列表。让我们来看一下类型签名：

\begin{lstlisting}[language=Haskell]
  map :: (a -> b) -> [a] -> [b]
  map _ [] = []
  map f (x : xs) = f x : map f xs
\end{lstlisting}

测试：

\begin{lstlisting}[language=Haskell]
  ghci> map (+3) [1,3,5,1,6]
  [4,6,8,4,9]
  ghci> map (-1) [1,3,5,1,6]

  <interactive>:2:1: error:
      • Could not deduce (Num a0)
          arising from a type ambiguity check for
          the inferred type for ‘it’
        from the context: (Num a, Num (a -> b))
          bound by the inferred type for ‘it’:
                     forall {a} {b}. (Num a, Num (a -> b)) => [b]
          at <interactive>:2:1-20
        The type variable ‘a0’ is ambiguous
        These potential instances exist:
          instance Num Integer -- Defined in ‘GHC.Num’
          instance Num Double -- Defined in ‘GHC.Float’
          instance Num Float -- Defined in ‘GHC.Float’
          ...plus two others
          ...plus one instance involving out-of-scope types
          (use -fprint-potential-instances to see them all)
      • In the ambiguity check for the inferred type for ‘it’
        To defer the ambiguity check to use sites, enable AllowAmbiguousTypes
        When checking the inferred type
          it :: forall {a} {b}. (Num a, Num (a -> b)) => [b]
  ghci> map (subtract 1) [1,3,5,1,6]
  [0,2,4,0,5]
  ghci> map (++ "!") ["BIFF", "BANG", "POW"]
  ["BIFF!","BANG!","POW!"]
  ghci> map (replicate 3) [3..6]
  [[3,3,3],[4,4,4],[5,5,5],[6,6,6]]
  ghci> map (map (^2)) [[1,2], [3,4,5,6], [7,8]]
  [[1,4],[9,16,25,36],[49,64]]
  ghci> map fst [(1,2),(3,5),(6,3),(2,6),(2,5)]
  [1,3,6,2,2]
\end{lstlisting}

原书上一章有提到过\acode{-1}这样的情况，报错的原因是 Haskell 将\acode{-1}识别为负数而不是减法，需要显式调用\acode{subtract}
才能识别为 partial 函数并应用至列表中的各个元素上。

\acode{filter}接受一个子句（该子句是一个函数，用于告知某物是否为真），以及一个列表，并返回满足该子句的元素列表。类型签名如下：

\begin{lstlisting}[language=Haskell]
  filter :: (a -> Bool) -> [a] -> [a]
  filter _ [] = []
  filter p (x : xs)
    | p x = x : filter p xs
    | otherwise = filter p xs
\end{lstlisting}

测试：

\begin{lstlisting}[language=Haskell]
  ghci> filter (>3) [1,5,3,2,1,6,4,3,2,1]
  [5,6,4]
  ghci> filter (==3) [1,2,3,4,5]
  [3]
  ghci> filter even [1..10]
  [2,4,6,8,10]
  ghci> let notNull x = not (null x) in filter notNull [[1,2,3],[],[3,4,5],[2,2],[],[],[]]
  [[1,2,3],[3,4,5],[2,2]]
  ghci> filter (`elem` ['a'..'z']) "u LaUgH aT mE BeCaUsE I aM diFfeRent"
  "uagameasadifeent"
  ghci> filter (`elem` ['A'..'Z']) "i lauGh At You BecAuse u r aLL the Same"
  "GAYBALLS"
\end{lstlisting}

将上一章的\acode{quicksort}中的列表表达式替换为\acode{filter}：

\begin{lstlisting}[language=Haskell]
  quicksort :: (Ord a) => [a] -> [a]
  quicksort [] = []
  quicksort (x : xs) =
    let smallerSorted = quicksort (filter (<= x) xs)
        biggerSorted = quicksort (filter (> x) xs)
     in smallerSorted ++ [x] ++ biggerSorted
\end{lstlisting}

现在尝试一下\textbf{找到 100,100 以下最大能被 3829 的值}：

\begin{lstlisting}[language=Haskell]
  largestDivisible :: (Integral a) => a
  largestDivisible = head (filter p [100000, 99999 ..])
    where
      p x = x `mod` 3829 == 0
\end{lstlisting}

接下来尝试一下\textbf{找到所有奇数平方在 10,000 以下的和}，不过首先要介绍一下\acode{takeWhile}函数。该函数接受一个子句以及一个列表，
接着从列表头向后遍历，在子句返回真时返回元素，一旦子句返回假则结束遍历。可以在 GHCI 上用一行来完成任务：

\begin{lstlisting}[language=Haskell]
  ghci> sum (takeWhile (<10000) (filter odd (map (^2) [1..])))
  166650
\end{lstlisting}

当然也可以用列表表达式：

\begin{lstlisting}[language=Haskell]
  ghci> sum (takeWhile (<10000) [n^2 | n <- [1..], odd (n^2)])
  166650
\end{lstlisting}

接下来一个问题是处理考拉兹猜想 Collatz sequences，其数学表达为：

\begin{equation*}
  f(n) =
  \begin{cases}
    n / 2  & \text{if $n \equiv 0$ ($\mod 2$)} \\
    3n + 1 & \text{if $n \equiv 1$ ($\mod 2$)} \\
  \end{cases}
\end{equation*}

我们希望知道的是：\textbf{对于从 1 至 100 的所有数开始，有多少链的长度是大于 15 的？}首先编写一个函数用于生成链：

\begin{lstlisting}[language=Haskell]
  chain :: (Integral a) => a -> [a]
  chain 1 = [1]
  chain n
    | even n = n : chain (n `div` 2)
    | odd n = n : chain (n * 3 + 1)
\end{lstlisting}

因为链的最后一位肯定是 1，也就是边界，那么这就是一个简单的递归函数了。测试：

\begin{lstlisting}[language=Haskell]
  ghci> chain 10
  [10,5,16,8,4,2,1]
  ghci> chain 1
  [1]
  ghci> chain 30
  [30,15,46,23,70,35,106,53,160,80,40,20,10,5,16,8,4,2,1]
\end{lstlisting}

看起来能正常工作，接下来就是获取长度：

\begin{lstlisting}[language=Haskell]
  numLongChains :: Int
  numLongChains = length (filter isLong (map chain [1 .. 100]))
    where
      isLong xs = length xs > 15
\end{lstlisting}

我们将\acode{chain}函数映射至\acode{[1..100]}来获取一个链的列表，接着根据检查长度是否超过 15 的子句来过滤它们、一旦完成过滤，我们就可以看到
结果的列表中还剩多少链。

\begin{anote}
  该函数的类型是\acode{numLongChains :: Int}，因为历史原因\acode{length}返回一个\acode{Int}而不是一个\acode{Num a}。如果我们需要返回一个
  更通用的\acode{Num a}，可以对返回的长度使用\acode{fromIntegral}。
\end{anote}

使用\acode{map}，我们还可以这样做\acode{map (*) [0..]}，如果不是因为别的原因要解释柯里化以及偏函数是实值，那么可以将其传递至其它函数，
或者置入列表中（仅仅不能将其变为字符串）。迄今为止，我们只映射了单参数的函数至列表，例如\acode{map (*2) [0..]}类型是\acode{(Num a) => [a]}，
我们同样可以这么做\acode{map (*) [0..]}。这里将会对列表中的每个数值应用函数\acode{*}，即类型为\acode{(Num a) => a -> a -> a}。将一个参数
应用于需要两个参数的函数将会返回需要一个参数的函数。如果将\acode{*}映射至列表\acode{[0..]}，得到的则是一个接受单个参数的函数的列表，即
\acode{(Num a) => [a -> a]}。也就是说\acode{map (*) [0..]}生产一个这样的列表\acode{[(0*),(1*),(2*),(3*),(4*),(5*)..]}。

\begin{lstlisting}[language=Haskell]
  ghci> let listOfFuns = map (*) [0..]
  ghci> (listOfFuns !! 4) 5
  20
\end{lstlisting}

\subsection*{Lambdas}

构建 lambda 的方式是写一个\acode{\\}，接着是由空格分隔的参数，再然后是\acode{->}符，最后是函数体。

对于\acode{numLongChains}函数而言，不再需要一个\acode{where}子句：

\begin{lstlisting}[language=Haskell]
  numLongChains' :: Int
  numLongChains' = length (filter (\xs -> length xs > 15) (map chain [1 .. 100]))
\end{lstlisting}

lambdas 也是表达式，上述代码中的表达式\acode{\\xs -> length xs > 15}返回的就是一个函数，其用作于告知列表的长度是否超过 15。

对于不熟悉柯里化以及偏函数应用的人而言，通常会在不必要的地方使用 lambdas。例如表达式\acode{map (+3) [1,6,3,2]}以及
\acode{map (\x -> x + 3) [1,6,3,2]}是等价的，因为\acode{(+3)}以及\acode{(\x -> x + 3)}皆为接受一个值并加上 3 的函数。

与普通函数一样，lambdas 可以接受任意数量的参数：

\begin{lstlisting}[language=Haskell]
  ghci> zipWith (\a b -> (a * 30 + 3) / b) [5,4,3,2,1] [1,2,3,4,5]
  [153.0,61.5,31.0,15.75,6.6]
\end{lstlisting}

与普通函数一样，也可以在 lambdas 中进行模式匹配。唯一不同点在于不能在一个参数内定义若干模式，例如对同样一个参数做\acode{[]}以及\acode{(x:xs)}
模式。如果一个模式匹配再 lambda 中失败了，一个运行时错误则会出现，所以需要特别注意在 lambdas 中进行模式匹配！

\begin{lstlisting}[language=Haskell]
  ghci> map (\(a,b) -> a + b) [(1,2),(3,5),(6,3),(2,6),(2,5)]
  [3,8,9,8,7]
\end{lstlisting}

lambdas 通常都被圆括号包围，除非我们想让它一直延伸到最右。有趣的来了：函数默认情况下是柯里化的，以下两者相等：

\begin{lstlisting}[language=Haskell]
  addThree :: (Num a) => a -> a -> a -> a
  addThree x y z = x + y + z
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  addThree :: (Num a) => a -> a -> a -> a
  addThree = \x -> \y -> \z -> x + y + z
\end{lstlisting}

\subsection*{fold}

一个 fold 接受一个二元函数，一个起始值（可以称其为 accumulator）以及一个需要被 fold 的列表。二元函数接受两个参数，第一个是 accumulator，
第二个则是列表中第一个（或最后一个）元素，然后再生产一个新的 accumulator。接着二元函数再次被调用，带着新的 accumulator 以及新的列表中第一个
（或最后一个）元素，以此类推。一旦遍历完整个列表，仅剩 accumulator 剩余，即最终答案。

首先让我们看一下\acode{foldl}函数，也被称为左折叠 left fold。

改写\acode{sum}的实现：

\begin{lstlisting}[language=Haskell]
  sum' :: (Num a) => [a] -> a
  sum' xs = foldl (\acc x -> acc + x) 0 xs
\end{lstlisting}

如果考虑到函数是柯里化的，那么可以简化实现：

\begin{lstlisting}[language=Haskell]
  sum' :: (Num a) => [a] -> a
  sum' = foldl (+) 0
\end{lstlisting}

这是因为 lambda 函数\acode{\\acc x -> acc + x}等同于\acode{(+)}，所以可以省略掉\acode{xs}这个参数，因为调用\acode{foldl (+) 0}将
返回一个接受列表的函数。

接下来通过左折叠来实现\acode{elem}这个函数：

\begin{lstlisting}[language=Haskell]
  elem' :: (Eq a) => a -> [a] -> Bool
  elem' y ys = foldl (\acc x -> if x == y then True else acc) False ys
\end{lstlisting}

让我们看一下这里究竟做了些什么。这里的起始值与 accumulator 都是布尔值。在处理 fold 时，accumulator 与返回值的类型总是要一致的。这里的起始值
为\acode{False}，即假设寻找的值并不在列表中。接着就是检查当前元素是否为需要找到的那个，如果是则将 accumulator 设为\acode{True}，不是则不变。

\acode{foldr} 类似于左折叠，只不过 accumulator 是从列表右侧开始。

以下是使用右折叠来实现\acode{map}：

\begin{lstlisting}[language=Haskell]
  map' :: (a -> b) -> [a] -> [b]
  map' f xs = foldr (\x acc -> f x : acc) [] xs
\end{lstlisting}

\textbf{折叠可以用于实现任意一个想要一次性遍历列表中所有元素的函数，并基于此进行返回。任何时候想要遍历一个列表来返回一些东西时，那么这个时候
  就很可能需要一个 fold。}这也是为什么在函数式编程中，连同 maps 与 filters，fold 是最有用的函数类型。

\acode{foldl1}与\acode{foldr1}类似于\acode{foldl}与\acode{foldr}，区别在于不需要提供一个显式的初始值。它们假设首个（或最后的）元素为
起始值，接着从临近的元素开始进行 fold。由于依赖列表至少有一个元素，空列表的情况下它们会导致运行时错误；而\acode{foldl}与\acode{foldr}则
不会。

现在通过 fold 来实现标准库的函数，看看 fold 的强大之处：

\begin{lstlisting}[language=Haskell]
  maximum' :: (Ord a) => [a] -> a
  maximum' = foldr1 (\x acc -> if x > acc then x else acc)

  reverse' :: [a] -> [a]
  reverse' = foldl (\acc x -> x : acc) []

  product' :: (Num a) => [a] -> a
  product' = foldr1 (*)

  filter' :: (a -> Bool) -> [a] -> [a]
  filter' p = foldr (\x acc -> if p x then x : acc else acc) []

  head' :: [a] -> a
  head' = foldr1 (\x _ -> x)

  last' :: [a] -> a
  last' = foldl1 (\_ x -> x)
\end{lstlisting}

% TODO

\begin{lstlisting}[language=Haskell]

\end{lstlisting}

\end{document}
