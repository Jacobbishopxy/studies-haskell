\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{Hello, world!}

在文件编辑器中敲下：

\begin{lstlisting}[language=Haskell]
  main = putStrLn "hello, world"
\end{lstlisting}

我们定义了一个\acode{main}，其调用了一个名为\acode{putStrLn}的函数，其参数为\acode{"hello, world"}。将其保存为\acode{helloworld.hs}。
打开终端并 cd 到该文件处，输入命令：

\begin{lstlisting}
  $ ghc --make helloworld
  [1 of 1] Compiling Main             ( helloworld.hs, helloworld.o )
  Linking helloworld ...
\end{lstlisting}

执行：

\begin{lstlisting}
  $ ./helloworld
  hello, world
\end{lstlisting}

我们第一个编译的程序好了！

测试一下我们所写的。首先是查看\acode{putStrLn}的类型：

\begin{lstlisting}[language=Haskell]
  ghci> :t putStrLn
  putStrLn :: String -> IO ()
  ghci> :t putStrLn "hello, world"
  putStrLn "hello, world" :: IO ()
\end{lstlisting}

我们可以这样解读\acode{putStrLn}：\acode{putStrLn}接受一个字符串并返回一个\textbf{I/O action}，其返回值的类型是\acode{()}（也就是
空元组，或是 unit 形态）。一个 I/O action 就是在执行时会造成副作用的动作，常常指读取输入或输出到屏幕，同时也代表返回某些值。

那么 I/O action 会在什么时候触发呢？这就是\acode{main}的作用。一个 I/O action 会在我们把它绑定到 \acode{main} 这个名字并执行程序的
时候触发。

把整个程序限制在只能有一个 I/O action 看起来有限制，这就是为什么需要\textit{do}语法将所有 I/O action 粘合成一个。例如：

\begin{lstlisting}[language=Haskell]
  main = do
    putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
\end{lstlisting}

有趣，新的语法！这读起来非常像是命令式编程。注意我们写了\textit{do}之后接着一连串指令，就像是在写命令式编程那样。

正因如此，\acode{main}的类型签名总会是\acode{main :: IO something}，这里的\acode{something}就是写具体类型。

我们之前没有遇到过的情况是第三行，即\acode{name <- getLine}。它看起来像是从输入中读取一行，并存储至变量\acode{name}中。让我们测试一下
\acode{getLine}的类型：

\begin{lstlisting}[language=Haskell]
  ghci> :t getLine
  getLine :: IO String
\end{lstlisting}

好的，\acode{getLine}是一个 I/O action，其包含了\acode{String}返回值类型。这很合理，因为它将等待用户在终端的输入，然后将输入转换为一个
字符串。那\acode{name <- getLine}是什么呢？你可以将这段代码读作：\textbf{执行一个 I/O action，\acode{getLine}将其结果绑定到
  \acode{name}这个名字}。\acode{getLine}的类型是\acode{IO String}，因此\acode{name}的类型也就是\acode{String}。当我们从 I/O
action 中拿取数据时，就一定同时要在另一个 I/O action 中。这就是 Haskell 如何漂亮的区分 pure 和 impure 程序的方法。\acode{getLine}
在这样的意义下是 impure 的，因为执行两次的时候它没法保证会返回一样的值，这就是为什么它需要在一个 \acode{IO} 的类型构建函数中，这样才能在
I/O action 中取出数据。任何一段程序一旦依赖 I/O 数据，那么则会被视为 I/O 代码（原文用 tainted）。

当提到污染，并不是说 I/O action 所提供的返回不能在 pure 代码中使用。只要我们绑定它到一个名字，我们便可以暂时使用它。也就是说
\acode{name <- getLine}的\acode{name}就是一个普通的字符串。

让我们看以下代码是否合法：

\begin{lstlisting}[language=Haskell]
  nameTag = "Hello, my name is " ++ getLine
\end{lstlisting}

该代码不合法是因为\acode{++}需要两个参数都是同样参数类型的列表，左参数为\acode{String}（或\acode{[Char]}），而\acode{getLine}则是
\acode{IO String}。显然不能将两者合并。要从\acode{IO String}中获取值只能在 I/O action 内部做\acode{name <- getLine}。换言之，
如果要处理 impure 数据，那么就需要再 impure 环境中做。

每个 I/O action 执行都有一个封装后的返回。那么之前的代码同样也可以这么写：

\begin{lstlisting}[language=Haskell]
  main = do
    foo <- putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
\end{lstlisting}

然而\acode{foo}只会得到一个\acode{()}值，因此这么做并无实际意义。注意最后的\acode{putStrLn}并没有绑定至任何事物。这是因为在一个
\textit{do}代码块中，\acode{最后的 action 不能绑定至一个名称}，如前面两行那样。我们在之后讲解 Monad 的时候会说明为什么。

除了最后一行，\textit{do}代码块中的每一行皆可进行绑定。因此\acode{putStrLn "BLAH"}可以被写成\acode{_ <- putStrLn "BLAH"}，不过
这并没大用，因此不如不写。

初学者可能会这么想：

\begin{lstlisting}[language=Haskell]
  name = getLine
\end{lstlisting}

记住，从 I/O action 中取值，必须将其置于其它 I/O action 内，并使用\acode{<-}将其结果绑定至一个名称。

我们能够在\textit{do}代码块中使用\textit{let}绑定，就如在列表表达式中那样：

\begin{lstlisting}[language=Haskell]
  import Data.Char

  main = do
    putStrLn "What's your first name?"
    firstName <- getLine
    putStrLn "What's your last name?"
    lastName <- getLine

    let bigFirstName = map toUpper firstName
        bigLastName = map toUpper lastName

    putStrLn $ "hey " ++ bigFirstName ++ " " ++ bigLastName ++ ", how are you?"
\end{lstlisting}

注意在\acode{do}代码块中的 I/O actions，同时注意\acode{let}与其名字，缩进在 Haskell 中不会被无视。

接下来是一个持续读取输入行，并在同一行打印翻转后单词的程序。程序会在输入空行后结束：

\begin{lstlisting}[language=Haskell]
  main = do
  line <- getLine
  if null line
    then return ()
    else do
      putStrLn $ reverseWords line
      main

reverseWords :: String -> String
reverseWords = unwords . map reverse . words
\end{lstlisting}

首先我们来看一下\acode{reverseWords}，这个普通的函数假如接受了个字符串\acode{"hey there man"}，那么先调用\acode{words}来参数
一个字的列表，比如\acode{["hey", "there", "man"]}。接着将\acode{reverse}映射至列表，获得\acode{["yeh", "ereht", "nam"]}，
接着再通过\acode{unwords}将列表转换为一个字符串\acode{"yeh ereht nam"}。这里用到了函数组合，如果没有函数组合的话，我们需要这样做
\acode{reverseWords st = unwords (map reverse (words st))}。

我们来看一下在\textit{else}中发生了什么事。由于我们必须要一个 I/O action 在\textit{else}之后，我们使用一个\textit{do}代码块
将两个 I/O action 整合成一个。我们也可以这么写：

\begin{lstlisting}[language=Haskell]
  else (do
    putStrLn $ reverseWords line
    main)
\end{lstlisting}

这样可以更显式的将\textit{do}代码块认做是一个 I/O action，不过就是更丑了点。在\textit{do}代码块中，调用\acode{reverseWords}从
\acode{getLine}而来的行，接着输出至终端。之后就是递归，因为\acode{main}自身就是一个 I/O action。也就意味着又回到了程序一开头。

那么当\acode{null line}为真时呢？我们看到\acode{then return ()}。\textbf{在 Haskell 中的\acode{return}与其他语言的
  \acode{return}完全不同！}它们只是有相同的名字，这会迷惑很多人，但是实际上大相径庭。在命令式语言中，\acode{return}通常结束一个
方法的执行，并将结果返回给调用者。在 Haskell（特别是 I/O action 中），则是利用某个 pure 值制造出 I/O action。所以在 I/O 的情况下，
\acode{return "haha"}的类型是\acode{IO String}。将 pure 值包成 I/O action 有什么意义呢？这是因为一定要 I/O action 来
承载空输入行的情况。因此使用\acode{return ()}做了一个没什么用的 I/O action。

在 I/O \textit{do}代码块中放一个\acode{return}并不会结束执行。下面这个程序就会执行到底：

\begin{lstlisting}[language=Haskell]
  main = do
    return ()
    return "HAHAHA"
    line <- getLine
    return "BLAH BLAH BLAH"
    return 4
    putStrLn line
\end{lstlisting}

所有的这些\acode{return}都用于创造 I/O actions，而其并不做任何事情仅仅是封装一个结构，且该结果被抛弃，因为它们并没有绑定到一个
名字上。\acode{return}可以与\acode{<-}组合在一起用于绑定名称：

\begin{lstlisting}[language=Haskell]
  main = do
    a <- return "hell"
    b <- return "yeah!"
    putStrLn $ a ++ " " ++ b
\end{lstlisting}

可以看到，\acode{return}像是相反的\acode{<-}，前者接受一个值，将其放入盒中，后者接受一个盒（并执行它）然后将值取出来，绑定至一个
名称。不过这么做有点多余，特别是在\textit{do}代码块中，可以使用\textit{let}绑定名称：

\begin{lstlisting}[language=Haskell]
  main = do
    let a = "hell"
        b = "yeah"
    putStrLn $ a ++ " " ++ b
\end{lstlisting}

在 I/O \textit{do}代码块中需要\acode{return}的原因有两个：一个是需要一个什么事都不做的 I/O action，或者是不希望这个\textit{do}
代码块形成的 I/O action 的结果值是这个代码块中的最后一个 I/O action。我们希望有一个不同的结果值，所以用\acode{return}来做一个
I/O action 包装想要的结果放在\textit{do}代码块的最后。

在讲下一节的文件之前，让我们看看有哪些实用的函数可以处理 I/O。

\acodered{putStr}类似于\acode{putStrLn}，前者不会换行：

\begin{lstlisting}[language=Haskell]
  main = do   putStr "Hey, "
              putStr "I'm "
              putStrLn "Andy!"
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell putstr_test.hs
  Hey, I'm Andy!
\end{lstlisting}

\acodered{putChar}接受一个字符：

\begin{lstlisting}[language=Haskell]
  main = do   putChar 't'
              putChar 'e'
              putChar 'h'
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell putchar_test.hs
  teh
\end{lstlisting}

\acodered{print}接受任意实现了\acode{Show}的值（意味着知道如何将该值转换为一个字符串）：

\begin{lstlisting}[language=Haskell]
  main = do   print True
              print 2
              print "haha"
              print 3.2
              print [3,4,3]
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell print_test.hs
  True
  2
  "haha"
  3.2
  [3,4,3]
\end{lstlisting}

\acodered{getChar}从输入中读取一个字符：

\begin{lstlisting}[language=Haskell]
  main = do
    c <- getChar
    if c /= ' '
        then do
            putChar c
            main
        else return ()
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell getchar_test.hs
  hello sir
  hello
\end{lstlisting}

\acodered{when}函数可以在\acode{Control.Monad}中找到（通过\acode{import Control.Monad}）。它在\textit{do}代码块中很有意思，
它像是一个流控声明，但其实它是一个普通函数。其接受一个布尔值以及一个 I/O action，如果改布尔值为真，返回同样的 I/O action；如果为假，
则返回\acode{return ()}，即什么都不做的 I/O action。下面是使用\acode{when}来改写之前的程序：

\begin{lstlisting}[language=Haskell]
  import Control.Monad

  main = do
      c <- getChar
      when (c /= ' ') $ do
          putChar c
          main
\end{lstlisting}

如你所见，它将\acode{if something then do some I/O action else return ()}这样的模式封装了起来。

\acodered{sequence}接受一个列表的 I/O action 并返回一个 I/O action。其类型签名\acode{sequence :: [IO a] -> IO [a]}。例：

\begin{lstlisting}[language=Haskell]
  main = do
    a <- getLine
    b <- getLine
    c <- getLine
    print [a,b,c]
\end{lstlisting}

等同于：

\begin{lstlisting}[language=Haskell]
  main = do
    rs <- sequence [getLine, getLine, getLine]
    print rs
\end{lstlisting}

由于对一个队列映射一个返回 I/O action 的函数，再\acode{sequence}这个动作太常用了。所以\acodered{mapM}与\acodered{mapM_}
被引入了。前者接受一个函数与一个列表，映射函数至列表接着再 sequences；后者一样，只不过丢弃返回值。在不关心 sequenced I/O action
的返回值时，我们使用后者。

\begin{lstlisting}[language=Haskell]
  ghci> mapM print [1,2,3]
  1
  2
  3
  [(),(),()]
  ghci> mapM_ print [1,2,3]
  1
  2
  3
\end{lstlisting}

\acodered{forever}接受一个 I/O action 返回一个 I/O action，无限循环：

\begin{lstlisting}[language=Haskell]
  import Control.Monad
  import Data.Char

  main = forever $ do
      putStr "Give me some input: "
      l <- getLine
      putStrLn $ map toUpper l
\end{lstlisting}

\acodered{forM}类似于\acode{mapM}，不同之处在于参数调转了。为什么有用呢？一些创造性的 lambdas 与\textit{do}的使用，让我们可以
这样做：

\begin{lstlisting}[language=Haskell]
  import Control.Monad

  main = do
      colors <- forM [1,2,3,4] (\a -> do
          putStrLn $ "Which color do you associate with the number " ++ show a ++ "?"
          color <- getLine
          return color)
      putStrLn "The colors that you associate with 1, 2, 3 and 4 are: "
      mapM putStrLn colors
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell form_test.hs
  Which color do you associate with the number 1?
  white
  Which color do you associate with the number 2?
  blue
  Which color do you associate with the number 3?
  red
  Which color do you associate with the number 4?
  orange
  The colors that you associate with 1, 2, 3 and 4 are:
  white
  blue
  red
  orange
\end{lstlisting}

\subsection*{文件与流}

现在让我们来看一下\acodered{getContents}，这是一个从标准输入中读取所有东西直到遇到结束符的 I/O action。其类型为
\acode{getContents :: IO String}。\acode{getContents}是一个 lazy I/O。当使用\acode{foo <- getContents}，它不会
一次性将所有输入读取存储至内存中然后绑定至\acode{foo}。

在我们将一个程序中的输出导向另一个程序时，\acode{getContents}尤其的有用。我们现在来造一个文件：

\begin{lstlisting}[language=Haskell]
  I'm a lil' teapot
  What's with that airplane food, huh?
  It's so small, tasteless
\end{lstlisting}

现在让我们回忆一下之前介绍的\acode{forever}函数。它提示用户输入一行，将输入改为大写，然后再次回到第一步：

\begin{lstlisting}[language=Haskell]
  import Control.Monad
  import Data.Char

  main = forever $ do
      putStr "Give me some input: "
      l <- getLine
      putStrLn $ map toUpper l
\end{lstlisting}

将其保存为\acode{capslocker.sh}并进行编译。通过 unix 的 pipe 将 txt 文件喂给我们的程序：

\begin{lstlisting}[language=Haskell]
  $ ghc --make capslocker
  [1 of 1] Compiling Main             ( capslocker.hs, capslocker.o )
  Linking capslocker ...
  $ cat haiku.txt
  I'm a lil' teapot
  What's with that airplane food, huh?
  It's so small, tasteless
  $ cat haiku.txt | ./capslocker
  I'M A LIL' TEAPOT
  WHAT'S WITH THAT AIRPLANE FOOD, HUH?
  IT'S SO SMALL, TASTELESS
  capslocker <stdin>: hGetLine: end of file
\end{lstlisting}

正如所见，将一个程序（上述案例为\textit{cat}）的输出 pipe 至另一个程序（\textit{capslocker}）作为输入，是由\acode{|}
字符来完成的。

而这里的\acode{forever}就是接受输入并转换后输出。这就是为什么使用\acode{getContents}可以使得程序变得更简洁简短：

\begin{lstlisting}[language=Haskell]
  import Data.Char

  main = do
    contents <- getContents
    putStr $ map toUpper contents
\end{lstlisting}

这里执行\acode{getContents} I/O action 并将其生产的字符串命名为\acode{contents}。接着映射\acode{toUpper}至字符串，
再打印至终端。注意字符串的本质是列表，也是 lazy 的，而\acode{getContents}是 I/O lazy 的，所有在打印出 capslocked 之前，
它不会一次性读取所有内容并存储至内存。实际上会一行一行读取并输出 capslocked，这是因为输出才是真的需要输入数据的时候。

\begin{lstlisting}[language=Haskell]
  $ cat haiku.txt | ./capslocker
  I'M A LIL' TEAPOT
  WHAT'S WITH THAT AIRPLANE FOOD, HUH?
  IT'S SO SMALL, TASTELESS
\end{lstlisting}

如果仅运行\textit{capslockder}并尝试输入呢？

\begin{lstlisting}[language=Haskell]
  $ ./capslocker
  hey ho
  HEY HO
  lets go
  LETS GO
\end{lstlisting}

通过 Ctrl-D 退出。正如你所见，它将我们的输入一行一行的打印出来。当\acode{getContents}的结果绑定至\acode{contents}，
它在内存中并不代表着一个真实字符串，更像是一个 promise，承诺它将最终输出字符串。当映射\acode{toUpper}至\acode{contents}，
则同样是一个承诺，承诺将映射该函数至最终的内容。最后就是当\acode{putStr}发生时，它告知之前的承诺：我需要一个大写的行！
它还未有任何的行，而是告知\acode{contents}：该从命令行中获取一行了。这才是\acode{getContents}实际上从终端中读取并将这一行
交给程序的时候，程序便将这一行用\acode{toUpper}处理并交给\acode{putStr}，\acode{putStr}则打印出它，之后\acode{putStr}
再说：我需要下一行，循环往复，直到读到结束符为止。

下面是一个只打印出少于十个字符行的程序：

\begin{lstlisting}[language=Haskell]
  main = do
    contents <- getContents
    putStr $ shortLinesOnly contents

  shortLinesOnly :: String -> String
  shortLinesOnly input =
    let allLines = lines input
        shortLines = filter (\line -> length line < 10) allLines
        result = unlines shortLines
    in result
\end{lstlisting}

我们尽量让程序的 I/O 部分简短，因为我们的程序本就该接受一些输入并根据输入打印出一些东西。

\acode{shortLinesOnly}函数工作如下：接受一个字符串\acode{"short\\nlooooooooooooooong\\nshort again"}，该字符串
有三行，两行短，中间那行长。运行\acode{lines}函数，转换成\acode{["short", "looooooooooooooong", "short again"]}，
接着绑定至名称\acode{allLines}。该字符串列表被过滤，只留下少于 10 个字符的字符串，即\acode{["short", "short again"]}。
最后，\acode{unlines}将列表转换成一个通过换行符分隔的字符串。

\begin{lstlisting}[language=Haskell]
  i'm short
  so am i
  i am a loooooooooong line!!!
  yeah i'm long so what hahahaha!!!!!!
  short line
  loooooooooooooooooooooooooooong
  short
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ ghc --make shortlinesonly
  [1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )
  Linking shortlinesonly ...
  $ cat shortlines.txt | ./shortlinesonly
  i'm short
  so am i
  short
\end{lstlisting}

我们将内容放至\textit{shortlines.txt}中并 pipe 至编译好的\textit{shortlinesonly}，这样就得到短行了。

从输入中获取字符串，通过一个函数进行转换，然后再输出的这个模式太常见了，因此存在一个名为\acodered{interact}的函数专门用作此模式。

\begin{lstlisting}[language=Haskell]
  main = interact shortLinesOnly

  shortLinesOnly :: String -> String
  shortLinesOnly input =
    let allLines = lines input
        shortLines = filter (\line -> length line < 10) allLines
        result = unlines shortLines
     in result
\end{lstlisting}

当然可以用更少的代码来表达：

\begin{lstlisting}[language=Haskell]
  main = interact $ unlines . filter ((< 10) . length) . lines
\end{lstlisting}

能应用\acode{interact}的情况有几种，一种是从输入 pipe 读取一些内容接着返回一些结果的程序；另一种是用户一行一行的输入，
返回那一行运算后的结果，再接着读取玲一行。

接下来的程序是持续读取一行，接着告诉我们这一行是否为回文。我们可以用\acode{getLine}来读取一行，告诉用户是否为回文，接着再执行
\acode{main}。不过使用\acode{interact}的情况会更加的简单，只需要考虑转换函数。我们的需求中，替换的是每一行输出是否为
\acode{"palindrome"}或者\acode{"not a palindrome"}，也就是说这个函数会转换\acode{"elephant\\nABCBA\\nwhatever"}
成\acode{"not a palindrome\\npalindrome\\nnot a palindrome"}。

\begin{lstlisting}[language=Haskell]
  main = interact respondPalindromes

  respondPalindromes contents =
    unlines
      ( map
          ( \xs ->
              if isPalindrome xs then "palindrome" else "not a palindrome"
          )
          (lines contents)
      )
    where
      isPalindrome xs = xs == reverse xs
\end{lstlisting}

用 point-free 进行改造：

\begin{lstlisting}[language=Haskell]
  respondPalindromes =
  unlines
    . map
      (\xs -> if isPalindrome xs then "palindrome" else "not a palindrome")
    . lines
  where
    isPalindrome xs = xs == reverse xs
\end{lstlisting}

非常的直观。首先它转换\acode{"elephant\\nABCBA\\nwhatever"}为\acode{["elephant", "ABCBA", "whatever"]}，接着映射
一个 lambda 函数，得到\acode{["not a palindrome", "palindrome", "not a palindrome"]}接着\acode{unlines}转为一个
字符串。测试：

\begin{lstlisting}[language=Haskell]
  $ runhaskell palindromes.hs
  hehe
  not a palindrome
  ABCBA
  palindrome
  cookie
  not a palindrome
\end{lstlisting}

尽管我们编写了一个转换输入的大字符串成为另一个大字符串的程序，但其表现的好像是一行一行做的。这是因为 Haskell 是 lazy 的，程序
想要打印出第一行结果，它必须要现有第一行输入，一旦有了第一行输入，那么便打印出第一行结果。这里使用文件终止符来结束程序。

假设我们有这样一个文件：

\begin{lstlisting}
  dogaroo
  radar
  rotor
  madam
\end{lstlisting}

将其保存至\acode{words.txt}。再将其 pipe 至我们的程序：

\begin{lstlisting}[language=Haskell]
  $ cat words.txt | runhaskell palindromes.hs
  not a palindrome
  palindrome
  palindrome
  palindrome
\end{lstlisting}

到现在为止我们遇到的 I/O 都是读取或输出至终端，那么读取和写文件呢？其实我们已经做过这样的事儿了，我们可以想象终端就是一个文件，
而写入和读取它们分别是\acode{stdout}与\acode{stdin}。

首先是一个文件：

\begin{lstlisting}[language=Haskell]
  Hey! Hey! You! You!
  I don't like your girlfriend!
  No way! No way!
  I think you need a new one!
\end{lstlisting}

接着是程序：

\begin{lstlisting}[language=Haskell]
  import System.IO

  main = do
    handle <- openFile "girlfriend.txt" ReadMode
    contents <- hGetContents handle
    putStr contents
    hClose handle
\end{lstlisting}

用程序读取文件：

\begin{lstlisting}[language=Haskell]
  $ runhaskell girlfriend.hs
  Hey! Hey! You! You!
  I don't like your girlfriend!
  No way! No way!
  I think you need a new one!
\end{lstlisting}

我们的程序拥有若干个 I/O actions 被整合在一个\textit{do}代码块中。首先是\acodered{openFile}这个函数，其类型签名为：
\acode{openFile :: FilePath -> IOMode -> IO Handle}，即\acode{openFile}接受一个文件路径，以及一个\acode{IOMode}，
返回一个将会打开文件并将文件关联到句柄的 I/O action。

\acode{FilePath}是\acode{String}的类型别名：

\begin{lstlisting}[language=Haskell]
  type FilePath = String
\end{lstlisting}

而\acode{IOMode}的定义如下：

\begin{lstlisting}[language=Haskell]
  data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
\end{lstlisting}

\acodered{hGetContents}接受一个\acode{Handle}（这样才能知道从哪里获取内容）并返回一个\acode{IO String} -- 一个包含了
文件内容的 I/O action。该函数类似于\acode{getContents}，不同之处在于\acode{getContents}会自动的从标准输入中读取（也就是
终端），而\acode{hGetContents}接受一个文件句柄，该句柄则是告诉它去哪里读取文件。同样的，\acode{hGetContents}不会一次性
读取文件并存储于内存中，而是按需读取。这样就很酷，因为我们可以将\acode{contents}视作文件的所有内容，且并没有全部加载至内存中。
因此如果有一个很大的文件，使用\acode{hGetContents}并不会打爆内存，而是按需读取。

注意这里用于识别文件的句柄与文件内容的概念上的区别。前者是用于区分文件的依据，如果把整个文件系统想象成一本厚厚的书，每个文件分别
是其中的章节，handle 就像是书签标记了正在阅读（或写入）的章节，而内容则是章节本身。

\acode{putStr contents}将内容打印至标准输出，接着是\acodered{hClose}，其接受一个句柄返回一个 I/O action 关闭文件。

函数\acodered{withFile}，其类型签名为\acode{withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a}，是另外
一种方式，它接受一个文件路径，一个\acode{IOMode}，以及一个接受句柄并返回 I/O action 的函数。这个返回的 I/O action 函数
将会打开文件，处理并关闭文件。

\begin{lstlisting}[language=Haskell]
  main = do
  withFile
    "girlfriend.txt"
    ReadMode
    ( \handle -> do
        contents <- hGetContents handle
        putStr contents
    )
\end{lstlisting}

下面是自己实现的\acode{withFile}：

\begin{lstlisting}[language=Haskell]
  withFile' :: FilePath -> IOMode -> (Handle -> IO a) -> IO a
  withFile' path mode f = do
    handle <- openFile path mode
    result <- f handle
    hClose handle
    return result
\end{lstlisting}

我们知道返回值会是一个 I/O action，因此我们可以由\textit{do}开始。首先打开一个文件，得到一个句柄，接着将\acode{handle}应用至
我们的函数并重新拿到一个处理事情的 I/O action。将此 I/O action 绑定至\acode{result}，关闭句柄接着\acode{return result}。
\acode{return}封装\acode{f}的结果进 I/O action，这样 I/O action 中就包含了\acode{f handle}得到的结果。如果
\acode{f handle}返回的是一个从标准输入读取行，并写到文件然后返回读取的行数的 I/O action，在\acode{withFile'}的情况中，
最后的 I/O action 就会包含读入的行数。

\acode{hGetContents}类似\acode{getContents}，还有\acodered{hGetLine}，\acodered{hPutStr}，\acodered{hPutStrLn}，
\acodered{hGetChar}等等。这些\textit{h}开头的函数都是接受一个句柄作为参数，并操作某指定的文件（而不是标准输出）。

加载文件然后将它们的内容视为字符串这件事非常的常见，因此有三个函数能给我们很大的帮助：

\acodered{readFile}的类型签名是\acode{readFile :: FilePath -> IO String}，它接受一个文件路径，返回一个 I/O action，
该 I/O action 将会读取文件（当然是 lazy 的），并将文件内容作为字符串绑定至某名称：

\begin{lstlisting}[language=Haskell]
  main = do
    contents <- readFile "girlfriend.txt"
    putStr contents
\end{lstlisting}

由于我们拿不到句柄，所以我们无法关闭文件，而 Haskell 的\acode{readFile}在背后帮我们做了这件事。

\acodered{writeFile}的类型签名是\acode{writeFile :: FilePath -> String -> IO ()}，它接受一个文件路径以及需要写入的
字符串，返回一个真实写入文件的 I/O action。如果文件存在，则会清空内容再写入：

\begin{lstlisting}[language=Haskell]
  import System.IO
  import Data.Char

  main = do
    contents <- readFile "girlfriend.txt"
    writeFile "girlfriendcaps.txt" (map toUpper contents)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell girlfriendtocaps.hs
  $ cat girlfriendcaps.txt
  HEY! HEY! YOU! YOU!
  I DON'T LIKE YOUR GIRLFRIEND!
  NO WAY! NO WAY!
  I THINK YOU NEED A NEW ONE!
\end{lstlisting}

\acodered{appendFile}的类型签名与\acode{writeFile}一样，只不过前者在文件存在时会直接在已有内容尾部写入。

\begin{lstlisting}[language=Haskell]
  import System.IO

  main = do
    todoItem <- getLine
    appendFile "todo.txt" $ todoItem ++ "\n"
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell appendtodo.hs
  Iron the dishes
  $ runhaskell appendtodo.hs
  Dust the dog
  $ runhaskell appendtodo.hs
  Take salad out of the oven
  $ cat todo.txt
  Iron the dishes
  Dust the dog
  Take salad out of the oven
\end{lstlisting}

之前提到过的\acode{contents <- hGetContents handle}并不会将文件一次性读入内存，所以这么写

\begin{lstlisting}[language=Haskell]
  main = do
  withFile
    "something.txt"
    ReadMode
    ( \handle -> do
        contents <- hGetContents handle
        putStr contents
    )
\end{lstlisting}

实际上像是将文件 pipe 到标准输出。就像是可以把列表想象成流那样，文件也可以是流，即每次读一行再打印到终端上。对于文本文件而言，
默认的 buffer 通常以行划分，而对于二进制文件而言，buffer 则跟操作系统有关，即以 chunk 进行划分。

使用\acode{hSetBuffering}来控制 buffer 的行为，该函数接受一个句柄以及一个\acode{BufferMode}，返回一个设置 buffer
行为的 I/O action。\acode{BufferMode}是一个枚举，有值：\acode{NoBuffering}，\acode{LineBuffering}或
\acode{BlockBuffering (Maybe Int)}（\acode{Maybe Int}代表一个 chunk 的字节，如果是\acode{Nothing}则有系统决定）。
\acode{NoBuffering}表示一次读一个字符（频繁访问磁盘，性能很差）。

使用 2048 字节的 chunk 读取：

\begin{lstlisting}[language=Haskell]
  main = do
  withFile
    "something.txt"
    ReadMode
    ( \handle -> do
        hSetBuffering handle $ BlockBuffering (Just 2048)
        contents <- hGetContents handle
        putStr contents
    )
\end{lstlisting}

用更大的 chunk 来进行数据读取对于减少访问磁盘的次数是很有帮助的，特别是在文件其实是通过网络来访问的时候。

% TODO

% \begin{lstlisting}[language=Haskell]

% \end{lstlisting}

\subsection*{命令行参数}

% TODO

\subsection*{随机}

% TODO

\subsection*{字节串}

% TODO

\subsection*{异常}

% TODO

\end{document}
