\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{Hello, world!}

在文件编辑器中敲下：

\begin{lstlisting}[language=Haskell]
  main = putStrLn "hello, world"
\end{lstlisting}

我们定义了一个\acode{main}，其调用了一个名为\acode{putStrLn}的函数，其参数为\acode{"hello, world"}。将其保存为\acode{helloworld.hs}。
打开终端并 cd 到该文件处，输入命令：

\begin{lstlisting}
  $ ghc --make helloworld
  [1 of 1] Compiling Main             ( helloworld.hs, helloworld.o )
  Linking helloworld ...
\end{lstlisting}

执行：

\begin{lstlisting}
  $ ./helloworld
  hello, world
\end{lstlisting}

我们第一个编译的程序好了！

测试一下我们所写的。首先是查看\acode{putStrLn}的类型：

\begin{lstlisting}[language=Haskell]
  ghci> :t putStrLn
  putStrLn :: String -> IO ()
  ghci> :t putStrLn "hello, world"
  putStrLn "hello, world" :: IO ()
\end{lstlisting}

我们可以这样解读\acode{putStrLn}：\acode{putStrLn}接受一个字符串并返回一个\textbf{I/O action}，其返回值的类型是\acode{()}（也就是
空元组，或是 unit 形态）。一个 I/O action 就是在执行时会造成副作用的动作，常常指读取输入或输出到屏幕，同时也代表返回某些值。

那么 I/O action 会在什么时候触发呢？这就是\acode{main}的作用。一个 I/O action 会在我们把它绑定到 \acode{main} 这个名字并执行程序的
时候触发。

把整个程序限制在只能有一个 I/O action 看起来有限制，这就是为什么需要\textit{do}语法将所有 I/O action 粘合成一个。例如：

\begin{lstlisting}[language=Haskell]
  main = do
    putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
\end{lstlisting}

有趣，新的语法！这读起来非常像是命令式编程。注意我们写了\textit{do}之后接着一连串指令，就像是在写命令式编程那样。

正因如此，\acode{main}的类型签名总会是\acode{main :: IO something}，这里的\acode{something}就是写具体类型。

我们之前没有遇到过的情况是第三行，即\acode{name <- getLine}。它看起来像是从输入中读取一行，并存储至变量\acode{name}中。让我们测试一下
\acode{getLine}的类型：

\begin{lstlisting}[language=Haskell]
  ghci> :t getLine
  getLine :: IO String
\end{lstlisting}

好的，\acode{getLine}是一个 I/O action，其包含了\acode{String}返回值类型。这很合理，因为它将等待用户在终端的输入，然后将输入转换为一个
字符串。那\acode{name <- getLine}是什么呢？你可以将这段代码读作：\textbf{执行一个 I/O action，\acode{getLine}将其结果绑定到
  \acode{name}这个名字}。\acode{getLine}的类型是\acode{IO String}，因此\acode{name}的类型也就是\acode{String}。当我们从 I/O
action 中拿取数据时，就一定同时要在另一个 I/O action 中。这就是 Haskell 如何漂亮的区分 pure 和 impure 程序的方法。\acode{getLine}
在这样的意义下是 impure 的，因为执行两次的时候它没法保证会返回一样的值，这就是为什么它需要在一个 \acode{IO} 的类型构建函数中，这样才能在
I/O action 中取出数据。任何一段程序一旦依赖 I/O 数据，那么则会被视为 I/O 代码（原文用 tainted）。

当提到污染，并不是说 I/O action 所提供的返回不能在 pure 代码中使用。只要我们绑定它到一个名字，我们便可以暂时使用它。也就是说
\acode{name <- getLine}的\acode{name}就是一个普通的字符串。

让我们看以下代码是否合法：

\begin{lstlisting}[language=Haskell]
  nameTag = "Hello, my name is " ++ getLine
\end{lstlisting}

该代码不合法是因为\acode{++}需要两个参数都是同样参数类型的列表，左参数为\acode{String}（或\acode{[Char]}），而\acode{getLine}则是
\acode{IO String}。显然不能将两者合并。要从\acode{IO String}中获取值只能在 I/O action 内部做\acode{name <- getLine}。换言之，
如果要处理 impure 数据，那么就需要再 impure 环境中做。

每个 I/O action 执行都有一个封装后的返回。那么之前的代码同样也可以这么写：

\begin{lstlisting}[language=Haskell]
  main = do
    foo <- putStrLn "Hello, what's your name?"
    name <- getLine
    putStrLn ("Hey " ++ name ++ ", you rock!")
\end{lstlisting}

然而\acode{foo}只会得到一个\acode{()}值，因此这么做并无实际意义。注意最后的\acode{putStrLn}并没有绑定至任何事物。这是因为在一个
\textit{do}代码块中，\acode{最后的 action 不能绑定至一个名称}，如前面两行那样。我们在之后讲解 Monad 的时候会说明为什么。

除了最后一行，\textit{do}代码块中的每一行皆可进行绑定。因此\acode{putStrLn "BLAH"}可以被写成\acode{_ <- putStrLn "BLAH"}，不过
这并没大用，因此不如不写。

初学者可能会这么想：

\begin{lstlisting}[language=Haskell]
  name = getLine
\end{lstlisting}

记住，从 I/O action 中取值，必须将其置于其它 I/O action 内，并使用\acode{<-}将其结果绑定至一个名称。

我们能够在\textit{do}代码块中使用\textit{let}绑定，就如在列表表达式中那样：

\begin{lstlisting}[language=Haskell]
  import Data.Char

  main = do
    putStrLn "What's your first name?"
    firstName <- getLine
    putStrLn "What's your last name?"
    lastName <- getLine

    let bigFirstName = map toUpper firstName
        bigLastName = map toUpper lastName

    putStrLn $ "hey " ++ bigFirstName ++ " " ++ bigLastName ++ ", how are you?"
\end{lstlisting}

注意在\acode{do}代码块中的 I/O actions，同时注意\acode{let}与其名字，缩进在 Haskell 中不会被无视。

接下来是一个持续读取输入行，并在同一行打印翻转后单词的程序。程序会在输入空行后结束：

\begin{lstlisting}[language=Haskell]
  main = do
  line <- getLine
  if null line
    then return ()
    else do
      putStrLn $ reverseWords line
      main

reverseWords :: String -> String
reverseWords = unwords . map reverse . words
\end{lstlisting}

首先我们来看一下\acode{reverseWords}，这个普通的函数假如接受了个字符串\acode{"hey there man"}，那么先调用\acode{words}来参数
一个字的列表，比如\acode{["hey", "there", "man"]}。接着将\acode{reverse}映射至列表，获得\acode{["yeh", "ereht", "nam"]}，
接着再通过\acode{unwords}将列表转换为一个字符串\acode{"yeh ereht nam"}。这里用到了函数组合，如果没有函数组合的话，我们需要这样做
\acode{reverseWords st = unwords (map reverse (words st))}。

我们来看一下在\textit{else}中发生了什么事。由于我们必须要一个 I/O action 在\textit{else}之后，我们使用一个\textit{do}代码块
将两个 I/O action 整合成一个。我们也可以这么写：

\begin{lstlisting}[language=Haskell]
  else (do
    putStrLn $ reverseWords line
    main)
\end{lstlisting}

这样可以更显式的将\textit{do}代码块认做是一个 I/O action，不过就是更丑了点。在\textit{do}代码块中，调用\acode{reverseWords}从
\acode{getLine}而来的行，接着输出至终端。之后就是递归，因为\acode{main}自身就是一个 I/O action。也就意味着又回到了程序一开头。

那么当\acode{null line}为真时呢？我们看到\acode{then return ()}。\textbf{在 Haskell 中的\acode{return}与其他语言的
  \acode{return}完全不同！}它们只是有相同的名字，这会迷惑很多人，但是实际上大相径庭。在命令式语言中，\acode{return}通常结束一个
方法的执行，并将结果返回给调用者。在 Haskell（特别是 I/O action 中），则是利用某个 pure 值制造出 I/O action。所以在 I/O 的情况下，
\acode{return "haha"}的类型是\acode{IO String}。将 pure 值包成 I/O action 有什么意义呢？这是因为一定要 I/O action 来
承载空输入行的情况。因此使用\acode{return ()}做了一个没什么用的 I/O action。

在 I/O \textit{do}代码块中放一个\acode{return}并不会结束执行。下面这个程序就会执行到底：

\begin{lstlisting}[language=Haskell]
  main = do
    return ()
    return "HAHAHA"
    line <- getLine
    return "BLAH BLAH BLAH"
    return 4
    putStrLn line
\end{lstlisting}

所有的这些\acode{return}都用于创造 I/O actions，而其并不做任何事情仅仅是封装一个结构，且该结果被抛弃，因为它们并没有绑定到一个
名字上。\acode{return}可以与\acode{<-}组合在一起用于绑定名称：

\begin{lstlisting}[language=Haskell]
  main = do
    a <- return "hell"
    b <- return "yeah!"
    putStrLn $ a ++ " " ++ b
\end{lstlisting}

可以看到，\acode{return}像是相反的\acode{<-}，前者接受一个值，将其放入盒中，后者接受一个盒（并执行它）然后将值取出来，绑定至一个
名称。不过这么做有点多余，特别是在\textit{do}代码块中，可以使用\textit{let}绑定名称：

\begin{lstlisting}[language=Haskell]
  main = do
    let a = "hell"
        b = "yeah"
    putStrLn $ a ++ " " ++ b
\end{lstlisting}

在 I/O \textit{do}代码块中需要\acode{return}的原因有两个：一个是需要一个什么事都不做的 I/O action，或者是不希望这个\textit{do}
代码块形成的 I/O action 的结果值是这个代码块中的最后一个 I/O action。我们希望有一个不同的结果值，所以用\acode{return}来做一个
I/O action 包装想要的结果放在\textit{do}代码块的最后。

在讲下一节的文件之前，让我们看看有哪些实用的函数可以处理 I/O。

\acodered{putStr}类似于\acode{putStrLn}，前者不会换行：

\begin{lstlisting}[language=Haskell]
  main = do   putStr "Hey, "
              putStr "I'm "
              putStrLn "Andy!"
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell putstr_test.hs
  Hey, I'm Andy!
\end{lstlisting}

\acodered{putChar}接受一个字符：

\begin{lstlisting}[language=Haskell]
  main = do   putChar 't'
              putChar 'e'
              putChar 'h'
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell putchar_test.hs
  teh
\end{lstlisting}

\acodered{print}接受任意实现了\acode{Show}的值（意味着知道如何将该值转换为一个字符串）：

\begin{lstlisting}[language=Haskell]
  main = do   print True
              print 2
              print "haha"
              print 3.2
              print [3,4,3]
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell print_test.hs
  True
  2
  "haha"
  3.2
  [3,4,3]
\end{lstlisting}

\acodered{getChar}从输入中读取一个字符：

\begin{lstlisting}[language=Haskell]
  main = do
    c <- getChar
    if c /= ' '
        then do
            putChar c
            main
        else return ()
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell getchar_test.hs
  hello sir
  hello
\end{lstlisting}

\acodered{when}函数可以在\acode{Control.Monad}中找到（通过\acode{import Control.Monad}）。它在\textit{do}代码块中很有意思，
它像是一个流控声明，但其实它是一个普通函数。其接受一个布尔值以及一个 I/O action，如果改布尔值为真，返回同样的 I/O action；如果为假，
则返回\acode{return ()}，即什么都不做的 I/O action。下面是使用\acode{when}来改写之前的程序：

\begin{lstlisting}[language=Haskell]
  import Control.Monad

  main = do
      c <- getChar
      when (c /= ' ') $ do
          putChar c
          main
\end{lstlisting}

如你所见，它将\acode{if something then do some I/O action else return ()}这样的模式封装了起来。

\acodered{sequence}接受一个列表的 I/O action 并返回一个 I/O action。其类型签名\acode{sequence :: [IO a] -> IO [a]}。例：

\begin{lstlisting}[language=Haskell]
  main = do
    a <- getLine
    b <- getLine
    c <- getLine
    print [a,b,c]
\end{lstlisting}

等同于：

\begin{lstlisting}[language=Haskell]
  main = do
    rs <- sequence [getLine, getLine, getLine]
    print rs
\end{lstlisting}

由于对一个队列映射一个返回 I/O action 的函数，再\acode{sequence}这个动作太常用了。所以\acodered{mapM}与\acodered{mapM_}
被引入了。前者接受一个函数与一个列表，映射函数至列表接着再 sequences；后者一样，只不过丢弃返回值。在不关心 sequenced I/O action
的返回值时，我们使用后者。

\begin{lstlisting}[language=Haskell]
  ghci> mapM print [1,2,3]
  1
  2
  3
  [(),(),()]
  ghci> mapM_ print [1,2,3]
  1
  2
  3
\end{lstlisting}

\acodered{forever}接受一个 I/O action 返回一个 I/O action，无限循环：

\begin{lstlisting}[language=Haskell]
  import Control.Monad
  import Data.Char

  main = forever $ do
      putStr "Give me some input: "
      l <- getLine
      putStrLn $ map toUpper l
\end{lstlisting}

\acodered{forM}类似于\acode{mapM}，不同之处在于参数调转了。为什么有用呢？一些创造性的 lambdas 与\textit{do}的使用，让我们可以
这样做：

\begin{lstlisting}[language=Haskell]
  import Control.Monad

  main = do
      colors <- forM [1,2,3,4] (\a -> do
          putStrLn $ "Which color do you associate with the number " ++ show a ++ "?"
          color <- getLine
          return color)
      putStrLn "The colors that you associate with 1, 2, 3 and 4 are: "
      mapM putStrLn colors
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell form_test.hs
  Which color do you associate with the number 1?
  white
  Which color do you associate with the number 2?
  blue
  Which color do you associate with the number 3?
  red
  Which color do you associate with the number 4?
  orange
  The colors that you associate with 1, 2, 3 and 4 are:
  white
  blue
  red
  orange
\end{lstlisting}

\subsection*{文件与流}

现在让我们来看一下\acodered{getContents}，这是一个从标准输入中读取所有东西直到遇到结束符的 I/O action。其类型为
\acode{getContents :: IO String}。\acode{getContents}是一个 lazy I/O。当使用\acode{foo <- getContents}，它不会
一次性将所有输入读取存储至内存中然后绑定至\acode{foo}。

在我们将一个程序中的输出导向另一个程序时，\acode{getContents}尤其的有用。我们现在来造一个文件：

\begin{lstlisting}[language=Haskell]
  I'm a lil' teapot
  What's with that airplane food, huh?
  It's so small, tasteless
\end{lstlisting}

现在让我们回忆一下之前介绍的\acode{forever}函数。它提示用户输入一行，将输入改为大写，然后再次回到第一步：

\begin{lstlisting}[language=Haskell]
  import Control.Monad
  import Data.Char

  main = forever $ do
      putStr "Give me some input: "
      l <- getLine
      putStrLn $ map toUpper l
\end{lstlisting}

将其保存为\acode{capslocker.sh}并进行编译。通过 unix 的 pipe 将 txt 文件喂给我们的程序：

\begin{lstlisting}[language=Haskell]
  $ ghc --make capslocker
  [1 of 1] Compiling Main             ( capslocker.hs, capslocker.o )
  Linking capslocker ...
  $ cat haiku.txt
  I'm a lil' teapot
  What's with that airplane food, huh?
  It's so small, tasteless
  $ cat haiku.txt | ./capslocker
  I'M A LIL' TEAPOT
  WHAT'S WITH THAT AIRPLANE FOOD, HUH?
  IT'S SO SMALL, TASTELESS
  capslocker <stdin>: hGetLine: end of file
\end{lstlisting}

正如所见，将一个程序（上述案例为\textit{cat}）的输出 pipe 至另一个程序（\textit{capslocker}）作为输入，是由\acode{|}
字符来完成的。

而这里的\acode{forever}就是接受输入并转换后输出。这就是为什么使用\acode{getContents}可以使得程序变得更简洁简短：

\begin{lstlisting}[language=Haskell]
  import Data.Char

  main = do
    contents <- getContents
    putStr $ map toUpper contents
\end{lstlisting}

这里执行\acode{getContents} I/O action 并将其生产的字符串命名为\acode{contents}。接着映射\acode{toUpper}至字符串，
再打印至终端。注意字符串的本质是列表，也是 lazy 的，而\acode{getContents}是 I/O lazy 的，所有在打印出 capslocked 之前，
它不会一次性读取所有内容并存储至内存。实际上会一行一行读取并输出 capslocked，这是因为输出才是真的需要输入数据的时候。

\begin{lstlisting}[language=Haskell]
  $ cat haiku.txt | ./capslocker
  I'M A LIL' TEAPOT
  WHAT'S WITH THAT AIRPLANE FOOD, HUH?
  IT'S SO SMALL, TASTELESS
\end{lstlisting}

如果仅运行\textit{capslockder}并尝试输入呢？

\begin{lstlisting}[language=Haskell]
  $ ./capslocker
  hey ho
  HEY HO
  lets go
  LETS GO
\end{lstlisting}

通过 Ctrl-D 退出。正如你所见，它将我们的输入一行一行的打印出来。当\acode{getContents}的结果绑定至\acode{contents}，
它在内存中并不代表着一个真实字符串，更像是一个 promise，承诺它将最终输出字符串。当映射\acode{toUpper}至\acode{contents}，
则同样是一个承诺，承诺将映射该函数至最终的内容。最后就是当\acode{putStr}发生时，它告知之前的承诺：我需要一个大写的行！
它还未有任何的行，而是告知\acode{contents}：该从命令行中获取一行了。这才是\acode{getContents}实际上从终端中读取并将这一行
交给程序的时候，程序便将这一行用\acode{toUpper}处理并交给\acode{putStr}，\acode{putStr}则打印出它，之后\acode{putStr}
再说：我需要下一行，循环往复，直到读到结束符为止。

下面是一个只打印出少于十个字符行的程序：

\begin{lstlisting}[language=Haskell]
  main = do
    contents <- getContents
    putStr $ shortLinesOnly contents

  shortLinesOnly :: String -> String
  shortLinesOnly input =
    let allLines = lines input
        shortLines = filter (\line -> length line < 10) allLines
        result = unlines shortLines
    in result
\end{lstlisting}

我们尽量让程序的 I/O 部分简短，因为我们的程序本就该接受一些输入并根据输入打印出一些东西。

\acode{shortLinesOnly}函数工作如下：接受一个字符串\acode{"short\\nlooooooooooooooong\\nshort again"}，该字符串
有三行，两行短，中间那行长。运行\acode{lines}函数，转换成\acode{["short", "looooooooooooooong", "short again"]}，
接着绑定至名称\acode{allLines}。该字符串列表被过滤，只留下少于 10 个字符的字符串，即\acode{["short", "short again"]}。
最后，\acode{unlines}将列表转换成一个通过换行符分隔的字符串。

\begin{lstlisting}[language=Haskell]
  i'm short
  so am i
  i am a loooooooooong line!!!
  yeah i'm long so what hahahaha!!!!!!
  short line
  loooooooooooooooooooooooooooong
  short
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ ghc --make shortlinesonly
  [1 of 1] Compiling Main             ( shortlinesonly.hs, shortlinesonly.o )
  Linking shortlinesonly ...
  $ cat shortlines.txt | ./shortlinesonly
  i'm short
  so am i
  short
\end{lstlisting}

我们将内容放至\textit{shortlines.txt}中并 pipe 至编译好的\textit{shortlinesonly}，这样就得到短行了。

从输入中获取字符串，通过一个函数进行转换，然后再输出的这个模式太常见了，因此存在一个名为\acodered{interact}的函数专门用作此模式。

\begin{lstlisting}[language=Haskell]
  main = interact shortLinesOnly

  shortLinesOnly :: String -> String
  shortLinesOnly input =
    let allLines = lines input
        shortLines = filter (\line -> length line < 10) allLines
        result = unlines shortLines
     in result
\end{lstlisting}

当然可以用更少的代码来表达：

\begin{lstlisting}[language=Haskell]
  main = interact $ unlines . filter ((< 10) . length) . lines
\end{lstlisting}

能应用\acode{interact}的情况有几种，一种是从输入 pipe 读取一些内容接着返回一些结果的程序；另一种是用户一行一行的输入，
返回那一行运算后的结果，再接着读取玲一行。

接下来的程序是持续读取一行，接着告诉我们这一行是否为回文。我们可以用\acode{getLine}来读取一行，告诉用户是否为回文，接着再执行
\acode{main}。不过使用\acode{interact}的情况会更加的简单，只需要考虑转换函数。我们的需求中，替换的是每一行输出是否为
\acode{"palindrome"}或者\acode{"not a palindrome"}，也就是说这个函数会转换\acode{"elephant\\nABCBA\\nwhatever"}
成\acode{"not a palindrome\\npalindrome\\nnot a palindrome"}。

\begin{lstlisting}[language=Haskell]
  main = interact respondPalindromes

  respondPalindromes contents =
    unlines
      ( map
          ( \xs ->
              if isPalindrome xs then "palindrome" else "not a palindrome"
          )
          (lines contents)
      )
    where
      isPalindrome xs = xs == reverse xs
\end{lstlisting}

用 point-free 进行改造：

\begin{lstlisting}[language=Haskell]
  respondPalindromes =
  unlines
    . map
      (\xs -> if isPalindrome xs then "palindrome" else "not a palindrome")
    . lines
  where
    isPalindrome xs = xs == reverse xs
\end{lstlisting}

非常的直观。首先它转换\acode{"elephant\\nABCBA\\nwhatever"}为\acode{["elephant", "ABCBA", "whatever"]}，接着映射
一个 lambda 函数，得到\acode{["not a palindrome", "palindrome", "not a palindrome"]}接着\acode{unlines}转为一个
字符串。测试：

\begin{lstlisting}[language=Haskell]
  $ runhaskell palindromes.hs
  hehe
  not a palindrome
  ABCBA
  palindrome
  cookie
  not a palindrome
\end{lstlisting}

尽管我们编写了一个转换输入的大字符串成为另一个大字符串的程序，但其表现的好像是一行一行做的。这是因为 Haskell 是 lazy 的，程序
想要打印出第一行结果，它必须要现有第一行输入，一旦有了第一行输入，那么便打印出第一行结果。这里使用文件终止符来结束程序。

假设我们有这样一个文件：

\begin{lstlisting}
  dogaroo
  radar
  rotor
  madam
\end{lstlisting}

将其保存至\acode{words.txt}。再将其 pipe 至我们的程序：

\begin{lstlisting}[language=Haskell]
  $ cat words.txt | runhaskell palindromes.hs
  not a palindrome
  palindrome
  palindrome
  palindrome
\end{lstlisting}

到现在为止我们遇到的 I/O 都是读取或输出至终端，那么读取和写文件呢？其实我们已经做过这样的事儿了，我们可以想象终端就是一个文件，
而写入和读取它们分别是\acode{stdout}与\acode{stdin}。

首先是一个文件：

\begin{lstlisting}[language=Haskell]
  Hey! Hey! You! You!
  I don't like your girlfriend!
  No way! No way!
  I think you need a new one!
\end{lstlisting}

接着是程序：

\begin{lstlisting}[language=Haskell]
  import System.IO

  main = do
    handle <- openFile "girlfriend.txt" ReadMode
    contents <- hGetContents handle
    putStr contents
    hClose handle
\end{lstlisting}

用程序读取文件：

\begin{lstlisting}[language=Haskell]
  $ runhaskell girlfriend.hs
  Hey! Hey! You! You!
  I don't like your girlfriend!
  No way! No way!
  I think you need a new one!
\end{lstlisting}

我们的程序拥有若干个 I/O actions 被整合在一个\textit{do}代码块中。首先是\acodered{openFile}这个函数，其类型签名为：
\acode{openFile :: FilePath -> IOMode -> IO Handle}，即\acode{openFile}接受一个文件路径，以及一个\acode{IOMode}，
返回一个将会打开文件并将文件关联到句柄的 I/O action。

\acode{FilePath}是\acode{String}的类型别名：

\begin{lstlisting}[language=Haskell]
  type FilePath = String
\end{lstlisting}

而\acode{IOMode}的定义如下：

\begin{lstlisting}[language=Haskell]
  data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode
\end{lstlisting}

\acodered{hGetContents}接受一个\acode{Handle}（这样才能知道从哪里获取内容）并返回一个\acode{IO String} -- 一个包含了
文件内容的 I/O action。该函数类似于\acode{getContents}，不同之处在于\acode{getContents}会自动的从标准输入中读取（也就是
终端），而\acode{hGetContents}接受一个文件句柄，该句柄则是告诉它去哪里读取文件。同样的，\acode{hGetContents}不会一次性
读取文件并存储于内存中，而是按需读取。这样就很酷，因为我们可以将\acode{contents}视作文件的所有内容，且并没有全部加载至内存中。
因此如果有一个很大的文件，使用\acode{hGetContents}并不会打爆内存，而是按需读取。

注意这里用于识别文件的句柄与文件内容的概念上的区别。前者是用于区分文件的依据，如果把整个文件系统想象成一本厚厚的书，每个文件分别
是其中的章节，handle 就像是书签标记了正在阅读（或写入）的章节，而内容则是章节本身。

\acode{putStr contents}将内容打印至标准输出，接着是\acodered{hClose}，其接受一个句柄返回一个 I/O action 关闭文件。

函数\acodered{withFile}，其类型签名为\acode{withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a}，是另外
一种方式，它接受一个文件路径，一个\acode{IOMode}，以及一个接受句柄并返回 I/O action 的函数。这个返回的 I/O action 函数
将会打开文件，处理并关闭文件。

\begin{lstlisting}[language=Haskell]
  main = do
  withFile
    "girlfriend.txt"
    ReadMode
    ( \handle -> do
        contents <- hGetContents handle
        putStr contents
    )
\end{lstlisting}

下面是自己实现的\acode{withFile}：

\begin{lstlisting}[language=Haskell]
  withFile' :: FilePath -> IOMode -> (Handle -> IO a) -> IO a
  withFile' path mode f = do
    handle <- openFile path mode
    result <- f handle
    hClose handle
    return result
\end{lstlisting}

我们知道返回值会是一个 I/O action，因此我们可以由\textit{do}开始。首先打开一个文件，得到一个句柄，接着将\acode{handle}应用至
我们的函数并重新拿到一个处理事情的 I/O action。将此 I/O action 绑定至\acode{result}，关闭句柄接着\acode{return result}。
\acode{return}封装\acode{f}的结果进 I/O action，这样 I/O action 中就包含了\acode{f handle}得到的结果。如果
\acode{f handle}返回的是一个从标准输入读取行，并写到文件然后返回读取的行数的 I/O action，在\acode{withFile'}的情况中，
最后的 I/O action 就会包含读入的行数。

\acode{hGetContents}类似\acode{getContents}，还有\acodered{hGetLine}，\acodered{hPutStr}，\acodered{hPutStrLn}，
\acodered{hGetChar}等等。这些\textit{h}开头的函数都是接受一个句柄作为参数，并操作某指定的文件（而不是标准输出）。

加载文件然后将它们的内容视为字符串这件事非常的常见，因此有三个函数能给我们很大的帮助：

\acodered{readFile}的类型签名是\acode{readFile :: FilePath -> IO String}，它接受一个文件路径，返回一个 I/O action，
该 I/O action 将会读取文件（当然是 lazy 的），并将文件内容作为字符串绑定至某名称：

\begin{lstlisting}[language=Haskell]
  main = do
    contents <- readFile "girlfriend.txt"
    putStr contents
\end{lstlisting}

由于我们拿不到句柄，所以我们无法关闭文件，而 Haskell 的\acode{readFile}在背后帮我们做了这件事。

\acodered{writeFile}的类型签名是\acode{writeFile :: FilePath -> String -> IO ()}，它接受一个文件路径以及需要写入的
字符串，返回一个真实写入文件的 I/O action。如果文件存在，则会清空内容再写入：

\begin{lstlisting}[language=Haskell]
  import System.IO
  import Data.Char

  main = do
    contents <- readFile "girlfriend.txt"
    writeFile "girlfriendcaps.txt" (map toUpper contents)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell girlfriendtocaps.hs
  $ cat girlfriendcaps.txt
  HEY! HEY! YOU! YOU!
  I DON'T LIKE YOUR GIRLFRIEND!
  NO WAY! NO WAY!
  I THINK YOU NEED A NEW ONE!
\end{lstlisting}

\acodered{appendFile}的类型签名与\acode{writeFile}一样，只不过前者在文件存在时会直接在已有内容尾部写入。

\begin{lstlisting}[language=Haskell]
  import System.IO

  main = do
    todoItem <- getLine
    appendFile "todo.txt" $ todoItem ++ "\n"
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  $ runhaskell appendtodo.hs
  Iron the dishes
  $ runhaskell appendtodo.hs
  Dust the dog
  $ runhaskell appendtodo.hs
  Take salad out of the oven
  $ cat todo.txt
  Iron the dishes
  Dust the dog
  Take salad out of the oven
\end{lstlisting}

之前提到过的\acode{contents <- hGetContents handle}并不会将文件一次性读入内存，所以这么写

\begin{lstlisting}[language=Haskell]
  main = do
  withFile
    "something.txt"
    ReadMode
    ( \handle -> do
        contents <- hGetContents handle
        putStr contents
    )
\end{lstlisting}

实际上像是将文件 pipe 到标准输出。就像是可以把列表想象成流那样，文件也可以是流，即每次读一行再打印到终端上。对于文本文件而言，
默认的 buffer 通常以行划分，而对于二进制文件而言，buffer 则跟操作系统有关，即以 chunk 进行划分。

使用\acode{hSetBuffering}来控制 buffer 的行为，该函数接受一个句柄以及一个\acode{BufferMode}，返回一个设置 buffer
行为的 I/O action。\acode{BufferMode}是一个枚举，有值：\acode{NoBuffering}，\acode{LineBuffering}或
\acode{BlockBuffering (Maybe Int)}（\acode{Maybe Int}代表一个 chunk 的字节，如果是\acode{Nothing}则有系统决定）。
\acode{NoBuffering}表示一次读一个字符（频繁访问磁盘，性能很差）。

使用 2048 字节的 chunk 读取：

\begin{lstlisting}[language=Haskell]
  main = do
  withFile
    "something.txt"
    ReadMode
    ( \handle -> do
        hSetBuffering handle $ BlockBuffering (Just 2048)
        contents <- hGetContents handle
        putStr contents
    )
\end{lstlisting}

使用更大的 chunk 读取数据可以减少访问磁盘的次数，特别是通过网络来进行文件访问的时候。

我们也可以使用\acodered{hFlush}，该函数接受一个句柄并返回一个 I/O action，该 I/O action flush 句柄关联文件的缓存。
在使用行缓存的时候，缓存会在每次换行时 flush；而在使用块缓存时，会在读取块完成后 flush；同样也会在关闭句柄时 flush。
而\acode{hFlush}则可以强制进行 flush，之后数据就能被其他程序看见。

以下是一个将 item 加入 todo list 的程序，现在加入移除 item 的功能，这里会用到新函数\acode{System.Directory}以及
\acode{System.IO}：

\begin{lstlisting}[language=Haskell]
  import Data.List
  import System.Directory
  import System.IO

  main = do
    handle <- openFile "todo.txt" ReadMode
    (tempName, tempHandle) <- openTempFile "." "temp"
    contents <- hGetContents handle
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -> show n ++ " - " ++ line) [0 ..] todoTasks
    putStrLn "These are your TO-DO items:"
    putStr $ unlines numberedTasks
    putStrLn "Which one do you want to delete?"
    numberString <- getLine
    let number = read numberString
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile "todo.txt"
    renameFile tempName "todo.txt"
\end{lstlisting}

首先是将\acode{ReadMode}下\acode{openFile}返回的句柄绑定至\acode{handle}。

其次是一个从\acode{System.IO}而来的新函数\acodered{openTempFile}，它接受一个临时路径以及一个临时文件名，打开一个
临时文件。这里使用\acode{"."}作为临时路径，即当前地址；使用\acode{"temp"}作为临时文件名。该函数返回一个 I/O action，
用于创建临时文件，并在 I/O action 中返回一对值：临时文件的名称，以及一个句柄。我们其实可以打开一个名为\textit{todo2.txt}
的普通文件再进行处理，不过使用\acode{openTempFile}是一个更好的实践，这样就不会覆盖任何文件了。

没有使用\acode{getCurrentDirectory}获取当前路径后，再传递给\acode{openTempFile}，这么做是因为\acode{.}在类 unix
系统与 Windows 都代表着当前路径。

接下来是将\acode{todo.txt}的内容绑定至\acode{contents}。再是将字符串转为字符串列表，这时的\acode{todoTasks}就变为
\acode{["Iron the dishes", "Dust the dog", "Take salad out of the oven"]}。使用\acode{zipWith}将零至无穷的
列表与字符串列表结合，返回\acode{["0 - Iron the dishes", "1 - Dust the dog" ...}。再通过\acode{unlines}将字符串
列表转为一个大字符串，打印至终端。这里我们也可以用\acode{mapM putStrLn numberedTasks}。

接下来询问用户想要删除哪个 item，假设用户输入的是 1，那么\acode{numberString}则被绑定上\acode{"1"}这个字符串，需要用
\acode{read}将字符串转换成数字。

接下来就是\acode{Data.List}所提供的\acode{delete}与\acode{!!}函数。\acode{!!}从列表中通过某索引，返回一个元素，
而\acode{delete}删除列表中第一个出现的元素，并返回删除后的列表。这里的\acode{(todoTasks !! number)}返回的是
\acode{"Dust the dog"}。将删除元素后的新列表绑定至\acode{newTodoItems}，接着通过\acode{unlines}合并成一个字符串，
再写入临时文件。这时旧文件并没有改变，而临时文件包含了旧文件中所有函数，除了已删除的那行。

最后就是关闭两个文件的句柄，通过\acodered{removeFile}移除旧文件，再通过\acodered{renameFile}将临时文件命名为
\acode{todo.txt}。

测试：

\begin{lstlisting}[language=Haskell]
  $ runhaskell deletetodo.hs
  These are your TO-DO items:
  0 - Iron the dishes
  1 - Dust the dog
  2 - Take salad out of the oven
  Which one do you want to delete?
  1

  $ cat todo.txt
  Iron the dishes
  Take salad out of the oven

  $ runhaskell deletetodo.hs
  These are your TO-DO items:
  0 - Iron the dishes
  1 - Take salad out of the oven
  Which one do you want to delete?
  0

  $ cat todo.txt
  Take salad out of the oven
\end{lstlisting}

\subsection*{命令行参数}

如果想要写一个在终端运行的程序，处理命令行参数是不可避免的。而 Haskell 的标准库能让我们有效处理参数。

\acode{System.Environment}模块有两个很酷的 I/O actions。第一个是\acodered{getArgs}，其类型是
\acode{getArgs :: IO [String]}，它是一个拿去命令行参数的 I/O actions，并把结果放在字符串列表中；第二个是
\acodered{getProgName}，其类型是\acode{getProgName :: IO String}，它是一个包含了程序名称的 I/O action。

现在来看一下它们是如何工作的：

\begin{lstlisting}[language=Haskell]
  import Data.List
  import System.Environment

  main = do
    args <- getArgs
    progName <- getProgName
    putStrLn "The arguments are:"
    mapM_ putStrLn args
    putStrLn "The program name is:"
    putStrLn progName
\end{lstlisting}

测试：

\begin{lstlisting}[language=Haskell]
  $ ./arg-test first second w00t "multi word arg"
  The arguments are:
  first
  second
  w00t
  multi word arg
  The program name is:
  arg-test
\end{lstlisting}

现在来改造一下\textit{todo}，我们需要：

\begin{enumerate}
  \item 查看任务
  \item 新增任务
  \item 删除任务
\end{enumerate}

首先来构建一个分发关联列表。这些函数的类型将会是\acode{[String] -> IO ()}，它们接受关联列表作为参数，并返回一个
I/O action，其中包含查看、新增以及删除：

\begin{lstlisting}[language=Haskell]
  import Data.List
  import System.Directory
  import System.Environment
  import System.IO

  dispatch :: [(String, [String] -> IO ())]
  dispatch = [("add", add), ("view", view), ("remove", remove)]
\end{lstlisting}

暂未定义\acode{main}，\acode{add}，\acode{view}以及\acode{remove}，那么首先是\acode{main}

\begin{lstlisting}[language=Haskell]
  main = do
    (commands : args) <- getArgs
    let (Just action) = lookup command dispatch
    action args
\end{lstlisting}

首先我们获取参数并将它们绑定至\acode{(command : args)}，这里的模式匹配意为第一个参数绑定至\acode{command}，
其余的参数绑定至\acode{args}。

下一行是在分发列表中查找命令。由于\acode{"add"}指向了\acode{add}，那么得到\acode{Just add}作为返回值。这里再次使用
模式匹配从\acode{Maybe}中提取出我们的函数。那么如果命令不在关联列表中呢？返回的值是\acode{Nothing}，而这里我们不太
需要考虑失败的情况，因此模式匹配失败后程序便抛出异常并退出。

最后是调用\acode{action}函数，并将剩余参数列表作为参数传递进去，并返回一个 I/O action。

棒极了！现在还剩下\acode{add}，\acode{view}以及\acode{remove}需要被实现。首先是\acode{add}：

\begin{lstlisting}[language=Haskell]
  add :: [String] -> IO ()
  add [fileName, todoItem] = appendFile fileName $ todoItem ++ "\n"
\end{lstlisting}

接着是\acode{view}：

\begin{lstlisting}[language=Haskell]
  view :: [String] -> IO ()
  view [fileName] = do
    contents <- readFile fileName
    let todoTasks = lines contents
        numberedTasks = zipWith (\n line -> show n ++ " - " ++ line) [0 ..] todoTasks
    putStr $ unlines numberedTasks
\end{lstlisting}

最后来实现\acode{remove}：

\begin{lstlisting}[language=Haskell]
  remove :: [String] -> IO ()
  remove [fileName, numberString] = do
    handle <- openFile fileName ReadMode
    (tempName, tempHandle) <- openTempFile "." "temp"
    contents <- hGetContents handle
    let number = read numberString
        todoTasks = lines contents
        newTodoItems = delete (todoTasks !! number) todoTasks
    hPutStr tempHandle $ unlines newTodoItems
    hClose handle
    hClose tempHandle
    removeFile fileName
    renameFile tempName fileName
\end{lstlisting}

\subsection*{随机}

在\acode{System.Random}模块中，包含了所有我们所需的随机函数。首先是\acodered{random}，它的类型是
\acode{random :: (RandomGen g, Random a) => g -> (a, g)}。一些新的 typeclasses 出现了！\acodeppl{RandomGen}
typeclass 即可以当做随机的源，而 \acodeppl{Random} typeclass 则是一个接受随机值的类型。

使用\acode{random}函数首先需要知道随机数生成器。\acode{System.Random}模块提懂了一个很酷的名为\acodegrn{StdGen}的类型，
其本身为一个\acode{RandomGen} typeclass 的实例。我们既可以手动创建一个\acode{StdGen}，也可以告诉系统基于一些随机事物
向我们提供一个。

使用\acodered{mkStdGen}函数可以手动创建一个随机数生成器，其类型为\acode{mkStdGen :: Int -> StdGen}。它接受一个整数，
并根据这个整数提供一个随机数生成器。

\begin{lstlisting}[language=Haskell]
  ghci> random (mkStdGen 100)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  <interactive>:1:0:
    Ambiguous type variable `a' in the constraint:
      `Random a' arising from a use of `random' at <interactive>:1:0-20
    Probable fix: add a type signature that fixes these type variable(s)
\end{lstlisting}

为什么会这样？因为\acode{random}函数可以返回一个任意属于\acode{Random} typeclass 类型的值，因此我们需要显式的告诉
Haskell 我们需要的是哪种类型，同样还要告诉随机数生成器返回的随机值类型。

\begin{lstlisting}[language=Haskell]
  ghci> random (mkStdGen 100) :: (Int, StdGen)
  (-1352021624,651872571 1655838864)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> random (mkStdGen 949488) :: (Float, StdGen)
  (0.8938442,1597344447 1655838864)
  ghci> random (mkStdGen 949488) :: (Bool, StdGen)
  (False,1485632275 40692)
  ghci> random (mkStdGen 949488) :: (Integer, StdGen)
  (1691547873,1597344447 1655838864)
\end{lstlisting}

现在让我们模拟一下丢三个硬币（通过执行\acode{cabal install --lib random}安装\acode{System.Random}模块）：

\begin{lstlisting}[language=Haskell]
  import System.Random

  threeCoins :: StdGen -> (Bool, Bool, Bool)
  threeCoins gen =
    let (firstCoin, newGen) = random gen :: (Bool, StdGen)
        (secondCoin, newGen') = random newGen :: (Bool, StdGen)
        (thirdCoin, newGen'') = random newGen' :: (Bool, StdGen)
     in (firstCoin, secondCoin, thirdCoin)
\end{lstlisting}

注意这里与原文不同的地方在于\acode{random}之后显式声明了类型\acode{ :: (Bool, StdGen)}，这是为了粘贴去 GHCI 时避免
\textit{ambiguous type}错误（因为没有类型推导）；仅在文件中则不需要显式声明，因为函数签名可供 Haskell 进行类型推导。

如果想要丢更多的硬币，可以使用\acodered{randoms}函数，其接受一个生成器，返回一个无限列表：

\begin{lstlisting}[language=Haskell]
  ghci> take 5 $ randoms (mkStdGen 11) :: [Int]
  [-1807975507,545074951,-1015194702,-1622477312,-502893664]
  ghci> take 5 $ randoms (mkStdGen 11) :: [Bool]
  [True,True,True,True,False]
  ghci> take 5 $ randoms (mkStdGen 11) :: [Float]
  [7.904789e-2,0.62691015,0.26363158,0.12223756,0.38291094]
\end{lstlisting}

为什么\acode{randoms}不另外多返回一个新的生成器呢？我们自己来实现一下\acode{randoms}函数：

\begin{lstlisting}[language=Haskell]
  randoms' :: (RandomGen g, Random a) => g -> [a]
  randoms' gen = let (value, newGen) = random gen in value : randoms' newGen
\end{lstlisting}

这是一个递归的定义。从现在的生成器中获取到一个随机数以及一个新的生成器，接着构建一个列表，该随机数位于列表头部，而列表其余
部分则是新的生成器所生成的随机数。因为我们可能产生出无限的随机数，因此不能将一个新的生成器返回。

我们可以编写一个函数生成有限流以及新的生成器，像是这样：

\begin{lstlisting}[language=Haskell]
  finiteRandoms :: (RandomGen g, Random a, Num n, Eq n) => n -> g -> ([a], g)
  finiteRandoms 0 gen = ([], gen)
  finiteRandoms n gen =
    let (value, newGen) = random gen
        (restOfList, finalGen) = finiteRandoms (n - 1) newGen
     in (value : restOfList, finalGen)
\end{lstlisting}

又是一个递归定义（与原文不同的是\acode{n}加上了\acode{Eq}约束，不然\acode{finiteRandoms 0 gen = ([], gen)}将会
无法对其进行类型推导）。对于 0 而言，我们仅返回一个空列表以及传入的生成器；对于其他的数而言，返回一个随机数以及一个新的
生成器。首先是头，接着是由新的生成器所生成的\textit{n-1}作为尾，最后返回整个列表以及生成完\textit{n-1}个随机数后的
生成器。测试：

\begin{lstlisting}[language=Bash]
  % runhaskell ownRandom.hs 1 2
  ([-2108421029521926081],StdGen {unStdGen = SMGen 15138674219130149558 10905525725756348111})
\end{lstlisting}

\acodered{randomR}则在给定范围内生成随机数，\acode{randomR :: (RandomGen g, Random a) :: (a, a) -> g -> (a, g)}

\begin{lstlisting}[language=Haskell]
  ghci> randomR (1,6) (mkStdGen 359353)
  (6,1494289578 40692)
  ghci> randomR (1,6) (mkStdGen 35935335)
  (3,1250031057 40692)
\end{lstlisting}

函数\acodered{randomRs}生成随机值的流，无需定义范围：

\begin{lstlisting}[language=Haskell]
  ghci> take 10 $ randomRs ('a','z') (mkStdGen 3) :: [Char]
  "ndkxbvmomg"
\end{lstlisting}

你可能会问这一小节跟 I/O 有什么关系？我们尚未考虑到 I/O，现在的问题就是如果在真实程序中，我们总会返回相同的随机数，这并不好。
这就是为什么\acode{System.Random}提供了\acodered{getStdGen} I/O action，其类型为\acode{IO StdGen}。当程序启动后，
程序会向系统要一个随机数生成器，并存储其为全局生成器。当将\acode{getStdGen}绑定至某变量时，它会去获取这个全局随机数生成器。

以下是一个简单的生成随机字符串的程序：

\begin{lstlisting}[language=Haskell]
  import System.Random

  main = do
    gen <- getStdGen
    putStr $ take 20 $ randomRs ('a', 'z') gen
\end{lstlisting}

\begin{lstlisting}[language=Bash]
  % runhaskell randomString.hs
  rfbhrwkgvbqedgvaxvxz
  % runhaskell randomString.hs
  fgibjkxmivziojyyrcoa
  % runhaskell randomString.hs
  puohzegfvvswyrqrsdbe
\end{lstlisting}

不过要小心，执行多次\acode{getStdGen}会向系统请求同一个全局生成器，例如：

\begin{lstlisting}[language=Haskell]
  import System.Random

  main = do
    gen <- getStdGen
    putStrLn $ take 20 (randomRs ('a','z') gen)
    gen2 <- getStdGen
    putStr $ take 20 (randomRs ('a','z') gen2)
\end{lstlisting}

会打印出同样的字符串两次！这里的解决方案是设置一个无限流，每次获取 20 个字符：

\begin{lstlisting}[language=Haskell]
  main = do
    gen <- getStdGen
    let randomChars = randomRs ('a', 'z') gen
        (first20, rest) = splitAt 20 randomChars
        (second20, _) = splitAt 20 rest
    putStrLn first20
    putStr second20
\end{lstlisting}

另一个方法就是使用\acodered{newStdGen} action：

\begin{lstlisting}[language=Haskell]
  main = do
    gen <- getStdGen
    putStrLn $ take 20 $ randomRs ('a', 'z') gen
    gen' <- newStdGen
    putStrLn $ take 20 $ randomRs ('a', 'z') gen'
\end{lstlisting}

下面是一个猜数字的小程序：

\begin{lstlisting}[language=Haskell]
  -- import Control.Monad (when)
  import Control.Monad (unless)
  import System.Random

  main = do
    gen <- getStdGen
    askForNumber gen

  askForNumber :: StdGen -> IO ()
  askForNumber gen = do
    let (randNumber, newGen) = randomR (1, 10) gen :: (Int, StdGen)
    putStr "Which number in the range from 1 to 10 am I thinking of? "
    numberString <- getLine
    -- when (not $ null numberString) $ do
    unless (null numberString) $ do
      let number = read numberString
      if randNumber == number
        then putStrLn "You are correct!"
        else putStrLn $ "Sorry, it was" ++ show randNumber
      askForNumber newGen
\end{lstlisting}

\begin{anote}
  如果用户输入了\acode{read}读不了的东西（例如\acode{"haha"}），程序会立刻崩溃。如果使用\acodered{reads}遇到
  错误输入是则会返回一个空列表；如果是正确输入则会返回一个包含了一个二元元组的单元素列表，
\end{anote}

这里\acode{when}用于查看用户输入的字符串是否为空，如果是则一个空 I/O action 的\acode{return ()}被执行，程序结束。

另一种做法，用\acode{main}做递归（与原文不同，使用了上述建议的\acode{reads}，并默认 0 避免错误输入导致的崩溃）：

\begin{lstlisting}[language=Haskell]
  main = do
  gen <- getStdGen
  let (randNumber, _) = randomR (1, 10) gen :: (Int, StdGen)
  putStr "Which number in the range from 1 to 10 am I thinking of? "
  numberString <- getLine
  unless (null numberString) $ do
    let number = case reads numberString of
          [(num, _)] -> num
          _ -> 0
    if randNumber == number
      then putStrLn "You are correct!"
      else putStrLn $ "Sorry, it was " ++ show randNumber
    newStdGen
    main
\end{lstlisting}

\subsection*{字节串}

将文件处理成字符串有一个缺陷：它很慢。如我们所知，\acode{String}其实就是\acode{[Char]}，\acode{Char}并没有一个
固定的大小，因为需要若干字节才能表示一个字符。另外就是列表是 lazy 的，如果有一个\acode{[1,2,3,4]}列表，它只会在有
必要时才会进行计算，也就是说整个列表其实是一个 promise 的列表。当列表的第一个元素被强制计算（假设是打印），列表的
剩余部分\acode{2:3:4:[]}仍然是一个 promise 列表。

大多数时候这种负担并没什么，但是读取大文件并进行操作时就不一样了。这就是为什么 Haskell 有\textbf{bytestrings}，
其元素是一个字节（8 bits），而且与字符串相比，它们的 lazy 性质也不一样。

Bytestrings 有两种模式：strict 以及 lazy。Strict 模式位于\acode{Data.ByteString}模块，没有涉及 promise；
该模式的好处就是更少的费用开支，而坏处就是一次性加载至内存会导致内存占用过高。Lazy 模式\acode{Data.ByteString.Lazy}
则是另一种做法，它们被存储于 chunks 中（不是 Thunk），每个 chunk 的大小都是 64k。

使用它们需要 qualified 导入：

\begin{lstlisting}[language=Haskell]
  import Data.ByteString.Lazy qualified as B
  import Data.ByteString qualified as S
\end{lstlisting}

\acode{B}拥有 lazy bytestring 的类型与函数，而\acode{S}则是 strict。大多数时候我们用的是 lazy 的版本。

\acodered{pack}函数的类型签名是\acode{pack :: [Word8] -> ByteString}，意为接受一个\acode{Word8}类型的字节
列表，并返回一个\acode{ByteString}。可以想象成接受一个 lazy 的列表，使其变成没那么 lazy，也就是对于 64K lazy。

那么\acode{Word8}类型又是什么？它类似于\acode{Int}，只是范围较小，介于 0-255 之间。它代表一个 8-bit 的数字，就像
\acode{Int}一样，它是属于\acode{Num}这个 typeclass。例如我们知道\acode{5}是多态的，它能够表现成任何数值类型，
\acode{Word8}也能这样表现。

\begin{lstlisting}[language=Haskell]
  ghci> B.pack [99,97,110]
  Chunk "can" Empty
  ghci> B.pack [98..120]
  Chunk "bcdefghijklmnopqrstuvwx" Empty
\end{lstlisting}

如你所见，通常无需担心\acode{Word8}，因为类型系统可以使数值选择类型。如果使用一个大的数值，例如\acode{336}作为
\acode{Word8}，它会包装成\acode{80}。

我们把一部分数值打包成\acode{ByteString}，使它们可以塞进一个 chunk 内，而\acode{Empty}类似于\acode{[]}那样的
空列表用作于空的\acode{ByteString}。

\acodered{unpack}则是\acode{pack}的反函数，即接受一个 bytestring 将其转换成字节列表。

\acodered{fromChunks}接受一个 strict 模式的 bytestrings，将其转换成 lazy 模式；\acodered{toChunks}则相反。

\begin{lstlisting}[language=Haskell]
  ghci> B.fromChunks [S.pack [40,41,42], S.pack [43,44,45], S.pack [46,47,48]]
  Chunk "()*" (Chunk "+,-" (Chunk "./0" Empty))
\end{lstlisting}

这对于很多小的 strict bytestring 且不想将它们 join 起来（占用内存），是个不错的做法。

\acode{cons}是\acode{:}的 bytestring 版本，它接受一个字节以及一个 bytestring，将前者放置在后者头部。它是 lazy 的，
因此即使 bytestring 的第一个 chunk 不是满的，它也会添加一个 chunk。这也是为什么在插入很多字节的时候最好用 strict 的
\acode{cons'}。

\begin{lstlisting}[language=Haskell]
  ghci> B.cons 85 $ B.pack [80,81,82,84]
  Chunk "U" (Chunk "PQRT" Empty)
  ghci> B.cons' 85 $ B.pack [80,81,82,84]
  Chunk "UPQRT" Empty
  ghci> foldr B.cons B.empty [50..60]
  Chunk "2" (Chunk "3" (Chunk "4" (Chunk "5" (Chunk "6" (Chunk "7" (Chunk "8" (Chunk "9" (Chunk ":" (Chunk ";" (Chunk "<" Empty))))))))))
  ghci> foldr B.cons' B.empty [50..60]
  Chunk "23456789:;<" Empty
\end{lstlisting}

如你所见\acode{empty}创建一个空的 bytestring。可以看出来\acode{cons}与\acode{cons'}之间的区别了吗？通过\acode{foldr}
我们从一个空的 bytestring 开始，接着从右开始遍历数值列表，将每个数值放置在 bytestring 的头部。使用\acode{cons}时，则是
每个字节都作为一个 chunk，这显然不符合初衷。

bytestring 有一堆与\acode{Data.List}中类似的函数，其中包括\acode{head}，\acode{tail}，\acode{init}，\acode{null}，
\acode{length}，\acode{map}，\acode{reverse}，\acode{foldl}，\acode{foldr}，\acode{concat}，\acode{taskWhile}，
\acode{filter}等等。

同样也有表现的跟\acode{System.IO}中一样的函数，只不过是\acode{Strings}被替换成了\acode{ByteString}。比如
\acode{System.IO}中的\acode{readFile}，其类型为\acode{readFile :: FilePath -> IO String}，而 bytestring 模块中的
\acodered{readFile}其类型为\acode{readFile :: FilePath -> IO ByteString}。注意这里使用的是 strict bytestring，
读取文件时会一次性读取至内存！如果是 lazy 模式，则会读取成 chunks。

现在让我们写一个简单的程序，从命令行中接受两个文件名，将第一个文件中的内容拷贝至第二个。注意\acode{System.Directory}有一个
名为\acode{copyFile}的函数，不过这里我们还是来实现一下：

\begin{lstlisting}[language=Haskell]
  import Data.ByteString.Lazy qualified as B
  import System.Environment

  main = do
    (fileName1 : fileName2 : _) <- getArgs
    copyFile fileName1 fileName2

  copyFile :: FilePath -> FilePath -> IO ()
  copyFile source dest = do
    contents <- B.readFile source
    B.writeFile dest contents
\end{lstlisting}

\begin{lstlisting}[language=Bash]
  runhaskell byteStringCopy.hs todo.txt ../../todo.txt
\end{lstlisting}

当需要更好的性能来读取数据时，可以尝试用 bytestring。

\subsection*{异常}

尽管有表达力强的类型来帮助失败的情景（\acode{Maybe}，\acode{Either}等），Haskell 仍然支持 exception，因为
在 I/O 的场景下 exception 是比较合理的。在处理 I/O 的时候会有很多奇怪的事情发生，环境并不能被信赖。比如说打开文件，
文件有可能被锁，也有可能被移除了，甚至是硬盘都没了，因此直接跳到处理错误的代码是很合理的。

我们知道 I/O 代码抛出异常是合理的，那么 pure 代码呢？当然是也可以抛出异常。想一想\acode{div}与\acode{head}函数，
它们的类型分别是\acode{(Integral a) => a -> a -> a}与\acode{[a] -> a}。\acode{Maybe}或\acode{Either}
并没有在它们的返回类型中。

\begin{lstlisting}[language=Haskell]
  ghci> 4 `div` 0
  *** Exception: divide by zero
  ghci> head []
  *** Exception: Prelude.head: empty list
\end{lstlisting}

Pure 代码可以抛出异常，但是它们只能在我们代码的 I/O 部分（也就是\acode{main}里的\acode{do}代码块）中被捕获。
这是因为 pure 代码中你不知道什么东西会在什么时候被计算。因为 lazy 特性的原因，程序没有一个特定的执行顺序，但是
I/O 代码却有。

I/O Exception 是我们在\acode{main}中与外界沟通失败而抛出的异常。下面是一个接受命令行参数，打开所指定的文件名，
并计算有多少行的代码：

\begin{lstlisting}[language=Haskell]
  import System.Environment
  import System.IO

  main = do
    (fileName : _) <- getArgs
    contents <- readFile fileName
    let l = show . length . lines
    putStrLn $ "This file has " ++ contents ++ " lines!"
\end{lstlisting}

当读取一个不存在的文件时：

\begin{lstlisting}[language=Bash]
  % runhaskell linecount.hs xx.txt
  linecount.hs: xx.txt: openFile: does not exist (No such file or directory)
\end{lstlisting}

改造一下，使用\acode{System.Directory}中的\acodered{doesFileExist}函数来确保文件是否存在：

\begin{lstlisting}[language=Haskell]
  import System.Directory
  import System.Environment
  import System.IO

  main = do
    (fileName : _) <- getArgs
    fileExists <- doesFileExist fileName
    if fileExists
      then do
        contents <- readFile fileName
        let l = show . length . lines
        putStrLn $ "The file has " ++ l contents ++ " lines!"
      else do
        putStrLn "The file doesn't exists!"
\end{lstlisting}

代码中的\acode{fileExists <- doesFileExist fileName}是因为\acode{doesFileExist}的类型是
\acode{doesFileExist :: FilePath -> IO Bool}，意味着返回一个 I/O action 其内容为布尔值，因此不能直接用于
\textit{if}表达式中。

\acode{System.IO.Error}模块中的\acodered{catch}函数可以用于处理异常。其类型是
\acode{catch :: IO a -> (IOError -> IO a) -> IO a}，接受两个参数：第一个参数是一个 I/O action，例如尝试
打开文件的 I/O action；第二个参数是一个句柄，如果 I/O action 抛出了 I/O 异常，那么该异常会被传递至该句柄，然后
再决定如何处理。最终的返回值也是一个 I/O action，也就是说整个过程中要么如预期那样完成第一个参数的 I/O action，
要么就是句柄处理后的结果。

句柄接受一个\acode{IOError}类型的值，它代表的是一个 I/O 异常已经发生了，它也带有一些异常信息。至于该类型在语言中
如何被实现则是要看编译器。这就意味着我们没法用模式匹配的方式来查看\acode{IOError}，类似于不能用模式匹配来查看
\acode{IO something}的内容那样。但是我们能用一些子句来查看它们。

以下是一个使用了\acode{catch}的程序：

\begin{lstlisting}[language=Haskell]
  import Control.Exception
  import System.Environment

  main = toTry `catch` handler

  toTry :: IO ()
  toTry = do
    (fileName : _) <- getArgs
    contents <- readFile fileName
    let l = show . length . lines
    putStrLn $ "The file has " ++ l contents ++ " lines!"

  handler :: IOError -> IO ()
  handler e = putStrLn "Whoops, had some trouble!"
\end{lstlisting}

与原文不同的是\acode{catch}位于\acode{Control.Exception}模块中。测试

\begin{lstlisting}[language=Bash]
  % runhaskell linecount2.hs xx.txt
  Whoops, had some trouble!
  % runhaskell linecount2.hs todo.txt
  The file has 3 lines!
\end{lstlisting}

下面代码细分了异常的处理：

\begin{lstlisting}[language=Haskell]
  import Control.Exception
  import System.Environment
  import System.IO.Error (isDoesNotExistError)

  main = toTry `catch` handler

  toTry :: IO ()
  toTry = do
    (fileName : _) <- getArgs
    contents <- readFile fileName
    let l = show . length . lines
    putStrLn $ "The file has " ++ l contents ++ " lines!"

  handler :: IOError -> IO ()
  handler e
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"
    | otherwise = ioError e
\end{lstlisting}

这里使用了\acode{System.IO.Error}模块中的\acodered{isDoesNotExistError}以及\acodered{ioError}。
前者是一个运行在\acode{ioError}之上的子句，其类型为\acode{isDoesNotExistError :: IOError -> Bool}。
这里使用了守护，但实际上也可以用\textit{if else}。如果异常不是文件不存在而导致的，那么就用\acode{ioError}
将异常重新抛出。

以下是一些常用的子句：

\begin{enumerate}
  \item \acodered{isAlreadyExistsError}
  \item \acodered{isDoesNotExistError}
  \item \acodered{isFullError}
  \item \acodered{isEOFError}
  \item \acodered{isIllegalOperation}
  \item \acodered{isPermissionError}
  \item \acodered{isUserError}
\end{enumerate}

最后一个\acode{isUserError}时在使用\acodered{userError}函数时的返回，意为我们的代码中抛出的异常。例如
\acode{ioError \$ userError "remote computer unplugged!"}，尽管用\acode{Either}或\acode{Maybe}
来表示可能的错误会比自己抛出异常更好。

所以可以编写这样的一个句柄：

\begin{lstlisting}[language=Haskell]
  handler :: IOError -> IO ()
  handler e
    | isDoesNotExistError e = putStrLn "The file doesn't exist!"
    | isFullError e = freeSomeSpace
    | isIllegalOperation e = notifyCops
    | otherwise = ioError e
\end{lstlisting}

其中\acode{freeSomeSpace}与\acode{notifyCops}是用户自定义的 I/O action。如果异常不匹配，记得要将异常
重新抛出，不然程序还是会崩溃。

\acode{System.IO.Error}还提供了一些能够询问异常性质的函数，比如说是哪些句柄导致的错误，或者是哪些文件名造成的错误。
这些函数都是\acode{ioe}开头，详见
\href{https://downloads.haskell.org/~ghc/6.10.1/docs/html/libraries/base/System-IO-Error.html#3}{此处}.
这里使用\acodered{ioeGetFileName}函数可以知道文件路径，其类型为
\acode{ioeGetFileName :: IOError -> Maybe FilePath}。修改一下程序：

\begin{lstlisting}[language=Haskell]
  import Control.Exception
  import System.Environment
  import System.IO.Error

  main = toTry `catch` handler

  toTry :: IO ()
  toTry = do
    (fileName : _) <- getArgs
    contents <- readFile fileName
    let l = show . length . lines
    putStrLn $ "The file has " ++ l contents ++ " lines!"

  handler :: IOError -> IO ()
  handler e
    | isDoesNotExistError e =
        case ioeGetFileName e of
          Just path -> putStrLn $ "Whoops! File does not exist at: " ++ path
          Nothing -> putStrLn "Whoops! File does not exist at unknown location!"
    | otherwise = ioError e
\end{lstlisting}

如果不想只用一个\acode{catch}来捕获 I/O 部分中的所有异常，那么可以在特定的地方用\acode{catch}来进行捕获，
或者也可以使用不同的句柄：

\begin{lstlisting}[language=Haskell]
  main = do toTry `catch` handler1
    thenTryThis `catch` handler2
    launchRockets
\end{lstlisting}

\end{document}
