\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{模式匹配}

一个简单案例：

\begin{lstlisting}[language=Haskell]
  sayMe :: (Integral a) => a -> String
  sayMe 1 = "One!"
  sayMe 2 = "Two!"
  sayMe 3 = "Three!"
  sayMe 4 = "Four!"
  sayMe 5 = "Five!"
  sayMe x = "Not between 1 and 5"
\end{lstlisting}

一个递归案例：

\begin{lstlisting}[language=Haskell]
  factorial :: (Integral a) => a ->
  factorial 0 = 1
  factorial n = n * factorial (n - 1)
\end{lstlisting}

模式匹配也可以失败：

\begin{lstlisting}[language=Haskell]
  charName :: Char -> String
  charName 'a' = "Albert"
  charName 'b' = "Broseph"
  charName 'c' = "Cecil"
\end{lstlisting}

当输入并不是期望时：

\begin{lstlisting}[language=Haskell]
  ghci> charName 'a'
  "Albert"
  ghci> charName 'b'
  "Broseph"
  ghci> charName 'h'
  "*** Exception: tut.hs:(53,0)-(55,21): Non-exhaustive patterns in function charName
\end{lstlisting}

即出现了非穷尽的匹配，因此我们总是需要捕获所有模式。

模式匹配也可用作于元组：

\begin{lstlisting}[language=Haskell]
  addVectors :: (Num a) => (a, a) -> (a, a) -> (a, a)
  addVectors a b = (fst a + fst b, snd a + snd b)
\end{lstlisting}

模式匹配也可作用于列表表达式：

\begin{lstlisting}[language=Haskell]
  ghci> let xs = [(1,3), (4,3), (2,4), (5,3), (5,6), (3,1)]
  ghci> [a+b | (a,b) <- xs]
  [4,7,6,8,11,4]
\end{lstlisting}

\begin{anote}
  \acode{x:xs} 模式的使用很常见，特别是递归函数。但是包含\acode{:}的模式只匹配长度为 1 或更多的数组。
\end{anote}

如果希望获取前三个元素以及数组剩余元素，那么可以使用 \acode{x:y:z:zs}，那么这样仅匹配有三个或以上的元素的数组。

其它案例：

\begin{lstlisting}[language=Haskell]
  tell :: (Show a) => [a] -> String
  tell [] = "The list is empty"
  tell (x:[]) = "The list has one element: " ++ show x
  tell (x:y:[]) = "The list has two elements: " ++ show x ++ " and " ++ show y
  tell (x:y:_) = "This list is long. The first two elements are: " ++ show x ++ " and " ++ show y
\end{lstlisting}

该函数是安全的，因为它考虑到了空数组，以及若干元素数组的情况。

之前通过列表表达式编写了 \acode{length} 函数，现在可以通过模式匹配再加上递归的方式实现一遍：

\begin{lstlisting}[language=Haskell]
  length' :: (Num b) => [a] -> b
  length' [] = 0
  length' (_ : xs) = 1 + length' xs
\end{lstlisting}

接下来是实现 \acode{sum}：

\begin{lstlisting}[language=Haskell]
  sum' :: (Num a) => [a] -> a
  sum' [] = 0
  sum' (x:xs) = x + sum' xs
\end{lstlisting}

同样还有一种被称为\textit{as 模式}的，即在模式前添加名称以及\acode{@}符号，例如\acode{xs@(x:y:ys)}，该模式将匹配
\acode{x:y:ys}，同时用户可以轻易的通过\acode{xs}来获取整个数组，而无需重复使用\acode{x:y:ys}进行表达：

\begin{lstlisting}[language=Haskell]
  capital :: String -> String
  capital "" = "Empty string, whoops!"
  capital all@(x : xs) = "The first letter of " ++ all ++ " is " ++ [x]
\end{lstlisting}

最后，用户在模式匹配中不能使用 \acode{++} 符号。

% TODO

\end{document}
