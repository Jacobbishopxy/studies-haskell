\documentclass[./main.tex]{subfiles}

\begin{document}

由纯粹性，高阶函数，参数化代数数据类型，以及 typeclasses 所构成的 Haskell，相比于其他语言，允许我们实现更高等级的多态。
我们无需考虑类型是如何属于一个类型阶级系统的，而是由合理的 typeclasses 如何连接它们的。

Typesclasses 是开放的，这就意味着我们可以定义自己的数据类型。

\subsection*{函子 Functors 复习}

回忆：Functors 可以用于映射至比如列表，\acode{Maybe}，树，等等。在 Haskell 中它们被 \acode{Functor} typeclass
所描述，其仅有一个名为 \acode{fmap} 的 typeclass 方法，该方法的类型是\acode{fmap :: (a -> b) -> f a -> f b}。
它表示：给我一个接受一个\acode{a}并返回一个\acode{b}的函数，以及给我一个（或多个）\acode{a}的容器，那么我将给你一个
（或多个）\acode{b}的容器。有点像是将函数应用至容器中的元素。

如果一个类型构造函数是\acode{Functor}的实例，那么它的 kind 就必须是\acode{* -> *}，这代表它必须刚好接受一个类型作为
类型参数。像是\acode{Maybe}是 Functor 的实例，它接受一个类型参数，如\acode{Maybe Int}或\acode{Maybe String}。
如果一个类型构造函数接受两个参数，比如\acode{Either}，我们不能这样\acode{instance Functor Either where}，不过
可以这样\acode{instance Functor (Either a) where}，那么\acode{fmap}作为\acode{Either a}的类型前面就可以这样
\acode{fmap :: (b -> c) -> Either a b -> Either a c}。

现在看看\acode{IO}是怎么样的一个\acode{Functor}实例。当我们\acode{fmap}一个函数在一个 I/O action 上，我们希望
拿回的 I/O action 是已经被映射过的：

\begin{lstlisting}[language=Haskell]
  instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)
\end{lstlisting}

对一个 I/O action 映射的结果仍然是一个 I/O action，因此需要用\textit{do}语法来把两个 I/O action 粘合成一个。

\begin{lstlisting}[language=Haskell]
  main = do
    line <- getLine
    let line' = reverse line
    putStrLn $ "You said " ++ line' ++ " backwards!"
    putStrLn $ "Yes, you really said " ++ line' ++ " backwards!"
\end{lstlisting}

用\acode{fmap}改写：

\begin{lstlisting}[language=Haskell]
  main = do
    line <- fmap reverse getLine
    putStrLn $ "You said " ++ line ++ " backwards!"
    putStrLn $ "Yes, you really said " ++ line ++ " backwards!"
\end{lstlisting}

如果将\acode{fmap}应用至\acode{IO}，其类型便为\acode{fmap :: (a -> b) -> IO a -> IO b}。

如果将一个 I/O action 绑定到一个名称上时，仅仅想要应用一个函数，那么可以考虑使用\acode{fmap}，因为这看起来更简洁。如果
想要应用多个函数，那么可以声明自己的函数，将其变为 lambda 或者使用函数组合：

\begin{lstlisting}[language=Haskell]
  import Data.Char
  import Data.List

  main = do
    line <- fmap (intersperse '-' . reverse . map toUpper) getLine
    putStrLn line
\end{lstlisting}

\begin{lstlisting}[language=Bash]
  $ runhaskell fmappingIO.hs
  hello there
  E-R-E-H-T- -O-L-L-E-H
\end{lstlisting}

\acode{intersperse '-' . reverse . map toUpper}这个函数接受一个字符串，映射\acode{toUpper}后的返回值再应用
\acode{reverse}，最后应用\acode{intersperes '-'}。

另一个我们已经接触过的\acode{Functor}实例就是\acode{(->) r}。函数类型\acode{r -> a}可以被重写为\acode{(->) r a}，
就像是\acode{2 + 3}可以表达为\acode{(+) 2 3}。从另一个角度来看\acode{(->) r a}，它其实就是一个接受两个类型参数的
构造函数，例如\acode{Either}。但是记住\acode{Functor}只能接受一个参数类型，这也是为什么\acode{(->)}不是
\acode{Functor}的一个实例，但是\acode{(->) r}则是。在\acode{Control.Monad.Instances}有更多的细节：

\begin{lstlisting}[language=Haskell]
  instance Functor ((->) r) where
    fmap f g = (\x -> f (g x))
\end{lstlisting}

首先来看看\acode{fmap}的类型\acode{fmap :: (a -> b) -> f a -> f b}。我们把所有的\acode{f}替换成\acode{(->) r}，
那么就是\acode{fmap :: (a -> b) -> ((->) r a) -> ((->) r b)}，然后将\acode{(->) r a}与\acode{(->) r b}换成
\acode{r -> a}与\acode{r -> b}，则得到\acode{fmap :: (a -> b) -> (r -> a) -> (r -> b)}。

将一个函数映射至另一个函数可以生产出一个函数，就像是映射一个函数在\acode{Maybe}上生产出一个\acode{Maybe}，映射一个函数在
一个列表上能生成出一个列表。那么上述的类型实例说的是什么呢？它接受一个\acode{a}至\acode{b}的函数，以及一个\acode{r}至
\acode{a}的函数，返回一个\acode{r}至\acode{b}的函数。这就是一个函数组合！另一种实例的写法：

\begin{lstlisting}[language=Haskell]
  instance Functor ((->) r) where
    fmap = (.)
\end{lstlisting}

很明显就是将\acode{fmap}当函数组合在用。在 GHCI 中使用\acode{:m + Control.Monad.Instances}加载模块，测试：

\begin{lstlisting}[language=Haskell]
  ghci> :t fmap (*3) (+100)
  fmap (*3) (+100) :: (Num a) => a -> a
  ghci> fmap (*3) (+100) 1
  303
  ghci> (*3) `fmap` (+100) $ 1
  303
  ghci> (*3) . (+100) $ 1
  303
  ghci> fmap (show . (*3)) (*100) 1
  "300"
\end{lstlisting}

\acode{fmap}等同于函数组合这件事儿对我们而言并不是很实用，但是这至少是一个有趣的观点。Functors 其实比较像是 computation，
函数被映射到另一个计算会经由那个函数映射过后的计算。

在看一下\acode{fmap}的类型\acode{fmap :: (a -> b) -> f a -> f b}，那么为了简洁不写\acode{(Functor f) =>}部分。
在学柯里化的时候提到过 Haskell 的函数实际上只接受一个参数，即\acode{a -> b -> c}，如果调用时少写一个参数，那么返回的函数
就需要接受剩下的参数。所以\acode{a -> b -> c}可以写成\acode{a -> (b -> c)}，这样柯里化更加明显。

同样的如果写成\acode{fmap :: (a -> b) -> (f a -> f b)}，我们可以认为\acode{fmap}不是一个接受函数与函子并返回一个函子的
函数，而是一个接受函数并返回一个新函数的函数，而这个返回的新函数接受一个函子作为参数，并返回一个函子。接受一个\acode{a -> b}
函数并返回一个\acode{f a -> f b}函数，这被称为\textit{提升 lifting}一个函数。我们用 GHCI 的\acode{:t}命令检查：

\begin{lstlisting}[language=Haskell]
  ghci> :t fmap (*2)
  fmap (*2) :: (Num a, Functor f) => f a -> f a
  ghci> :t fmap (replicate 3)
  fmap (replicate 3) :: (Functor f) => f a -> f [a]
\end{lstlisting}

表达式\acode{fmap (*2)}是一个接受基于数值的函子\acode{f}并返回一个数值函子的函数。函子可以是一个列表一个\acode{Maybe}，
一个\acode{Either String}，等等。表达式\acode{fmap (replicate 3)}则接受任意类型的函子并返回一个该类型列表函子。

\begin{anote}
  当我们说\textit{一个基于数值的函子 a functor over numbers}时，你可以认为是\textit{一个拥有数值的函子 a functor that
    has numbers in it}。前者的描述更加精准，后者则更容易理解。
\end{anote}

当使用部分应用绑定至一个名称时，比如说\acode{fmap (++"!")}，在 GHCI 更加的显而易见。

\begin{lstlisting}[language=Haskell]
  ghci> :t fmap (++"!")
  fmap (++"!") :: Functor f => f [Char] -> f [Char]
\end{lstlisting}

可以把\acode{fmap}想像成一个函数，接受另一个函数与一个函子，然后将接受的函数对函子中每个元素做映射；也可以想象成是一个函数，
接受一个函数并将其提升 lift 到可以在函子上操作。这两种想法都是正确的，且在 Haskell 中是等价的。

接下来我们开始学习\textbf{函子定律 functor laws}。为了让某物成为一个函子，它必须满足某些条件。所有的函子都要求具有某些性质，
它们必须是能被映射的，对它们调用\acode{fmap}应该要用一个函数映射至每一个元素，且没有额外的操作。这些行为都被函子定律所描述。
对于\acode{Functor}的实例而言，总共有两条定律该被遵守。不过它们不会在 Haskell 中自动被检查，需要用户自己确认这些条件。

\textbf{函子第一定律是如果将\acode{id}函数映射至该函子，得到的函子必须是原来的函子}。用代码表示即\acodegrn{fmap id = id}，
换言之如果\acode{fmap id}至一个函子，返回的结果跟直接\acode{id}至该函子是一样的。\acode{id}是一个 identity 函数，
可以写作是\acode{\\x -> x}。

\begin{lstlisting}[language=Haskell]
  ghci> fmap id (Just 3)
  Just 3
  ghci> id (Just 3)
  Just 3
  ghci> fmap id [1..5]
  [1,2,3,4,5]
  ghci> id [1..5]
  [1,2,3,4,5]
  ghci> fmap id []
  []
  ghci> fmap id Nothing
  Nothing
\end{lstlisting}

看一下\acode{Maybe}的\acode{fmap}的实现，可以知道第一定律是如何遵守的：

\begin{lstlisting}[language=Haskell]
  instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
\end{lstlisting}

\textbf{函子第二定律是将两个函数合成并将结果映射至一个函子的结果，与现将第一个函数映射函子再将第二个函子映射至该函子的结果是一样的}。
即\acodegrn{fmap (f . g) = fmap f . fmap g}，或者另一种写法，对于任何一个函子\acode{F}，满足\acodegrn{fmap (f . g) F =
  fmap f (fmap g F)}。

\subsection*{高级函子 Applicative functors}

本节开始学习高级函子，在 Haskell 中由 \acode{Applicative} typeclass 描述，可在\acode{Control.Applicative}模块中找到。

函数在 Haskell 中默认是柯里化的，这就意味着一个函数看起来接受若干参数实际上是接受一个参数并返回一个函数再接受一个参数，以此类推。
如果一个函数的类型是\acode{a -> b -> c}，那么通常会说它接受两个参数并返回一个\acode{c}。这就是为什么可以将\acode{f x y}
表达为\acode{(f x) y}。这个机制允许我们部分应用函数，仅需调用少一些的参数，返回的函数可以被传递至另一个函数。

迄今为止我们映射函数至函子，所映射的函数都是仅一个参数的。但是当映射一个接受两个参数的函数像是\acode{*}至一个函子，该怎么办呢？
首先让我们来观测几个实际的例子。如果有\acode{Just 3}，我们做\acode{fmap (*) (Just 3)}，会得到什么？从\acode{Maybe}实现
\acode{Functor}的实例中我们知道如果是一个\acode{Just something}值，会将函数应用至\acode{Just}中的\acode{something}。
因此\acode{fmap (*) (Just 3)}的结果是\acode{Just ((*) 3)}，即\acode{Just (* 3)}。有意思！我们得到了一个包裹在
\acode{Just}中的函数！

\begin{lstlisting}[language=Haskell]
  ghci> :t fmap (++) (Just "hey")
  fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])
  ghci> :t fmap compare (Just 'a')
  fmap compare (Just 'a') :: Maybe (Char -> Ordering)
  ghci> :t fmap compare "A LIST OF CHARS"
  fmap compare "A LIST OF CHARS" :: [Char -> Ordering]
  ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]
  fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]
\end{lstlisting}

如果映射\acode{compare}，其类型是\acode{(Ord a) => a -> a -> Ordering}至一个字符列表，得到\acode{Char -> Ordering}的
列表，因为函数\acode{compare}是部分应用在列表中的每个字符上的。不是\acode{(Ord a) => a -> Ordering}函数的列表，因为第一个
\acode{a}被应用的是一个\acode{Char}，因此第二个\acode{a}就必须是\acode{Char}类型了。

我们见识到了如何映射“多参数”函数至函子，得到的是一个包含了该函数的函子。那现在我们能对这个包含了函数的函子做什么呢？我们能用一个
消费这些函数的函数来映射至这个函子，这些函子中的函数都会被当做参数传给消费函数。

\begin{lstlisting}[language=Haskell]
  ghci> let a = fmap (*) [1,2,3,4]
  ghci> :t a
  a :: [Integer -> Integer]
  ghci> fmap (\f -> f 9) a
  [9,18,27,36]
\end{lstlisting}

但如果一个函子值是\acode{Just (3 *)}，一个函子值是\acode{Just 5}，我们希望从\acode{Just (3 *)}取出函数并映射至\acode{Just 5}
呢？普通的函子是没法做的，因为他们仅支持映射普通函数至已存在的函子。即使当我们映射\acode{\\f -> f 9}至一个包含了函数的函子上，我们
也只是映射了一个普通函数。也就是说我们没法用\acode{fmap}将一个包在函子里的函数映射至一个函子。我们可以用模式匹配将\acode{Just}中的
函数抽出来再映射至\acode{Just 5}，不过我们希望有一个通用方法，对于任何函子都有效。

现在来看看\acode{Applicative}这个 typeclass，可以在\acode{Control.Applicative}中找到它，其定义了两个函数\acode{pure}以及
\acode{<*>}。没有任何的默认实现，因此如果希望某物成为高级函子，那么我们需要定义这两个函数。其定义如下：

\begin{lstlisting}[language=Haskell]
  class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{lstlisting}

这简单的三行告诉了我们很多东西！首先是第一行，定义\acode{Applicative}类，并引入了类约束，即\acode{Applicative} typeclass 的
构造函数中的类型首先必须的是一个\acode{Functor}，因为这样才能使用\acode{fmap}。

第一个定义的方法是\acode{pure}。其类型声明是\acode{pure :: a -> f a}。\acode{f}在这里就是高级函子的实例。其接受一个任意类型，
返回一个包含了该任意类型的高级函子。

一个更好理解\acode{pure}的方式就是它接受一个值，将该值放入某些默认（或纯）context 中 -- 这个最小的 context 仍然包含了这个值。

\acode{<*>}函数非常有趣，其类型声明是\acode{f (a -> b) -> f a -> f b}，这跟\acode{fmap :: (a -> b) -> f a -> f b}很像。
也就是一个增强版的\acode{fmap}。\acode{fmap}接受一个函数和函子，并将函数应用至函子内的值，而\acode{<*>}接受一个包含了函数的函子，
以及另一个函子，并类似于提取第一个函子中的函数应用至第二个函子中。

下面是\acode{Maybe}实现\acode{Applicative}的实例：

\begin{lstlisting}[language=Haskell]
  instance Applicative Maybe where
    pure = Just
    Nothing <*> _ = Nothing
    (Just f) <*> something = fmap f something
\end{lstlisting}

首先是\acode{pure}，这里的\acode{pure = Just}是因为\acode{Just}的值构造函数是普通函数，等同于\acode{pure x = Just x}。

其次是\acode{<*>}，我们不能从\acode{Nothing}中提取函数，因此其返回值就是\acode{Nothing}；如果是一个包含函数的\acode{Just}，
那么将该函数映射至第二个参数，这里第二个参数也有可能是\acode{Nothing}，不过\acode{fmap}任何函数至\acode{Nothing}也都会返回
\acode{Nothin}，因此无需多虑。

测试一下：

\begin{lstlisting}[language=Haskell]
  ghci> Just (+3) <*> Just 9
  Just 12
  ghci> pure (+3) <*> Just 10
  Just 13
  ghci> pure (+3) <*> Just 9
  Just 12
  ghci> Just (++"hahah") <*> Nothing
  Nothing
  ghci> Nothing <*> Just "woot"
  Nothing
\end{lstlisting}

普通的函子能将函数映射至函子本身，但是可能没法拿到结果；而高级函子则可以让你用单一一个函数操作好几个函子。比如：

\begin{lstlisting}[language=Haskell]
  ghci> pure (+) <*> Just 3 <*> Just 5
  Just 8
  ghci> pure (+) <*> Just 3 <*> Nothing
  Nothing
  ghci> pure (+) <*> Nothing <*> Just 5
  Nothing
\end{lstlisting}

这里发生了什么？让我们一步一步来看。\acode{<*>}是左关联的，意味着\acode{pure (+) <*> Just 3 <*> Just 5}等同于
\acode{(pure (+) <*> Just 3) <*> Just 5}。首先\acode{+}函数被放进了一个函子中，这个例子中就是\acode{Maybe}包含了该
函数，因此\acode{pure (+)}即是\acode{Just (+)}。其次\acode{Just (+) <*> Just 3}发生了，其结果为\acode{Just (3+)}，
这是因为部分应用，仅将\acode{3}应用至\acode{+}函数返回的是一个接受一个参数的函数。最后\acode{Just (3+) <*> Just 5}被
运算，结果就是\acode{Just 8}。

这很棒吧！用 applicative 风格来使用高级函子，如\acode{pure f <*> x <*> y <*> ...}就让我们可以哪一个接受多个参数的函数，
而且这些参数不一定是包在函子内的。这样套用多个在函子 context 的值，该函数可以消费任意多的参数，毕竟\acode{<*>}只是在做
部分应用而已。

如果考虑到\acode{pure f <*> x}等同于\acode{fmap f x}的话，这样的用法就更方便了。这是一条 applicative 定律，之后会进行
详细讲解。如果我们将一个函数置入默认 context 中，接着提取并应用至另一个一个高级函子中的值，那么这就跟映射一个函数至高级函子
一样。与其\acode{pure f <*> x <*> y <*> ...}，可以写作\acode{fmap f x <*> y <*> ...}。这就是为什么
\acode{Control.Applicative}导出了一个名为\acode{<\$>}的函数，它实际上就是一个中置版本的\acode{fmap}，其定义如下：

\begin{lstlisting}[language=Haskell]
  (<$>) :: (Functor f) => (a -> b) -> f a -> f b
  f <$> x = fmap f x
\end{lstlisting}

\begin{anote}
  快速提示：类型变量跟参数的名字还有值绑定的名称不冲突。\acode{f}在函数的类型声明中是类型变量，说明\acode{f}应该要满足
  \acode{Functor} typeclass 的条件。而在函数本体中的\acode{f}则表示一个函数，我们将它映射至\acode{x}。我们同样用
  \acode{f}来表示它们并代表它们是相同的东西。
\end{anote}

通过使用\acode{<\$>}，applicative 风格的好处就很显著了。如果将\acode{f}应用至三个高级函子，就可以这样
\acode{f <\$> x <*> y <*> z}。如果参数不是高级函子而是普通值，则是\acode{f x y z}。

让我们再看看它是如何工作的。我们有一个值\acode{Just "johntra"}以及一个值\acode{Just "volta"}，我们想要合并他们成为
一个在\acode{Maybe}函子内部的\acode{String}。我们可以这么做：

\begin{lstlisting}[language=Haskell]
  ghci> (++) <$> Just "johntra" <*> Just "volta"
  Just "johntravolta"
\end{lstlisting}

在正式讲解发生了什么之前，先比较一下：

\begin{lstlisting}[language=Haskell]
  ghci> (++) "johntra" "volta"
  "johntravolta"
\end{lstlisting}

可以将一个普通的函数应用在高级函子上真棒。只用写一些\acode{<\$>}以及\acode{<*>}就可以把函数变为 applicative 风格，操作
这些 applicatives 并返回一个 applicative。太酷了！

无论如何，当运算\acode{(++) <\$> Just "johntra" <*> Just "volta"}时，首先\acode{(++)}其类型是\acode{(++) :: [a]
-> [a] -> [a]}，映射至\acode{Just "johntra"}，返回值为\acode{Just ("johntra"++)}，类型为\acode{Maybe ([Char] ->
[Char])}。注意\acode{(++)}的第一个参数被吃掉了，即\acode{a}转换为\acode{Char}。接着是\acode{Just ("johntra"++)
  <*> Just "volta"}，从\acode{Just}提取出的函数并映射至\acode{Just "volta"}，得到\acode{Just "johntravolta"}。
这里只要任意一个值是\acode{Nothing}，那么得到的结果也是\acode{Nothing}。

列表（实际上说的是列表构造函数，\acode{[]}）也是高级函子。惊喜吧！下面是\acode{[]}如何作为\acode{Applicative}实例的：

\begin{lstlisting}[language=Haskell]
  instance Applicative [] where
    pure x = [x]
    fs <*> xs = [f x | f <- fs, x <- xs]
\end{lstlisting}

之前我们说\acode{pure}接受一个值并将其放入一个默认 context 中，或者说，一个最小 context 仍然包含该值。这里的最小 context
就是空列表，\acode{[]}，不过空列表并不包含一个值，所以我们没法将其当做\acode{pure}。这也是为什么\acode{pure}实际上是接受
一个值，然后返回一个带有单元素的列表。同样的，\acode{Maybe}的最小 context 是\acode{Nothing}，但它其实表示的是没有值，
所以\acode{pure}其实是被实现成了\acode{Just}。

\begin{lstlisting}[language=Haskell]
  ghci> pure "Hey" :: [String]
  ["Hey"]
  ghci> pure "Hey" :: Maybe String
  Just "Hey"
\end{lstlisting}

那么\acode{<*>}呢？如果我们假定\acode{<*>}的类型是限制在列表上的话，我们会得到\acode{(<*>) :: [a -> b]-> [a]  -> [b]}。
这是用列表表达式来实现的。\acode{<*>}必须以某种方式从左侧参数中提取函数并映射至右侧参数上。不过这里左侧列表可以是没有函数，
一个函数，或者多个函数；右侧列表也可以存储若干值。这就是为什么我们使用列表表达式从两方列表中取值。我们要将左侧列表中所有可能的函数
映射至右侧列表中所有可能的值。

\begin{lstlisting}[language=Haskell]
  ghci> [(*0),(+100),(^2)] <*> [1,2,3]
  [0,0,0,101,102,103,1,4,9]
\end{lstlisting}

左侧列表包含三个函数，而右侧列表有三个值，那么结果就是有九个元素的列表。左边列表的每个函数都应用在右侧列表的每个值。如果列表中的
函数接受两个参数，那么也可以应用到两个列表上：

\begin{lstlisting}[language=Haskell]
  ghci> [(+),(*)] <*> [1,2] <*> [3,4]
  [4,5,5,6,3,4,6,8]
\end{lstlisting}

这是因为\acode{<*>}是左关联的，即\acode{[(+),(*)] <*> [1,2]}会先运行，得到\acode{[(1+),(2+),(1*),(2*)]}，又因为左侧
列表中的每个函数都会应用至右边列表中的每个值，即\acode{[(1+),(2+),(1*),(2*)] <*> [3,4]}，最终结果如上所述。

列表的 applicative 风格是非常有趣的：

\begin{lstlisting}[language=Haskell]
  ghci> (++) <$> ["ha","heh","hmm"] <*> ["?","!","."]
  ["ha?","ha!","ha.","heh?","heh!","heh.","hmm?","hmm!","hmm."]
\end{lstlisting}

你可以认为列表是一个非确定性 non-deterministic 的计算。对于像\acode{100}或\acode{"what"}则是确定性 deterministic 计算，
即只有一个结果；而\acode{[1,2,3]}则可以看作是没有确定究竟是哪一种结果，也就是说它代表的是所有可能的结果。在运行
\acode{(+) <\$> [1,2,3] <*> [4,5,6]}时，可以视为两个非确定性的计算通过\acode{+}进行运算，只不过会产生另一个非确定性的计算，
而结果更加不确定。

Applicative 风格对于列表而言是一个取代列表表达式的好方法。第二章里计算\acode{[2,5,10]}与\acode{[8,10,11]}相乘的结果，需要：

\begin{lstlisting}[language=Haskell]
  ghci> [ x*y | x <- [2,5,10], y <- [8,10,11]]
  [16,20,22,40,50,55,80,100,110]
\end{lstlisting}

通过 applicative 风格改写：

\begin{lstlisting}[language=Haskell]
  ghci> (*) <$> [2,5,10] <*> [8,10,11]
  [16,20,22,40,50,55,80,100,110]
\end{lstlisting}

如果我们希望将两个列表中的所有乘积大于 50 的数找出来，仅需：

\begin{lstlisting}[language=Haskell]
  ghci> filter (>50) $ (*) <$> [2,5,10] <*> [8,10,11]
  [55,80,100,110]
\end{lstlisting}

可以看到列表的运算中，\acode{pure f <*> xs}等同于\acode{fmap f xs}。\acode{pure f}就是\acode{[f]}，以及
\acode{[f] <*> xs}将应用左侧列表中的每个函数至右侧列表中的每个值，但左边其实只有一个函数，所以看上去就像是 mapping。

另一个我们已经遇到的\acode{Applicative}实例就是\acode{IO}，其实现：

\begin{lstlisting}[language=Haskell]
  instance Applicative IO where
    pure = return
    a <*> b = do
        f <- a
        x <- b
        return (f x)
\end{lstlisting}

\acode{pure}将值放入最小 context 内，这里即\acode{return}，意味着一个 I/O action 不做任何事情，返回其包含的值，
但实际上并没有做任何 I/O 操作比如打印至终端或者文件读取。

而\acode{<*>}被限制在\acode{IO}上的话，它的类型就是\acode{<*> :: IO (a -> b) -> IO a -> IO b}，即接受一个生产
函数的 I/O action，以及另一个 I/O action，由它们创建一个新的 I/O action，也就是把第二个参数传给第一个参数，得到的
返回值放进新的 I/O action 中。注意\textit{do}语法就是将若干 I/O action 粘合成一个，这正是我们现在所做的。

通过\acode{Maybe}已经\acode{[]}，我们可以认为\acode{<*>}就是从其左参数中提取一个函数，再将该函数应用至右参数上。
而对于\acode{IO}，仍然是提取，不过带上了\textit{序列 sequencing}这个概念，因为接受两个 I/O actions 顺序执行，或者
说是粘合成为一个 I/O action。从第一个 I/O action 中取值，但要取出 I/O action 的结果，因此它必须先被执行。

例如：

\begin{lstlisting}[language=Haskell]
  myAction :: IO String
  myAction = do
      a <- getLine
      b <- getLine
      return $ a ++ b
\end{lstlisting}

这个 I/O action 提示用户输入两行在返回合并的两行。达到这个目的就是将两个\acode{getLine} I/O actions 粘合在一起后
使用\acode{return}。而使用 applicative 可以这样写：

\begin{lstlisting}[language=Haskell]
  myAction :: IO String
  myAction = (++) <$> getLine <*> getLine
\end{lstlisting}

表达式\acode{(++) <\$> getLine <*> getLine}的类型是\acode{IO String}，意味着该表达式跟别的 I/O action 完全
一样，因此可以这么做：

\begin{lstlisting}[language=Haskell]
  main = do
    a <- (++) <$> getLine <*> getLine
    putStrLn $ "The two lines concatenated turn out to be: " ++ a
\end{lstlisting}

另一个\acode{Applicative}实例就是\acode{(->) r}：

\begin{lstlisting}[language=Haskell]
  instance Applicative ((->) r) where
    pure x = (\_ -> x)
    f <*> g = \x -> f x (g x)
\end{lstlisting}

\acode{pure}接受值，创建一个忽视入参且将该值作为返回的函数，即\acode{pure :: a -> (r -> a)}。

\begin{lstlisting}[language=Haskell]
  ghci> (pure 3) "blah"
  3
\end{lstlisting}

因为有柯里化，函数应用时左关联的，所以可以省略括号：

\begin{lstlisting}[language=Haskell]
  ghci> pure 3 "blah"
  3
\end{lstlisting}

而\acode{<*>}的实现则有点神秘，让我们看看作为高级函子如何使用该函数：

\begin{lstlisting}[language=Haskell]
  ghci> :t (+) <$> (+3) <*> (*100)
  (+) <$> (+3) <*> (*100) :: (Num a) => a -> a
  ghci> (+) <$> (+3) <*> (*100) $ 5
  508
\end{lstlisting}

两个高级函子输入\acode{<*>}返回一个高级函子，所以如果输入两个函数，则得到一个新的函数。这里发生了什么？当使用
\acode{(+) <\$> (+3) <*> (*100)}时，我们在创造一个函数，该函数会将\acode{(+3)}以及\acode{(*100)}的结果，
应用\acode{+}，再进行返回，即\acode{5}给到\acode{(+3)}以及\acode{(*100)}，得到\acode{8}与\acode{500}后，
将\acode{+}应用至\acode{8}与\acode{500}，得\acode{508}。再比如：

\begin{lstlisting}[language=Haskell]
  ghci> (\x y z -> [x,y,z]) <$> (+3) <*> (*2) <*> (/2) $ 5
  [8.0,10.0,2.5]
\end{lstlisting}

这里也一样。创建一个将会调用\acode{\\x y z -> [x,y,z]}函数的函数，输入的参数是\acode{(+3)}，\acode{(*2)}，
以及\acode{(/2)}。\acode{5}则被分别输入进这三个函数中，接着调用\acode{\\x y z -> [x,y,z]}得到结果。

我们可以认为函数作为盒子包含着它们最终的结果，因此\acode{k <\$> f <*> g}创建了一个将最终会对\acode{f}与
\acode{g}的结果而调用\acode{k}的函数。

另一个我们还没遇到过的\acode{Applicative}实例就是\acode{ZipList}，它位于\acode{Control.Applicative}模块中。

实际上列表要作为一个高级函子可以有很多种方式。已经介绍过的一种就是应用\acode{<*>}，左参是若干函数，右参则是若干值，
结果这是函数应用于所有值后的所有组合。例如\acode{[(+3),(*2)] <*> [1,2]}，\acode{(+3)}会先应用至\acode{1}与
\acode{2}，接着再是\acode{(*2)}应用至\acode{1}与\acode{2}，最终得\acode{[4,5,2,4]}。

而\acode{[(+3),(*2)] <*> [1,2]}理论上也可以将左参第一个函数应用至右参第一个值，再将左参第二个函数应用至右参的
第二个值，以此类推。

由于一个类型不能对同个 typeclass 定义两个实例，因此才有\acode{ZipList a}，它只有一个构造函数\acode{ZipList}，
一个字段，它的类型是列表：

\begin{lstlisting}[language=Haskell]
  instance Applicative ZipList where
    pure x = ZipList (repeat x)
    ZipList fs <*> ZipList xs = ZipList (zipWith (\f x -> f x) fs xs)
\end{lstlisting}

\acode{<*>}就是上面说的顺序应用，这是通过\acode{zipWith (\\f x -> f x) fs xs}实现的。又因为\acode{zipWith}
的原理，返回的列表长度由输入的列表中最短的那个决定。

\acode{pure}在这里同样有趣。它接受一个值，将其置入一个无限循环该值的列表中，例如\acode{pure "haha"}在这里返回
\acode{ZipList (["haha", "haha", "haha" ...)}。这里可能会令人迷惑，之前我们说过\acode{pure}是把一个值放入
最小的 context 中，而无限长的列表不可能会是一个最小的 context。然而这对 zip 列表来说很合理，因为它必须在列表的
每个位置都有值。这也遵守了\acode{pure f <*> xs}必须要等价于\acode{fmap f xs}的特性。

% TODO

\subsection*{newtype 关键字}

% TODO

\subsection*{幺半群 Monoids}

% TODO

\end{document}
