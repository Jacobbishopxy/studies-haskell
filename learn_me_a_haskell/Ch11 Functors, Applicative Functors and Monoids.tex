\documentclass[./main.tex]{subfiles}

\begin{document}

由纯粹性，高阶函数，参数化代数数据类型，以及 typeclasses 所构成的 Haskell，相比于其他语言，允许我们实现更高等级的多态。
我们无需考虑类型是如何属于一个类型阶级系统的，而是由合理的 typeclasses 如何连接它们的。

Typesclasses 是开放的，这就意味着我们可以定义自己的数据类型。

\subsection*{函子 Functors 复习}

回忆：Functors 可以用于映射至比如列表，\acode{Maybe}，树，等等。在 Haskell 中它们被 \acode{Functor} typeclass
所描述，其仅有一个名为 \acode{fmap} 的 typeclass 方法，该方法的类型是\acode{fmap :: (a -> b) -> f a -> f b}。
它表示：给我一个接受一个\acode{a}并返回一个\acode{b}的函数，以及给我一个（或多个）\acode{a}的容器，那么我将给你一个
（或多个）\acode{b}的容器。有点像是将函数应用至容器中的元素。

如果一个类型构造函数是\acode{Functor}的实例，那么它的 kind 就必须是\acode{* -> *}，这代表它必须刚好接受一个类型作为
类型参数。像是\acode{Maybe}是 Functor 的实例，它接受一个类型参数，如\acode{Maybe Int}或\acode{Maybe String}。
如果一个类型构造函数接受两个参数，比如\acode{Either}，我们不能这样\acode{instance Functor Either where}，不过
可以这样\acode{instance Functor (Either a) where}，那么\acode{fmap}作为\acode{Either a}的类型前面就可以这样
\acode{fmap :: (b -> c) -> Either a b -> Either a c}。

现在看看\acode{IO}是怎么样的一个\acode{Functor}实例。当我们\acode{fmap}一个函数在一个 I/O action 上，我们希望
拿回的 I/O action 是已经被映射过的：

\begin{lstlisting}[language=Haskell]
  instance Functor IO where
    fmap f action = do
        result <- action
        return (f result)
\end{lstlisting}

对一个 I/O action 映射的结果仍然是一个 I/O action，因此需要用\textit{do}语法来把两个 I/O action 粘合成一个。

\begin{lstlisting}[language=Haskell]
  main = do
    line <- getLine
    let line' = reverse line
    putStrLn $ "You said " ++ line' ++ " backwards!"
    putStrLn $ "Yes, you really said " ++ line' ++ " backwards!"
\end{lstlisting}

用\acode{fmap}改写：

\begin{lstlisting}[language=Haskell]
  main = do
    line <- fmap reverse getLine
    putStrLn $ "You said " ++ line ++ " backwards!"
    putStrLn $ "Yes, you really said " ++ line ++ " backwards!"
\end{lstlisting}

如果将\acode{fmap}应用至\acode{IO}，其类型便为\acode{fmap :: (a -> b) -> IO a -> IO b}。

如果将一个 I/O action 绑定到一个名称上时，仅仅想要应用一个函数，那么可以考虑使用\acode{fmap}，因为这看起来更简洁。如果
想要应用多个函数，那么可以声明自己的函数，将其变为 lambda 或者使用函数组合：

\begin{lstlisting}[language=Haskell]
  import Data.Char
  import Data.List

  main = do
    line <- fmap (intersperse '-' . reverse . map toUpper) getLine
    putStrLn line
\end{lstlisting}

\begin{lstlisting}[language=Bash]
  $ runhaskell fmappingIO.hs
  hello there
  E-R-E-H-T- -O-L-L-E-H
\end{lstlisting}

\acode{intersperse '-' . reverse . map toUpper}这个函数接受一个字符串，映射\acode{toUpper}后的返回值再应用
\acode{reverse}，最后应用\acode{intersperes '-'}。

另一个我们已经接触过的\acode{Functor}实例就是\acode{(->) r}。函数类型\acode{r -> a}可以被重写为\acode{(->) r a}，
就像是\acode{2 + 3}可以表达为\acode{(+) 2 3}。从另一个角度来看\acode{(->) r a}，它其实就是一个接受两个类型参数的
构造函数，例如\acode{Either}。但是记住\acode{Functor}只能接受一个参数类型，这也是为什么\acode{(->)}不是
\acode{Functor}的一个实例，但是\acode{(->) r}则是。在\acode{Control.Monad.Instances}有更多的细节：

\begin{lstlisting}[language=Haskell]
  instance Functor ((->) r) where
    fmap f g = (\x -> f (g x))
\end{lstlisting}

首先来看看\acode{fmap}的类型\acode{fmap :: (a -> b) -> f a -> f b}。我们把所有的\acode{f}替换成\acode{(->) r}，
那么就是\acode{fmap :: (a -> b) -> ((->) r a) -> ((->) r b)}，然后将\acode{(->) r a}与\acode{(->) r b}换成
\acode{r -> a}与\acode{r -> b}，则得到\acode{fmap :: (a -> b) -> (r -> a) -> (r -> b)}。

将一个函数映射至另一个函数可以生产出一个函数，就像是映射一个函数在\acode{Maybe}上生产出一个\acode{Maybe}，映射一个函数在
一个列表上能生成出一个列表。那么上述的类型实例说的是什么呢？它接受一个\acode{a}至\acode{b}的函数，以及一个\acode{r}至
\acode{a}的函数，返回一个\acode{r}至\acode{b}的函数。这就是一个函数组合！另一种实例的写法：

\begin{lstlisting}[language=Haskell]
  instance Functor ((->) r) where
    fmap = (.)
\end{lstlisting}

很明显就是将\acode{fmap}当函数组合在用。在 GHCI 中使用\acode{:m + Control.Monad.Instances}加载模块，测试：

\begin{lstlisting}[language=Haskell]
  ghci> :t fmap (*3) (+100)
  fmap (*3) (+100) :: (Num a) => a -> a
  ghci> fmap (*3) (+100) 1
  303
  ghci> (*3) `fmap` (+100) $ 1
  303
  ghci> (*3) . (+100) $ 1
  303
  ghci> fmap (show . (*3)) (*100) 1
  "300"
\end{lstlisting}

\acode{fmap}等同于函数组合这件事儿对我们而言并不是很实用，但是这至少是一个有趣的观点。Functors 其实比较像是 computation，
函数被映射到另一个计算会经由那个函数映射过后的计算。

在看一下\acode{fmap}的类型\acode{fmap :: (a -> b) -> f a -> f b}，那么为了简洁不写\acode{(Functor f) =>}部分。
在学柯里化的时候提到过 Haskell 的函数实际上只接受一个参数，即\acode{a -> b -> c}，如果调用时少写一个参数，那么返回的函数
就需要接受剩下的参数。所以\acode{a -> b -> c}可以写成\acode{a -> (b -> c)}，这样柯里化更加明显。

同样的如果写成\acode{fmap :: (a -> b) -> (f a -> f b)}，我们可以认为\acode{fmap}不是一个接受函数与函子并返回一个函子的
函数，而是一个接受函数并返回一个新函数的函数，而这个返回的新函数接受一个函子作为参数，并返回一个函子。接受一个\acode{a -> b}
函数并返回一个\acode{f a -> f b}函数，这被称为\textit{提升 lifting}一个函数。我们用 GHCI 的\acode{:t}命令检查：

\begin{lstlisting}[language=Haskell]
  ghci> :t fmap (*2)
  fmap (*2) :: (Num a, Functor f) => f a -> f a
  ghci> :t fmap (replicate 3)
  fmap (replicate 3) :: (Functor f) => f a -> f [a]
\end{lstlisting}

表达式\acode{fmap (*2)}是一个接受基于数值的函子\acode{f}并返回一个数值函子的函数。函子可以是一个列表一个\acode{Maybe}，
一个\acode{Either String}，等等。表达式\acode{fmap (replicate 3)}则接受任意类型的函子并返回一个该类型列表函子。

\begin{anote}
  当我们说\textit{一个基于数值的函子 a functor over numbers}时，你可以认为是\textit{一个拥有数值的函子 a functor that
    has numbers in it}。前者的描述更加精准，后者则更容易理解。
\end{anote}

当使用部分应用绑定至一个名称时，比如说\acode{fmap (++"!")}，在 GHCI 更加的显而易见。

\begin{lstlisting}[language=Haskell]
  ghci> :t fmap (++"!")
  fmap (++"!") :: Functor f => f [Char] -> f [Char]
\end{lstlisting}

可以把\acode{fmap}想像成一个函数，接受另一个函数与一个函子，然后将接受的函数对函子中每个元素做映射；也可以想象成是一个函数，
接受一个函数并将其提升 lift 到可以在函子上操作。这两种想法都是正确的，且在 Haskell 中是等价的。

接下来我们开始学习\textbf{函子定律 functor laws}。为了让某物成为一个函子，它必须满足某些条件。所有的函子都要求具有某些性质，
它们必须是能被映射的，对它们调用\acode{fmap}应该要用一个函数映射至每一个元素，且没有额外的操作。这些行为都被函子定律所描述。
对于\acode{Functor}的实例而言，总共有两条定律该被遵守。不过它们不会在 Haskell 中自动被检查，需要用户自己确认这些条件。

\textbf{函子第一定律是如果将\acode{id}函数映射至该函子，得到的函子必须是原来的函子}。用代码表示即\acodegrn{fmap id = id}，
换言之如果\acode{fmap id}至一个函子，返回的结果跟直接\acode{id}至该函子是一样的。\acode{id}是一个 identity 函数，
可以写作是\acode{\\x -> x}。

\begin{lstlisting}[language=Haskell]
  ghci> fmap id (Just 3)
  Just 3
  ghci> id (Just 3)
  Just 3
  ghci> fmap id [1..5]
  [1,2,3,4,5]
  ghci> id [1..5]
  [1,2,3,4,5]
  ghci> fmap id []
  []
  ghci> fmap id Nothing
  Nothing
\end{lstlisting}

看一下\acode{Maybe}的\acode{fmap}的实现，可以知道第一定律是如何遵守的：

\begin{lstlisting}[language=Haskell]
  instance Functor Maybe where
    fmap f (Just x) = Just (f x)
    fmap f Nothing = Nothing
\end{lstlisting}

\textbf{函子第二定律是将两个函数合成并将结果映射至一个函子的结果，与现将第一个函数映射函子再将第二个函子映射至该函子的结果是一样的}。
即\acodegrn{fmap (f . g) = fmap f . fmap g}，或者另一种写法，对于任何一个函子\acode{F}，满足\acodegrn{fmap (f . g) F =
  fmap f (fmap g F)}。

\subsection*{高级函子 Applicative functors}

本节开始学习高级函子，在 Haskell 中由 \acode{Applicative} typeclass 描述，可在\acode{Control.Applicative}模块中找到。

函数在 Haskell 中默认是柯里化的，这就意味着一个函数看起来接受若干参数实际上是接受一个参数并返回一个函数再接受一个参数，以此类推。
如果一个函数的类型是\acode{a -> b -> c}，那么通常会说它接受两个参数并返回一个\acode{c}。这就是为什么可以将\acode{f x y}
表达为\acode{(f x) y}。这个机制允许我们部分应用函数，仅需调用少一些的参数，返回的函数可以被传递至另一个函数。

迄今为止我们映射函数至函子，所映射的函数都是仅一个参数的。但是当映射一个接受两个参数的函数像是\acode{*}至一个函子，该怎么办呢？
首先让我们来观测几个实际的例子。如果有\acode{Just 3}，我们做\acode{fmap (*) (Just 3)}，会得到什么？从\acode{Maybe}实现
\acode{Functor}的实例中我们知道如果是一个\acode{Just something}值，会将函数应用至\acode{Just}中的\acode{something}。
因此\acode{fmap (*) (Just 3)}的结果是\acode{Just ((*) 3)}，即\acode{Just (* 3)}。有意思！我们得到了一个包裹在
\acode{Just}中的函数！

\begin{lstlisting}[language=Haskell]
  ghci> :t fmap (++) (Just "hey")
  fmap (++) (Just "hey") :: Maybe ([Char] -> [Char])
  ghci> :t fmap compare (Just 'a')
  fmap compare (Just 'a') :: Maybe (Char -> Ordering)
  ghci> :t fmap compare "A LIST OF CHARS"
  fmap compare "A LIST OF CHARS" :: [Char -> Ordering]
  ghci> :t fmap (\x y z -> x + y / z) [3,4,5,6]
  fmap (\x y z -> x + y / z) [3,4,5,6] :: (Fractional a) => [a -> a -> a]
\end{lstlisting}

如果映射\acode{compare}，其类型是\acode{(Ord a) => a -> a -> Ordering}至一个字符列表，得到\acode{Char -> Ordering}的
列表，因为函数\acode{compare}是部分应用在列表中的每个字符上的。不是\acode{(Ord a) => a -> Ordering}函数的列表，因为第一个
\acode{a}被应用的是一个\acode{Char}，因此第二个\acode{a}就必须是\acode{Char}类型了。

我们见识到了如何映射“多参数”函数至函子，得到的是一个包含了该函数的函子。那现在我们能对这个包含了函数的函子做什么呢？我们能用一个
消费这些函数的函数来映射至这个函子，这些函子中的函数都会被当做参数传给消费函数。

\begin{lstlisting}[language=Haskell]
  ghci> let a = fmap (*) [1,2,3,4]
  ghci> :t a
  a :: [Integer -> Integer]
  ghci> fmap (\f -> f 9) a
  [9,18,27,36]
\end{lstlisting}

但如果一个函子值是\acode{Just (3 *)}，一个函子值是\acode{Just 5}，我们希望从\acode{Just (3 *)}取出函数并映射至\acode{Just 5}
呢？普通的函子是没法做的，因为他们仅支持映射普通函数至已存在的函子。即使当我们映射\acode{\\f -> f 9}至一个包含了函数的函子上，我们
也只是映射了一个普通函数。也就是说我们没法用\acode{fmap}将一个包在函子里的函数映射至一个函子。我们可以用模式匹配将\acode{Just}中的
函数抽出来再映射至\acode{Just 5}，不过我们希望有一个通用方法，对于任何函子都有效。

现在来看看\acode{Applicative}这个 typeclass，可以在\acode{Control.Applicative}中找到它，其定义了两个函数\acode{pure}以及
\acode{<*>}。没有任何的默认实现，因此如果希望某物成为高级函子，那么我们需要定义这两个函数。其定义如下：

\begin{lstlisting}[language=Haskell]
  class (Functor f) => Applicative f where
    pure :: a -> f a
    (<*>) :: f (a -> b) -> f a -> f b
\end{lstlisting}

这简单的三行告诉了我们很多东西！首先是第一行，定义\acode{Applicative}类，并引入了类约束，即\acode{Applicative} typeclass 的
构造函数中的类型首先必须的是一个\acode{Functor}，因为这样才能使用\acode{fmap}。

第一个定义的方法是\acode{pure}。其类型声明是\acode{pure :: a -> f a}。\acode{f}在这里就是高级函子的实例。其接受一个任意类型，
返回一个包含了该任意类型的高级函子。

一个更好理解\acode{pure}的方式就是它接受一个值，将该值放入某些默认（或纯）context 中 -- 这个最小的 context 仍然包含了这个值。

\acode{<*>}函数非常有趣，其类型声明是\acode{f (a -> b) -> f a -> f b}，这跟\acode{fmap :: (a -> b) -> f a -> f b}很像。
也就是一个增强版的\acode{fmap}。\acode{fmap}接受一个函数和函子，并将函数应用至函子内的值，而\acode{<*>}接受一个包含了函数的函子，
以及另一个函子，并类似于提取第一个函子中的函数应用至第二个函子中。

下面是\acode{Maybe}实现\acode{Applicative}的实例：

\begin{lstlisting}[language=Haskell]
  instance Applicative Maybe where
    pure = Just
    Nothing <*> _ = Nothing
    (Just f) <*> something = fmap f something
\end{lstlisting}

首先是\acode{pure}，这里的\acode{pure = Just}是因为\acode{Just}的值构造函数是普通函数，等同于\acode{pure x = Just x}。

其次是\acode{<*>}，我们不能从\acode{Nothing}中提取函数，因此其返回值就是\acode{Nothing}；如果是一个包含函数的\acode{Just}，
那么将该函数映射至第二个参数，这里第二个参数也有可能是\acode{Nothing}，不过\acode{fmap}任何函数至\acode{Nothing}也都会返回
\acode{Nothin}，因此无需多虑。

测试一下：

\begin{lstlisting}[language=Haskell]
  ghci> Just (+3) <*> Just 9
  Just 12
  ghci> pure (+3) <*> Just 10
  Just 13
  ghci> pure (+3) <*> Just 9
  Just 12
  ghci> Just (++"hahah") <*> Nothing
  Nothing
  ghci> Nothing <*> Just "woot"
  Nothing
\end{lstlisting}

普通的函子能将函数映射至函子本身，但是可能没法拿到结果；而高级函子则可以让你用单一一个函数操作好几个函子。比如：

\begin{lstlisting}[language=Haskell]
  ghci> pure (+) <*> Just 3 <*> Just 5
  Just 8
  ghci> pure (+) <*> Just 3 <*> Nothing
  Nothing
  ghci> pure (+) <*> Nothing <*> Just 5
  Nothing
\end{lstlisting}

这里发生了什么？让我们一步一步来看。\acode{<*>}是左关联的，意味着\acode{pure (+) <*> Just 3 <*> Just 5}等同于
\acode{(pure (+) <*> Just 3) <*> Just 5}。首先\acode{+}函数被放进了一个函子中，这个例子中就是\acode{Maybe}包含了该
函数，因此\acode{pure (+)}即是\acode{Just (+)}。其次\acode{Just (+) <*> Just 3}发生了，其结果为\acode{Just (3+)}，
这是因为部分应用，仅将\acode{3}应用至\acode{+}函数返回的是一个接受一个参数的函数。最后\acode{Just (3+) <*> Just 5}被
运算，结果就是\acode{Just 8}。

这很棒吧！用 applicative 风格来使用高级函子，如\acode{pure f <*> x <*> y <*> ...}就让我们可以哪一个接受多个参数的函数，
而且这些参数不一定是包在函子内的。这样套用多个在函子 context 的值，该函数可以消费任意多的参数，毕竟\acode{<*>}只是在做
部分应用而已。

如果考虑到\acode{pure f <*> x}等同于\acode{fmap f x}的话，这样的用法就更方便了。这是一条 applicative 定律，之后会进行
详细讲解。如果我们将一个函数置入默认 context 中，接着提取并应用至另一个一个高级函子中的值，那么这就跟映射一个函数至高级函子
一样。与其\acode{pure f <*> x <*> y <*> ...}，可以写作\acode{fmap f x <*> y <*> ...}。这就是为什么
\acode{Control.Applicative}导出了一个名为\acode{<\$>}的函数，它实际上就是一个中置版本的\acode{fmap}，其定义如下：

\begin{lstlisting}[language=Haskell]
  (<$>) :: (Functor f) => (a -> b) -> f a -> f b
  f <$> x = fmap f x
\end{lstlisting}

\begin{anote}
  快速提示：类型变量跟参数的名字还有值绑定的名称不冲突。\acode{f}在函数的类型声明中是类型变量，说明\acode{f}应该要满足
  \acode{Functor} typeclass 的条件。而在函数本体中的\acode{f}则表示一个函数，我们将它映射至\acode{x}。我们同样用
  \acode{f}来表示它们并代表它们是相同的东西。
\end{anote}

通过使用\acode{<\$>}，applicative 风格的好处就很显著了。如果将\acode{f}应用至三个高级函子，就可以这样
\acode{f <\$> x <*> y <*> z}。如果参数不是高级函子而是普通值，则是\acode{f x y z}。

让我们再看看它是如何工作的。我们有一个值\acode{Just "johntra"}以及一个值\acode{Just "volta"}，我们想要合并他们成为
一个在\acode{Maybe}函子内部的\acode{String}。我们可以这么做：

\begin{lstlisting}[language=Haskell]
  ghci> (++) <$> Just "johntra" <*> Just "volta"
  Just "johntravolta"
\end{lstlisting}

在正式讲解发生了什么之前，先比较一下：

\begin{lstlisting}[language=Haskell]
  ghci> (++) "johntra" "volta"
  "johntravolta"
\end{lstlisting}

可以将一个普通的函数应用在高级函子上真棒。只用写一些\acode{<\$>}以及\acode{<*>}就可以把函数变为 applicative 风格，操作
这些 applicatives 并返回一个 applicative。太酷了！

% TODO

% \begin{lstlisting}[language=Haskell]

% \end{lstlisting}

% \begin{lstlisting}[language=Haskell]

% \end{lstlisting}

\subsection*{newtype 关键字}

% TODO

\subsection*{幺半群 Monoids}

% TODO

\end{document}
