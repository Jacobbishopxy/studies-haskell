\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{代数数据类型介绍}

迄今为止我们接触到了不少的类型：\acode{Bool}，\acode{Int}，\acode{Char}，\acode{Maybe}等等。但是我们如何构造自己的类型呢？
一种方式是使用\textbf{data}关键字来进行定义。让我们来看一下标准库中的\acode{Bool}是怎么定义的：

\begin{lstlisting}[language=Haskell]
data Bool = False | True
\end{lstlisting}

\textbf{data}意味着正在定义一个新的数据类型。在\acode{=}之前的部分代表着类型，即\acode{Bool}；而之后的部分则是
\textbf{类型构造函数value constructors}。它们指定了类型可变的值，这里的\acode{|}读作\textit{或 or}，因此整句代码可以读作：
\acode{Bool}类型可以是\acode{True}或\acode{False}其中的一个值。

假设这里定义了形状可以是一个圆或是长方形：

\begin{lstlisting}[language=Haskell]
  ghci> data Shape = Circle Float Float Float | Rectangle Float Float Float Float
  ghci> :t Circle
  Circle :: Float -> Float -> Float -> Shape
  ghci> :t Rectangle
  Rectangle :: Float -> Float -> Float -> Float -> Shape
\end{lstlisting}

\acode{Clicle}的值构造函数有三个字段，均接受浮点数；而\acode{Rectangle}的值构造函数有四个字段，均接受浮点数。

值构造函数实际上是最终返回数据类型值的函数。以下是一个接受 shape 并返回 surface 的函数：

\begin{lstlisting}[language=Haskell]
  surface :: Shape -> Float
  surface (Circle _ _ r) = pi * r ^ 2
  surface (Rectangle x1 y1 x2 y2) = abs (x2 - x1) * abs (y2 - y1)
\end{lstlisting}

首先值得注意的是类型声明。我们不能这样\acode{Circle -> Float}因为\acode{Circle}并非一个类型，\acode{Shape}才是。这就像我们
不能编写一个类型声明为\acode{True -> Int}的函数。其次需要注意的是我们不能对构造函数进行模式匹配，之前我们匹配过\acode{[]}，
\acode{False}或是\acode{5}，它们是不包含参数的值构造函数。

\begin{lstlisting}[language=Haskell]
  ghci> surface $ Circle 10 20 10
  314.15927
  ghci> surface $ Rectangle 0 0 100 100
  10000.0
\end{lstlisting}

很好成功了！但是如果我们想要打印出\acode{Circle 10 20 5}，则会得到一个错误。这是因为 Haskell 并不知道该如何将我们的数据类型
转换成字符串，因此我们需要让\acode{Shape}成为\acode{Show} typeclass 的一部分：

\begin{lstlisting}[language=Haskell]
  data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)
\end{lstlisting}

值构造函数是函数，因此我们可以映射它们并偏应用至任何东西：

\begin{lstlisting}[language=Haskell]
  ghci> map (Circle 10 20) [4,5,6,6]
  [Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 6.0]
\end{lstlisting}

我们的数据类型很棒，不过可以更棒。定义一个中间类型增强可读性：

\begin{lstlisting}[language=Haskell]
  data Point  = Point Float Float deriving (Show)
  data Shape = Circle Point Float | Rectangle Point Point deriving (Show)
\end{lstlisting}

修改\acode{surface}函数：

\begin{lstlisting}[language=Haskell]
  surface :: Shape -> Float
  surface (Circle _ r) = pi * r ^ 2
  surface (Rectangle (Point x1 y1) (Point x2 y2)) =
    abs (x2 - x1) * abs (y2 - y1)
\end{lstlisting}

调用时需要考虑模式：

\begin{lstlisting}[language=Haskell]
  ghci> surface (Rectangle (Point 0 0) (Point 100 100))
  10000.0
  ghci> surface (Circle (Point 0 0) 24)
  1809.5574
\end{lstlisting}

接下来是\acode{nudge}函数：

\begin{lstlisting}[language=Haskell]
  nudge :: Shape -> Float -> Float -> Shape
  nudge (Circle (Point x y) r) a b = Circle (Point (x + a) (y + b)) r
  nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b =
    Rectangle (Point (x1 + a) (y1 + b)) (Point (x2 + a) (y2 + b))
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> nudge (Circle (Point 34 34) 10) 5 10
  Circle (Point 39.0 44.0) 10.0
\end{lstlisting}

如果我们不想直接处理点，那么可以辅助函数用于创建初始在零点的形状并将其移动至正确点位：

\begin{lstlisting}[language=Haskell]
  baseCircle :: Float -> Shape
  baseCircle = Circle (Point 0 0)

  baseRect :: Float -> Float -> Shape
  baseRect width height = Rectangle (Point 0 0) (Point width height)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> nudge (baseRect 40 100) 60 23
  Rectangle (Point 60.0 23.0) (Point 100.0 123.0)
\end{lstlisting}

如果希望将所有的函数与类型导出（注意类型中使用\acode{..}，下文有解释），那么可以这么做：

\begin{lstlisting}[language=Haskell]
  module Shapes
    ( Point (..),
      Shape (..),
      surface,
      nudge,
      baseCircle,
      baseRect,
    )
  where
\end{lstlisting}

这里的\acode{Shape (..)}导出了所有\acode{Shape}的值构造函数，因此任何加载了该模块的都可以通过\acode{Rectangle}与
\acode{Circle}的值构造函数来创建形状。

当然也可以选择行的不到处任何\acode{Shape}的值构造函数，仅需在导出声明中这样写\acode{Shape}。这样的话加载该模块的仅能
使用辅助函数\acode{baseCircle}与\acode{baseRect}来创建形状。\acode{Data.Map}使用了这个技巧。

不到处数据类型的值构造函数会使得它们更为抽象，因为我们隐层了它们的实现；除此之外，使用该模块的将不再能对其使用模式匹配。

\subsection*{Record Syntax}

现在让我们创造一个用于描述人的数据类型，其中信息包括：名，姓，年龄，身高，体重，电话以及喜爱的冰淇淋类型。

\begin{lstlisting}[language=Haskell]
  data Person = Person String String Int Float String String deriving (Show)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
  ghci> guy
  Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
\end{lstlisting}

不错，但是不易读。现在让我们创建一个函数来获取信息：

\begin{lstlisting}[language=Haskell]
  firstName :: Person -> String
  firstName (Person firstName _ _ _ _ _) = firstName

  lastName :: Person -> String
  lastName (Person _ lastname _ _ _ _) = lastname

  age :: Person -> Int
  age (Person _ _ age _ _ _) = age

  height :: Person -> Float
  height (Person _ _ _ height _ _) = height

  phoneNumber :: Person -> String
  phoneNumber (Person _ _ _ _ number _) = number

  flavor :: Person -> String
  flavor (Person _ _ _ _ _ flavor) = flavor
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
  ghci> firstName guy
  "Buddy"
  ghci> height guy
  184.2
  ghci> flavor guy
  "Chocolate"
\end{lstlisting}

现在让我们使用 record syntax：

\begin{lstlisting}[language=Haskell]
  data Person = Person
  { firstName :: String,
    lastName :: String,
    age :: Int,
    height :: Float,
    phoneNumber :: String,
    flavor :: String
  }
  deriving (Show)
\end{lstlisting}

我们通过两个冒号\acode{::}来指定类型。

\begin{lstlisting}[language=Haskell]
  ghci> :t flavor
  flavor :: Person -> String
  ghci> :t firstName
  firstName :: Person -> String
\end{lstlisting}

使用 record syntax 的另一个好处就是为类型派生\acode{Show}时，展示的样子会更方便辨认：

\begin{lstlisting}[language=Haskell]
  data Car = Car String String Int deriving (Show)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> Car "Ford" "Mustang" 1967
  Car "Ford" "Mustang" 1967
\end{lstlisting}

使用 record syntax：

\begin{lstlisting}[language=Haskell]
  data Car = Car {company :: String, model :: String, year :: Int} deriving (Show)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> Car {company="Ford", model="Mustang", year=1967}
  Car {company = "Ford", model = "Mustang", year = 1967}
\end{lstlisting}

\subsection*{类型参数}

一个值构造函数可以接受一些参数然后生产出一个新值。例如\acode{Car}构造函数接受三个值并生产出一个 car 值。
同样的方式，\textbf{类型构造函数 type constructor}接受值作为参数并生成出一个新类型。首先让我们看一下\acode{Maybe}：

\begin{lstlisting}[language=Haskell]
  data Maybe a = Nothing | Just a
\end{lstlisting}

这里的\acode{a}就是一个类型参数，因为类型参数的介入，我们称\acode{Maybe}为一个类型构造函数。取决于我们想要它在不是
\acode{Nothing}时存储的数据类型，该类型构造函数可以生产\acode{Maybe Int}，\acode{Maybe Car}或者是
\acode{Maybe String}等等。

你可能不知道的是，在使用\acode{Maybe}之前，我们使用了一个由类型参数的类型。

\begin{lstlisting}[language=Haskell]
  ghci> Just "Haha"
  Just "Haha"
  ghci> Just 84
  Just 84
  ghci> :t Just "Haha"
  Just "Haha" :: Maybe [Char]
  ghci> :t Just 84
  Just 84 :: (Num t) => Maybe t
  ghci> :t Nothing
  Nothing :: Maybe a
  ghci> Just 10 :: Maybe Double
  Just 10.0
\end{lstlisting}

使用类型参数很方便，不过也得合理的使用。

另一个我们已经遇到过的参数化类型例子就是\acode{Data.Map}中的\acode{Map k v}。如果我们要定义一个 mapping 类型，我们
可以添加一个 typeclass 约束在\textit{数据}声明中：

\begin{lstlisting}[language=Haskell]
data (Ord k) => Map k v = ...
\end{lstlisting}

然而在 Haskell 中，\textbf{永远不要在数据声明中添加 typeclass 约束}，这是一个非常强大的约定。为什么呢？因为我们并不能
从中得到多大的好处，最终还写了更多的类约束，即使我们不需要它们。\acode{Map k v}要是有\acode{Ord k}的约束，那就相当于
假定每个 map 的相关函数都认为 k 是可排序的。如果不给数据类型加约束，那么就不用给不关心键是否可排序的函数另加约束了。这类
函数的一个例子就是\acode{toList}，它只是将 map 转换为关联列表而已，类型声明为\acode{toList :: Map k v -> [(k, v)]}
如果加上类型约束，那就得\acode{toList :: (Ord k) => Map k a -> [(k, v)]}，很明显没有必要这么做。

让我们实现一个 3D 向量类型，并为其添加一些操作。这里使用一个参数化的类型，虽然通常而言包含的是数值类型，不过这样支持了多种
数值类型：

\begin{lstlisting}[language=Haskell]
  data Vector a = Vector a a a deriving (Show)

  vPlus :: (Num t) => Vector t -> Vector t -> Vector t
  (Vector i j k) `vPlus` (Vector l m n) = Vector (i + l) (j + m) (k + n)

  vMult :: (Num t) => Vector t -> t -> Vector t
  (Vector i j k) `vMult` m = Vector (i * m) (j * m) (k * m)

  scalarMult :: (Num t) => Vector t -> Vector t -> t
  (Vector i j k) `scalarMult` (Vector l m n) = i * l + j * m + k * n
\end{lstlisting}

这三个函数可以作用于\acode{Vector Int}，\acode{Vector Integer}以及\acode{Vector Float}类型上，或者是任何满足
\acode{Num} typeclass 的\acode{a}。

再次强调，分辨出类型构造函数还是值构造函数是非常重要的。当定义一个数据类型，\acode{=}之前的部分就是类型构造函数，而之后的
（有可能通过\acode{|}来分隔）则是值构造函数。给这样一个函数类型\acode{Vector t t t -> Vector t t t -> t}是错误的，
因为我们必须将类型放置在类型声明中，且向量的\textbf{类型}构造函数仅接受一个参数，而值构造函数接受三个。

\begin{lstlisting}[language=Haskell]
  ghci> Vector 3 5 8 `vplus` Vector 9 2 8
  Vector 12 7 16
  ghci> Vector 3 5 8 `vplus` Vector 9 2 8 `vplus` Vector 0 2 3
  Vector 12 9 19
  ghci> Vector 3 9 7 `vectMult` 10
  Vector 30 90 70
  ghci> Vector 4 9 5 `scalarMult` Vector 9.0 2.0 4.0
  74.0
  ghci> Vector 2 9 3 `vectMult` (Vector 4 9 5 `scalarMult` Vector 9 2 4)
  Vector 148 666 222
\end{lstlisting}

\subsection*{派生实例}

在 Typeclasses 101 章节中，我们解释了 Typeclasses 的基础，即一种用于定义某些行为的接口。一个类型可以做该 typeclass
的\textbf{instance}，如果该类型支持这些行为。

我们也提到了 typeclasses 有别于 Java，Python，C++ 的类；在这些语言中，类是一个蓝图供我们创建包含了状态与一些行动的对象，
而 Typeclasses 更类似于接口。我们不从 typeclasses 中创造数据，而是先构建数据类型，接着思考其可行的行动。如果它可以像
等式那样行动，那么我们为其构建一个\acode{Eq} typeclass 的实例；如果它可以进行排序，那么我们为其构建一个\acode{Ord}
typeclass 的实例。

下一节中，我们将尝试如何通过实现定义在 typeclasses 里的函数，手动创建我们 typeclasses 的类型实例。不过现在让我们看看
Haskell 是如何自动的将我们的类型创建出以下任何 typeclasses 的实例：\acode{Eq}，\acode{Ord}，\acode{Enum}，
\acode{Bounded}，\acode{Show}，\acode{Read}。当我们使用\textit{deriving} 关键字时，Haskell 可以为我们的类型
派生出这些行为。

\begin{lstlisting}[language=Haskell]
  data Person = Person { firstName :: String
  , lastName :: String
  , age :: Int
  } deriving (Eq)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}
  ghci> let adRock = Person {firstName = "Adam", lastName = "Horovitz", age = 41}
  ghci> let mca = Person {firstName = "Adam", lastName = "Yauch", age = 44}
  ghci> mca == adRock
  False
  ghci> mikeD == adRock
  False
  ghci> mikeD == mikeD
  True
  ghci> mikeD == Person {firstName = "Michael", lastName = "Diamond", age = 43}
  True
\end{lstlisting}

当然了，由于\acode{Person}已经在\acode{Eq}了，我们就可以使用那些有类约束\acode{Eq a}的函数了，例如\acode{elem}：

\begin{lstlisting}[language=Haskell]
  ghci> let beastieBoys = [mca, adRock, mikeD]
  ghci> mikeD `elem` beastieBoys
  True
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  data Person = Person
    { firstName :: String,
      lastName :: String,
      age :: Int
    }
    deriving (Eq, Show, Read)
\end{lstlisting}

在终端上打印：

\begin{lstlisting}[language=Haskell]
  ghci> let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}
  ghci> mikeD
  Person {firstName = "Michael", lastName = "Diamond", age = 43}
  ghci> "mikeD is: " ++ show mikeD
  "mikeD is: Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}"
\end{lstlisting}

\acode{Read}则与\acode{Show}相反：

\begin{lstlisting}[language=Haskell]
  ghci> read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" :: Person
  Person {firstName = "Michael", lastName = "Diamond", age = 43}
\end{lstlisting}

我们可以使用代数数据类型来创建枚举，其中\acode{Enum}以及\acode{Bounded} typeclasses 帮了大忙。
\acode{Enum} typeclass 适用于有前置子和后继子的情况，而\acode{Bounded} typeclass 则代表有最大和最小值。
例如：

\begin{lstlisting}[language=Haskell]
  data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
    deriving (Eq, Ord, Show, Read, Bounded, Enum)
\end{lstlisting}

因为有\acode{Show}与\acode{Read} typeclasses，我们可以将其与字符串互相转换：

\begin{lstlisting}[language=Haskell]
  ghci> Wednesday
  Wednesday
  ghci> show Wednesday
  "Wednesday"
  ghci> read "Saturday" :: Day
  Saturday
\end{lstlisting}

因为有\acode{Eq}与\acode{Ord} typeclasses，我们可以进行比较：

\begin{lstlisting}[language=Haskell]
  ghci> Saturday == Sunday
  False
  ghci> Saturday == Saturday
  True
  ghci> Saturday > Friday
  True
  ghci> Monday `compare` Wednesday
  LT
\end{lstlisting}

又因为有\acode{Bounded}，我们可以得到最大与最小天：

\begin{lstlisting}[language=Haskell]
  ghci> minBound :: Day
  Monday
  ghci> maxBound :: Day
  Sunday
\end{lstlisting}

最后是\acode{Enum}，我们可以使用前置子与后继子：

\begin{lstlisting}[language=Haskell]
  ghci> succ Monday
  Tuesday
  ghci> pred Saturday
  Friday
  ghci> [Thursday .. Sunday]
  [Thursday,Friday,Saturday,Sunday]
  ghci> [minBound .. maxBound] :: [Day]
  [Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]
\end{lstlisting}

非常棒。

\subsection*{类型同义词}

之前我们在讨论类型的时候提到过，\acode{[Char]}和\acode{String}类型是相同的也是可互换的。这是因为实现了
\textbf{类型同义词 type synonyms}。标准库中的定义：

\begin{lstlisting}[language=Haskell]
  type String = [Char]
\end{lstlisting}

这里引入了\textit{type}关键字。由于我们并没有创建新的东西（如\textit{data}关键字），\textit{type}
仅关联已存在的类型的同义词。

\begin{lstlisting}[language=Haskell]
  type PhoneNumber = String
  type Name = String
  type PhoneBook = [(Name,PhoneNumber)]
\end{lstlisting}

现在可以实现一个函数用于接受名字，号码，并检查名字与号码的组合是否存在于号码簿中：

\begin{lstlisting}[language=Haskell]
  inPhoneBook :: Name -> PhoneNumber -> PhoneBook -> Bool
  inPhoneBook name pNumber pBook = (name, pNumber) `elem` pBook
\end{lstlisting}

这里若是没有使用类型同义词，那么函数的签名则会是\acode{String -> String -> [(String,String)] -> Bool}。

类型同义词同样也可以参数化。

\begin{lstlisting}[language=Haskell]
  type AssocList k v = [(k,v)]
\end{lstlisting}

那么通过关联列表中的键获取值的函数类型可以是\acode{(Eq k) => k -> AssocList k v -> Maybe v}。

正如我们可以偏应用函数来获取一个新的函数，我们还可以偏应用类型参数来获取一个新的类型构造函数。正如我们在调用函数时
缺少一些参数会返回一个新的函数，我们可以指定一个类型构造函数部分参数并返回一个偏应用的类型构造函数。如果我们想要
一个整数为键的 map，我们可以这么做：

\begin{lstlisting}[language=Haskell]
  type IntMap v = Map Int v
\end{lstlisting}

或是这样：

\begin{lstlisting}[language=Haskell]
  type IntMap = Map Int
\end{lstlisting}

另外一个酷炫的数据类型是\acode{Either a b}类型，它接受两个类型参数：

\begin{lstlisting}[language=Haskell]
  data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)
\end{lstlisting}

它有两个值构造函数。如果使用了\acode{Left}，那么其内容则是类型\acode{a}，反之则是\acode{b}。因此我们可以封装
一个拥有两种类型的值，然后使用模式匹配进行取值。

\begin{lstlisting}[language=Haskell]
  ghci> Right 20
  Right 20
  ghci> Left "w00t"
  Left "w00t"
  ghci> :t Right 'a'
  Right 'a' :: Either a Char
  ghci> :t Left True
  Left True :: Either Bool b
\end{lstlisting}

一个例子：一个壁橱拥有代码组合，每次申请一个壁橱的代码如果已经存在了，那么需要告知重新选择。这里使用\acode{Data.Map}
来代表壁橱：

\begin{lstlisting}[language=Haskell]
  import Data.Map qualified as Map

  data LockerState = Taken | Free deriving (Show, Eq)

  type Code = String

  type LockerMap = Map.Map Int (LockerState, Code)
\end{lstlisting}

这里引用了一个新的数据类型来代表一个壁橱是否被占用，同时也为壁橱代码设置了一个类型同义词。现在让我们使用
\acode{Either String Code}类型来做为查找函数的返回类型，因为查找可能会以两种原因失败 -- 橱柜已被占用或者是没有该
橱柜。

\begin{lstlisting}[language=Haskell]
  lockerLookup :: Int -> LockerMap -> Either String Code
  lockerLookup lockerNumber map =
    case Map.lookup lockerNumber map of
      Nothing -> Left $ "Locker number " ++ show lockerNumber ++ " doesn't exist!"
      Just (state, code) ->
        if state /= Taken
          then Right code
          else Left $ "Locker " ++ show lockerNumber ++ " is already taken!"
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  lockers :: LockerMap
  lockers =
    Map.fromList
      [ (100, (Taken, "ZD39I")),
        (101, (Free, "JAH3I")),
        (103, (Free, "IQSA9")),
        (105, (Free, "QOTSA")),
        (109, (Taken, "893JJ")),
        (110, (Taken, "99292"))
      ]
\end{lstlisting}

测试一下：

\begin{lstlisting}[language=Haskell]
  ghci> lockerLookup 101 lockers
  Right "JAH3I"
  ghci> lockerLookup 100 lockers
  Left "Locker 100 is already taken!"
  ghci> lockerLookup 102 lockers
  Left "Locker number 102 doesn't exist!"
  ghci> lockerLookup 110 lockers
  Left "Locker 110 is already taken!"
  ghci> lockerLookup 105 lockers
  Right "QOTSA"
\end{lstlisting}

我们当然可以使用\acode{Maybe a}来做结果，不过那样的话就不知道为什么不能拿到代码的原因了，而现在这么做，在拿不到代码的时候
是可以知道是什么原因造成的。

\subsection*{递归数据结构}

% TODO

\subsection*{Typeclasses 102}

% TODO

\subsection*{一个 yes-no typeclass}

% TODO

\subsection*{函子 typeclass}

% TODO

\subsection*{Kinds 以及一些 type-foo}

% TODO

\end{document}
