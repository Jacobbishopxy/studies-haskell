\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{代数数据类型介绍}

迄今为止我们接触到了不少的类型：\acode{Bool}，\acode{Int}，\acode{Char}，\acode{Maybe}等等。但是我们如何构造自己的类型呢？
一种方式是使用\textbf{data}关键字来进行定义。让我们来看一下标准库中的\acode{Bool}是怎么定义的：

\begin{lstlisting}[language=Haskell]
data Bool = False | True
\end{lstlisting}

\textbf{data}意味着正在定义一个新的数据类型。在\acode{=}之前的部分代表着类型，即\acode{Bool}；而之后的部分则是
\textbf{类型构造函数value constructors}。它们指定了类型可变的值，这里的\acode{|}读作\textit{或 or}，因此整句代码可以读作：
\acode{Bool}类型可以是\acode{True}或\acode{False}其中的一个值。

假设这里定义了形状可以是一个圆或是长方形：

\begin{lstlisting}[language=Haskell]
  ghci> data Shape = Circle Float Float Float | Rectangle Float Float Float Float
  ghci> :t Circle
  Circle :: Float -> Float -> Float -> Shape
  ghci> :t Rectangle
  Rectangle :: Float -> Float -> Float -> Float -> Shape
\end{lstlisting}

\acode{Clicle}的值构造函数有三个字段，均接受浮点数；而\acode{Rectangle}的值构造函数有四个字段，均接受浮点数。

值构造函数实际上是最终返回数据类型值的函数。以下是一个接受 shape 并返回 surface 的函数：

\begin{lstlisting}[language=Haskell]
  surface :: Shape -> Float
  surface (Circle _ _ r) = pi * r ^ 2
  surface (Rectangle x1 y1 x2 y2) = abs (x2 - x1) * abs (y2 - y1)
\end{lstlisting}

首先值得注意的是类型声明。我们不能这样\acode{Circle -> Float}因为\acode{Circle}并非一个类型，\acode{Shape}才是。这就像我们
不能编写一个类型声明为\acode{True -> Int}的函数。其次需要注意的是我们不能对构造函数进行模式匹配，之前我们匹配过\acode{[]}，
\acode{False}或是\acode{5}，它们是不包含参数的值构造函数。

\begin{lstlisting}[language=Haskell]
  ghci> surface $ Circle 10 20 10
  314.15927
  ghci> surface $ Rectangle 0 0 100 100
  10000.0
\end{lstlisting}

很好成功了！但是如果我们想要打印出\acode{Circle 10 20 5}，则会得到一个错误。这是因为 Haskell 并不知道该如何将我们的数据类型
转换成字符串，因此我们需要让\acode{Shape}成为\acode{Show} typeclass 的一部分：

\begin{lstlisting}[language=Haskell]
  data Shape = Circle Float Float Float | Rectangle Float Float Float Float deriving (Show)
\end{lstlisting}

值构造函数是函数，因此我们可以映射它们并偏应用至任何东西：

\begin{lstlisting}[language=Haskell]
  ghci> map (Circle 10 20) [4,5,6,6]
  [Circle 10.0 20.0 4.0,Circle 10.0 20.0 5.0,Circle 10.0 20.0 6.0,Circle 10.0 20.0 6.0]
\end{lstlisting}

我们的数据类型很棒，不过可以更棒。定义一个中间类型增强可读性：

\begin{lstlisting}[language=Haskell]
  data Point  = Point Float Float deriving (Show)
  data Shape = Circle Point Float | Rectangle Point Point deriving (Show)
\end{lstlisting}

修改\acode{surface}函数：

\begin{lstlisting}[language=Haskell]
  surface :: Shape -> Float
  surface (Circle _ r) = pi * r ^ 2
  surface (Rectangle (Point x1 y1) (Point x2 y2)) =
    abs (x2 - x1) * abs (y2 - y1)
\end{lstlisting}

调用时需要考虑模式：

\begin{lstlisting}[language=Haskell]
  ghci> surface (Rectangle (Point 0 0) (Point 100 100))
  10000.0
  ghci> surface (Circle (Point 0 0) 24)
  1809.5574
\end{lstlisting}

接下来是\acode{nudge}函数：

\begin{lstlisting}[language=Haskell]
  nudge :: Shape -> Float -> Float -> Shape
  nudge (Circle (Point x y) r) a b = Circle (Point (x + a) (y + b)) r
  nudge (Rectangle (Point x1 y1) (Point x2 y2)) a b =
    Rectangle (Point (x1 + a) (y1 + b)) (Point (x2 + a) (y2 + b))
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> nudge (Circle (Point 34 34) 10) 5 10
  Circle (Point 39.0 44.0) 10.0
\end{lstlisting}

如果我们不想直接处理点，那么可以辅助函数用于创建初始在零点的形状并将其移动至正确点位：

\begin{lstlisting}[language=Haskell]
  baseCircle :: Float -> Shape
  baseCircle = Circle (Point 0 0)

  baseRect :: Float -> Float -> Shape
  baseRect width height = Rectangle (Point 0 0) (Point width height)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> nudge (baseRect 40 100) 60 23
  Rectangle (Point 60.0 23.0) (Point 100.0 123.0)
\end{lstlisting}

如果希望将所有的函数与类型导出（注意类型中使用\acode{..}，下文有解释），那么可以这么做：

\begin{lstlisting}[language=Haskell]
  module Shapes
    ( Point (..),
      Shape (..),
      surface,
      nudge,
      baseCircle,
      baseRect,
    )
  where
\end{lstlisting}

这里的\acode{Shape (..)}导出了所有\acode{Shape}的值构造函数，因此任何加载了该模块的都可以通过\acode{Rectangle}与
\acode{Circle}的值构造函数来创建形状。

当然也可以选择行的不到处任何\acode{Shape}的值构造函数，仅需在导出声明中这样写\acode{Shape}。这样的话加载该模块的仅能
使用辅助函数\acode{baseCircle}与\acode{baseRect}来创建形状。\acode{Data.Map}使用了这个技巧。

不到处数据类型的值构造函数会使得它们更为抽象，因为我们隐层了它们的实现；除此之外，使用该模块的将不再能对其使用模式匹配。

\subsection*{Record Syntax}

现在让我们创造一个用于描述人的数据类型，其中信息包括：名，姓，年龄，身高，体重，电话以及喜爱的冰淇淋类型。

\begin{lstlisting}[language=Haskell]
  data Person = Person String String Int Float String String deriving (Show)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
  ghci> guy
  Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
\end{lstlisting}

不错，但是不易读。现在让我们创建一个函数来获取信息：

\begin{lstlisting}[language=Haskell]
  firstName :: Person -> String
  firstName (Person firstName _ _ _ _ _) = firstName

  lastName :: Person -> String
  lastName (Person _ lastname _ _ _ _) = lastname

  age :: Person -> Int
  age (Person _ _ age _ _ _) = age

  height :: Person -> Float
  height (Person _ _ _ height _ _) = height

  phoneNumber :: Person -> String
  phoneNumber (Person _ _ _ _ number _) = number

  flavor :: Person -> String
  flavor (Person _ _ _ _ _ flavor) = flavor
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> let guy = Person "Buddy" "Finklestein" 43 184.2 "526-2928" "Chocolate"
  ghci> firstName guy
  "Buddy"
  ghci> height guy
  184.2
  ghci> flavor guy
  "Chocolate"
\end{lstlisting}

现在让我们使用 record syntax：

\begin{lstlisting}[language=Haskell]
  data Person = Person
  { firstName :: String,
    lastName :: String,
    age :: Int,
    height :: Float,
    phoneNumber :: String,
    flavor :: String
  }
  deriving (Show)
\end{lstlisting}

我们通过两个冒号\acode{::}来指定类型。

\begin{lstlisting}[language=Haskell]
  ghci> :t flavor
  flavor :: Person -> String
  ghci> :t firstName
  firstName :: Person -> String
\end{lstlisting}

使用 record syntax 的另一个好处就是为类型派生\acode{Show}时，展示的样子会更方便辨认：

\begin{lstlisting}[language=Haskell]
  data Car = Car String String Int deriving (Show)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> Car "Ford" "Mustang" 1967
  Car "Ford" "Mustang" 1967
\end{lstlisting}

使用 record syntax：

\begin{lstlisting}[language=Haskell]
  data Car = Car {company :: String, model :: String, year :: Int} deriving (Show)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> Car {company="Ford", model="Mustang", year=1967}
  Car {company = "Ford", model = "Mustang", year = 1967}
\end{lstlisting}

\subsection*{类型参数}

一个值构造函数可以接受一些参数然后生产出一个新值。例如\acode{Car}构造函数接受三个值并生产出一个 car 值。
同样的方式，\textbf{类型构造函数 type constructor}接受值作为参数并生成出一个新类型。首先让我们看一下\acode{Maybe}：

\begin{lstlisting}[language=Haskell]
  data Maybe a = Nothing | Just a
\end{lstlisting}

这里的\acode{a}就是一个类型参数，因为类型参数的介入，我们称\acode{Maybe}为一个类型构造函数。取决于我们想要它在不是
\acode{Nothing}时存储的数据类型，该类型构造函数可以生产\acode{Maybe Int}，\acode{Maybe Car}或者是
\acode{Maybe String}等等。

你可能不知道的是，在使用\acode{Maybe}之前，我们使用了一个由类型参数的类型。

\begin{lstlisting}[language=Haskell]
  ghci> Just "Haha"
  Just "Haha"
  ghci> Just 84
  Just 84
  ghci> :t Just "Haha"
  Just "Haha" :: Maybe [Char]
  ghci> :t Just 84
  Just 84 :: (Num t) => Maybe t
  ghci> :t Nothing
  Nothing :: Maybe a
  ghci> Just 10 :: Maybe Double
  Just 10.0
\end{lstlisting}

使用类型参数很方便，不过也得合理的使用。

另一个我们已经遇到过的参数化类型例子就是\acode{Data.Map}中的\acode{Map k v}。如果我们要定义一个 mapping 类型，我们
可以添加一个 typeclass 约束在\textit{数据}声明中：

\begin{lstlisting}[language=Haskell]
data (Ord k) => Map k v = ...
\end{lstlisting}

然而在 Haskell 中，\textbf{永远不要在数据声明中添加 typeclass 约束}，这是一个非常强大的约定。为什么呢？因为我们并不能
从中得到多大的好处，最终还写了更多的类约束，即使我们不需要它们。\acode{Map k v}要是有\acode{Ord k}的约束，那就相当于
假定每个 map 的相关函数都认为 k 是可排序的。如果不给数据类型加约束，那么就不用给不关心键是否可排序的函数另加约束了。这类
函数的一个例子就是\acode{toList}，它只是将 map 转换为关联列表而已，类型声明为\acode{toList :: Map k v -> [(k, v)]}
如果加上类型约束，那就得\acode{toList :: (Ord k) => Map k a -> [(k, v)]}，很明显没有必要这么做。

让我们实现一个 3D 向量类型，并为其添加一些操作。这里使用一个参数化的类型，虽然通常而言包含的是数值类型，不过这样支持了多种
数值类型：

\begin{lstlisting}[language=Haskell]
  data Vector a = Vector a a a deriving (Show)

  vPlus :: (Num t) => Vector t -> Vector t -> Vector t
  (Vector i j k) `vPlus` (Vector l m n) = Vector (i + l) (j + m) (k + n)

  vMult :: (Num t) => Vector t -> t -> Vector t
  (Vector i j k) `vMult` m = Vector (i * m) (j * m) (k * m)

  scalarMult :: (Num t) => Vector t -> Vector t -> t
  (Vector i j k) `scalarMult` (Vector l m n) = i * l + j * m + k * n
\end{lstlisting}

这三个函数可以作用于\acode{Vector Int}，\acode{Vector Integer}以及\acode{Vector Float}类型上，或者是任何满足
\acode{Num} typeclass 的\acode{a}。

再次强调，分辨出类型构造函数还是值构造函数是非常重要的。当定义一个数据类型，\acode{=}之前的部分就是类型构造函数，而之后的
（有可能通过\acode{|}来分隔）则是值构造函数。给这样一个函数类型\acode{Vector t t t -> Vector t t t -> t}是错误的，
因为我们必须将类型放置在类型声明中，且向量的\textbf{类型}构造函数仅接受一个参数，而值构造函数接受三个。

\begin{lstlisting}[language=Haskell]
  ghci> Vector 3 5 8 `vplus` Vector 9 2 8
  Vector 12 7 16
  ghci> Vector 3 5 8 `vplus` Vector 9 2 8 `vplus` Vector 0 2 3
  Vector 12 9 19
  ghci> Vector 3 9 7 `vectMult` 10
  Vector 30 90 70
  ghci> Vector 4 9 5 `scalarMult` Vector 9.0 2.0 4.0
  74.0
  ghci> Vector 2 9 3 `vectMult` (Vector 4 9 5 `scalarMult` Vector 9 2 4)
  Vector 148 666 222
\end{lstlisting}

\subsection*{派生实例}

在 Typeclasses 101 章节中，我们解释了 Typeclasses 的基础，即一种用于定义某些行为的接口。一个类型可以做该 typeclass
的\textbf{instance}，如果该类型支持这些行为。

我们也提到了 typeclasses 有别于 Java，Python，C++ 的类；在这些语言中，类是一个蓝图供我们创建包含了状态与一些行动的对象，
而 Typeclasses 更类似于接口。我们不从 typeclasses 中创造数据，而是先构建数据类型，接着思考其可行的行动。如果它可以像
等式那样行动，那么我们为其构建一个\acode{Eq} typeclass 的实例；如果它可以进行排序，那么我们为其构建一个\acode{Ord}
typeclass 的实例。

下一节中，我们将尝试如何通过实现定义在 typeclasses 里的函数，手动创建我们 typeclasses 的类型实例。不过现在让我们看看
Haskell 是如何自动的将我们的类型创建出以下任何 typeclasses 的实例：\acode{Eq}，\acode{Ord}，\acode{Enum}，
\acode{Bounded}，\acode{Show}，\acode{Read}。当我们使用\textit{deriving} 关键字时，Haskell 可以为我们的类型
派生出这些行为。

\begin{lstlisting}[language=Haskell]
  data Person = Person { firstName :: String
  , lastName :: String
  , age :: Int
  } deriving (Eq)
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  ghci> let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}
  ghci> let adRock = Person {firstName = "Adam", lastName = "Horovitz", age = 41}
  ghci> let mca = Person {firstName = "Adam", lastName = "Yauch", age = 44}
  ghci> mca == adRock
  False
  ghci> mikeD == adRock
  False
  ghci> mikeD == mikeD
  True
  ghci> mikeD == Person {firstName = "Michael", lastName = "Diamond", age = 43}
  True
\end{lstlisting}

当然了，由于\acode{Person}已经在\acode{Eq}了，我们就可以使用那些有类约束\acode{Eq a}的函数了，例如\acode{elem}：

\begin{lstlisting}[language=Haskell]
  ghci> let beastieBoys = [mca, adRock, mikeD]
  ghci> mikeD `elem` beastieBoys
  True
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  data Person = Person
    { firstName :: String,
      lastName :: String,
      age :: Int
    }
    deriving (Eq, Show, Read)
\end{lstlisting}

在终端上打印：

\begin{lstlisting}[language=Haskell]
  ghci> let mikeD = Person {firstName = "Michael", lastName = "Diamond", age = 43}
  ghci> mikeD
  Person {firstName = "Michael", lastName = "Diamond", age = 43}
  ghci> "mikeD is: " ++ show mikeD
  "mikeD is: Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}"
\end{lstlisting}

\acode{Read}则与\acode{Show}相反：

\begin{lstlisting}[language=Haskell]
  ghci> read "Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}" :: Person
  Person {firstName = "Michael", lastName = "Diamond", age = 43}
\end{lstlisting}

我们可以使用代数数据类型来创建枚举，其中\acode{Enum}以及\acode{Bounded} typeclasses 帮了大忙。
\acode{Enum} typeclass 适用于有前置子和后继子的情况，而\acode{Bounded} typeclass 则代表有最大和最小值。
例如：

\begin{lstlisting}[language=Haskell]
  data Day = Monday | Tuesday | Wednesday | Thursday | Friday | Saturday | Sunday
    deriving (Eq, Ord, Show, Read, Bounded, Enum)
\end{lstlisting}

因为有\acode{Show}与\acode{Read} typeclasses，我们可以将其与字符串互相转换：

\begin{lstlisting}[language=Haskell]
  ghci> Wednesday
  Wednesday
  ghci> show Wednesday
  "Wednesday"
  ghci> read "Saturday" :: Day
  Saturday
\end{lstlisting}

因为有\acode{Eq}与\acode{Ord} typeclasses，我们可以进行比较：

\begin{lstlisting}[language=Haskell]
  ghci> Saturday == Sunday
  False
  ghci> Saturday == Saturday
  True
  ghci> Saturday > Friday
  True
  ghci> Monday `compare` Wednesday
  LT
\end{lstlisting}

又因为有\acode{Bounded}，我们可以得到最大与最小天：

\begin{lstlisting}[language=Haskell]
  ghci> minBound :: Day
  Monday
  ghci> maxBound :: Day
  Sunday
\end{lstlisting}

最后是\acode{Enum}，我们可以使用前置子与后继子：

\begin{lstlisting}[language=Haskell]
  ghci> succ Monday
  Tuesday
  ghci> pred Saturday
  Friday
  ghci> [Thursday .. Sunday]
  [Thursday,Friday,Saturday,Sunday]
  ghci> [minBound .. maxBound] :: [Day]
  [Monday,Tuesday,Wednesday,Thursday,Friday,Saturday,Sunday]
\end{lstlisting}

非常棒。

\subsection*{类型同义词}

之前我们在讨论类型的时候提到过，\acode{[Char]}和\acode{String}类型是相同的也是可互换的。这是因为实现了
\textbf{类型同义词 type synonyms}。标准库中的定义：

\begin{lstlisting}[language=Haskell]
  type String = [Char]
\end{lstlisting}

这里引入了\textit{type}关键字。由于我们并没有创建新的东西（如\textit{data}关键字），\textit{type}
仅关联已存在的类型的同义词。

\begin{lstlisting}[language=Haskell]
  type PhoneNumber = String
  type Name = String
  type PhoneBook = [(Name,PhoneNumber)]
\end{lstlisting}

现在可以实现一个函数用于接受名字，号码，并检查名字与号码的组合是否存在于号码簿中：

\begin{lstlisting}[language=Haskell]
  inPhoneBook :: Name -> PhoneNumber -> PhoneBook -> Bool
  inPhoneBook name pNumber pBook = (name, pNumber) `elem` pBook
\end{lstlisting}

这里若是没有使用类型同义词，那么函数的签名则会是\acode{String -> String -> [(String,String)] -> Bool}。

类型同义词同样也可以参数化。

\begin{lstlisting}[language=Haskell]
  type AssocList k v = [(k,v)]
\end{lstlisting}

那么通过关联列表中的键获取值的函数类型可以是\acode{(Eq k) => k -> AssocList k v -> Maybe v}。

正如我们可以偏应用函数来获取一个新的函数，我们还可以偏应用类型参数来获取一个新的类型构造函数。正如我们在调用函数时
缺少一些参数会返回一个新的函数，我们可以指定一个类型构造函数部分参数并返回一个偏应用的类型构造函数。如果我们想要
一个整数为键的 map，我们可以这么做：

\begin{lstlisting}[language=Haskell]
  type IntMap v = Map Int v
\end{lstlisting}

或是这样：

\begin{lstlisting}[language=Haskell]
  type IntMap = Map Int
\end{lstlisting}

另外一个酷炫的数据类型是\acode{Either a b}类型，它接受两个类型参数：

\begin{lstlisting}[language=Haskell]
  data Either a b = Left a | Right b deriving (Eq, Ord, Read, Show)
\end{lstlisting}

它有两个值构造函数。如果使用了\acode{Left}，那么其内容则是类型\acode{a}，反之则是\acode{b}。因此我们可以封装
一个拥有两种类型的值，然后使用模式匹配进行取值。

\begin{lstlisting}[language=Haskell]
  ghci> Right 20
  Right 20
  ghci> Left "w00t"
  Left "w00t"
  ghci> :t Right 'a'
  Right 'a' :: Either a Char
  ghci> :t Left True
  Left True :: Either Bool b
\end{lstlisting}

一个例子：一个壁橱拥有代码组合，每次申请一个壁橱的代码如果已经存在了，那么需要告知重新选择。这里使用\acode{Data.Map}
来代表壁橱：

\begin{lstlisting}[language=Haskell]
  import Data.Map qualified as Map

  data LockerState = Taken | Free deriving (Show, Eq)

  type Code = String

  type LockerMap = Map.Map Int (LockerState, Code)
\end{lstlisting}

这里引用了一个新的数据类型来代表一个壁橱是否被占用，同时也为壁橱代码设置了一个类型同义词。现在让我们使用
\acode{Either String Code}类型来做为查找函数的返回类型，因为查找可能会以两种原因失败 -- 橱柜已被占用或者是没有该
橱柜。

\begin{lstlisting}[language=Haskell]
  lockerLookup :: Int -> LockerMap -> Either String Code
  lockerLookup lockerNumber map =
    case Map.lookup lockerNumber map of
      Nothing -> Left $ "Locker number " ++ show lockerNumber ++ " doesn't exist!"
      Just (state, code) ->
        if state /= Taken
          then Right code
          else Left $ "Locker " ++ show lockerNumber ++ " is already taken!"
\end{lstlisting}

\begin{lstlisting}[language=Haskell]
  lockers :: LockerMap
  lockers =
    Map.fromList
      [ (100, (Taken, "ZD39I")),
        (101, (Free, "JAH3I")),
        (103, (Free, "IQSA9")),
        (105, (Free, "QOTSA")),
        (109, (Taken, "893JJ")),
        (110, (Taken, "99292"))
      ]
\end{lstlisting}

测试一下：

\begin{lstlisting}[language=Haskell]
  ghci> lockerLookup 101 lockers
  Right "JAH3I"
  ghci> lockerLookup 100 lockers
  Left "Locker 100 is already taken!"
  ghci> lockerLookup 102 lockers
  Left "Locker number 102 doesn't exist!"
  ghci> lockerLookup 110 lockers
  Left "Locker 110 is already taken!"
  ghci> lockerLookup 105 lockers
  Right "QOTSA"
\end{lstlisting}

我们当然可以使用\acode{Maybe a}来做结果，不过那样的话就不知道为什么不能拿到代码的原因了，而现在这么做，在拿不到代码的时候
是可以知道是什么原因造成的。

\subsection*{递归数据结构}

正如我们所见，代数数据类型中的构造函数可以有多个（或零）字段，每个字段必须是某些实际类型。有了这个概念，我们构建的类型可以
以自身类型为字段！

试想一下列表：\acode{[5]}。这是一个关于\acode{5:[]}的语法糖。\acode{:}的左侧是一个值，而右侧则是一个列表，
且这个列表是空的。那么\acode{[4,5]}呢？去掉语法糖后就是\acode{4:(5:[])}。观察第一个\acode{:}，其左侧为一个元素，
而右侧是一个列表\acode{5:[]}。以此类推，\acode{3:(4:(5:6:[]))}，可以写作\acode{3:4:5:6:[]}
（因为\acode{:}是右结合的）或者是\acode{[3,5,6,7]}。

我们可以说一个列表既能是一个空列表或者是一个与其它列表（无论是否为空列表）用\acode{:}所关联的元素。

现在让我们用代数数据类型来实现我们自己的列表！

\begin{lstlisting}[language=Haskell]
  data List a = Empty | Cons a (List a) deriving (Show, Read, Eq, Ord)
\end{lstlisting}

这读起来就像是列表的定义，要么是一个空列表要么是一个头与别的列表的组合。如果感到困惑，那么可以尝试用 record syntax 来理解：

\begin{lstlisting}[language=Haskell]
  data List a = Empty | Cons { listHead :: a, listTail :: List a} deriving (Show, Read, Eq, Ord)
\end{lstlisting}

这里可能也会对\acode{Cons}构造函数感到困惑。\textit{cons}就是\acode{:}，在列表中，\acode{:}实际上就是一个构造函数，
其接受一个值与另一个列表，并返回一个列表。尝试一下：

\begin{lstlisting}[language=Haskell]
  ghci> Empty
  Empty
  ghci> 5 `Cons` Empty
  Cons 5 Empty
  ghci> 4 `Cons` (5 `Cons` Empty)
  Cons 4 (Cons 5 Empty)
  ghci> 3 `Cons` (4 `Cons` (5 `Cons` Empty))
  Cons 3 (Cons 4 (Cons 5 Empty))
\end{lstlisting}

我们可以只用特殊字符来定义函数，这样它们就会自动获得中缀的性质。同样可以使用在构造函数上，因为它们也是返回一个数据类型的函数。
看看这个：

\begin{lstlisting}[language=Haskell]
  infixr 5 :-:
  data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
\end{lstlisting}

首先我们注意到一个新的语法结构，fixity 声明。当我们定义函数为操作符时，我们可以使用 fixity 来指定（但是不是必须的）。一个
fixity 指定了是左结合还是右结合的，同时还有优先级。比如\acode{*}的 fixity 是\acode{infixl 7 *}，而\acode{+}的
fixity 是\acode{infixl 6}，说明它们都是左结合的。

现在可以这样\acode{a :-: (List a)}而不用\acode{Cons a (List a)}。那么我们的列表可以这样写：

\begin{lstlisting}[language=Haskell]
  ghci> :{
  ghci| infixr 5 :-:
  ghci|
  ghci| data List a = Empty | a :-: (List a) deriving (Show, Read, Eq, Ord)
  ghci| :}
  ghci> 3 :-: 4 :-: 5 :-: Empty
  3 :-: (4 :-: (5 :-: Empty))
  ghci> let a = 3 :-: 4 :-: 5 :-: Empty
  ghci> 100 :-: a
  100 :-: (3 :-: (4 :-: (5 :-: Empty)))
\end{lstlisting}

现在来定义一个两列表加法的函数。这里是\acode{++}在普通列表中的定义：

\begin{lstlisting}[language=Haskell]
  infixr 5
  (++) :: [a] -> [a] -> [a]
  []     ++ ys = ys
  (x:xs) ++ ys = x : (xs ++ ys)
\end{lstlisting}

我们偷过来使用，这里命名为\acode{.++}：

\begin{lstlisting}[language=Haskell]
  infixr 5 .++

  (.++) :: List a -> List a -> List a
  Empty .++ ys = ys
  (x :-: xs) .++ ys = x :-: (xs .++ ys)
\end{lstlisting}

测试：

\begin{lstlisting}[language=Haskell]
  ghci> let a = 3 :-: 4 :-: 5 :-: Empty
  ghci> let b = 6 :-: 7 :-: Empty
  ghci> a .++ b
  (:-:) 3 ((:-:) 4 ((:-:) 5 ((:-:) 6 ((:-:) 7 Empty))))
\end{lstlisting}

注意这里是如何在\acode{(x :-: xs)}上模式匹配的，这是因为模式匹配本身是去匹配构造函数。这里可能匹配\acode{:-:}是因为
它是我们自设的列表类型的构造函数，我们也可以匹配\acode{:}，因为它是 Haskell 列表内置的构造函数。

现在我们开始实现一个\textbf{二叉搜索树 binary search tree}。

从\acode{Data.Set}与\acode{Data.Map}而来的 sets 与 maps 就是用了树来实现的，不过不是普通的二叉搜索树，而是平衡二叉树。

一个树可以是空树或者是一个元素，其中包含了一些信息以及两个树。这听起来很适合代数数据类型！

\begin{lstlisting}[language=Haskell]
  data Tree a = EmptyTree | Node a (Tree a) (Tree a) deriving (Show, Read, Eq)
\end{lstlisting}

接下来是两个构建树的函数：

\begin{lstlisting}[language=Haskell]
  singleton :: a -> Tree a
  singleton x = Node x EmptyTree EmptyTree

  treeInsert :: (Ord a) => a -> Tree a -> Tree a
  treeInsert x EmptyTree = singleton x
  treeInsert x (Node a left right)
    | x == a = Node x left right
    | x < a = Node a (treeInsert x left) right
    | x > a = Node a left (treeInsert x right)
\end{lstlisting}

接下来是查看元素是否存在于树中的函数：

\begin{lstlisting}[language=Haskell]
  treeElem :: (Ord a) => a -> Tree a -> Bool
  treeElem x EmptyTree = False
  treeElem x (Node a left right)
    | x == a = True
    | x < a = treeElem x left
    | x > a = treeElem x right
\end{lstlisting}

测试：

\begin{lstlisting}[language=Haskell]
  ghci> let nums = [8,6,4,1,7,3,5]
  ghci> let numsTree = foldr treeInsert EmptyTree nums
  ghci> numsTree
  Node 5 (Node 3 (Node 1 EmptyTree EmptyTree) (Node 4 EmptyTree EmptyTree)) (Node 7 (Node 6 EmptyTree EmptyTree) (Node 8 EmptyTree EmptyTree))
\end{lstlisting}

在这个\acode{foldr}中，\acode{treeInsert}是被接受的函数，\acode{EmptyTree}是初始的累加器，而\acode{nums}
则是需要遍历的列表。

再来查看元素：

\begin{lstlisting}[language=Haskell]
  ghci> 8 `treeElem` numsTree
  True
  ghci> 100 `treeElem` numsTree
  False
  ghci> 1 `treeElem` numsTree
  True
  ghci> 10 `treeElem` numsTree
  False
\end{lstlisting}

\subsection*{Typeclasses 102}

这里是标准库中\acode{Eq}的定义：

\begin{lstlisting}[language=Haskell]
  class Eq a where
  (==) :: a -> a -> Bool
  (/=) :: a -> a -> Bool
  x == y = not (x /= y)
  x /= y = not (x == y)
\end{lstlisting}

哇！新的语法和关键字！不要紧，马上会弄清楚。首先当写下\acode{class Eq a where}时，意味着正在定义一个新的名为\acode{Eq}
的 typeclass。这里的\acode{a}是类型变量，意为\acode{a}是任何定义实例时的类型，并不一定要叫做\acode{a}，只需要是小写字母。
接着定义了几个函数，并不一定要实现函数体，只需要指定这些函数的类型声明。

一旦有了一个类，就可以实现该类的类型实例，首先是一个类型：

\begin{lstlisting}[language=Haskell]
  data TrafficLight = Red | Yellow | Green
\end{lstlisting}

接着来实现\acode{Eq}的实例：

\begin{lstlisting}[language=Haskell]
  instance Eq TrafficLight where
    Red == Red = True
    Green == Green = True
    Yellow == Yellow = True
    _ == _ = False
\end{lstlisting}

这里使用了\textit{instance}关键字。与定义类时不同的是，我们用\acode{TrafficLight}这个时机类型替换了参数\acode{a}。

由于\acode{==}是用\acode{/=}来定义的，同样的\acode{/=}也是用\acode{==}来定义的。因此我们只需要在实例的定义中复写
其中一个就好了（我们复写了\acode{==}）。这样叫做定义了一个最小完整定义，即是能让类型符合类行为所需的最小实例化函数数量。
而如果\acode{Eq}的定义像是这样：

\begin{lstlisting}[language=Haskell]
  class Eq a where
    (==) :: a -> a -> Bool
    (/=) :: a -> a -> Bool
\end{lstlisting}

那么我们在定义实例的时候就必须将两个函数都实例化，因为 Haskell 并不知道这两个函数是怎么关联在一起的。所以这里的最小完整定义
是\acode{==}与\acode{/=}。

接下来是\acode{Show}的实例。

\begin{lstlisting}[language=Haskell]
  instance Show TrafficLight where
    show Red = "Red light"
    show Yellow = "Yellow light"
    show Green = "Green light"
\end{lstlisting}

测试：

\begin{lstlisting}[language=Haskell]
  ghci> Red == Red
  True
  ghci> Red == Yellow
  False
  ghci> Red `elem` [Red, Yellow, Green]
  True
  ghci> [Red, Yellow, Green]
  [Red light,Yellow light,Green light]
\end{lstlisting}

当我们使用\acode{deriving}关键字来自动生产\acode{Eq}，那么效果是一样的；但是生产\acode{Show}的话，Haskell 会将
值构造函数转换成字符串。我们需要的类似于\acode{"Red light"}这样的字符串，因此才需要手动进行实现。

我们也可以把 typeclass 定义成其它 typeclass 的子类。\acode{Num}的类声明很冗长，我们先看一个雏形：

\begin{lstlisting}[language=Haskell]
  class (Eq a) => Num a where
  ...
\end{lstlisting}

正如我们之前提到过的，我们可以在很多地方加上类约束。这里是在\acode{class Num a where}中的\acode{a}上，加上就必须
满足\acode{Eq}实例的限制。也就是说我们在定义一个类型为\acode{Num}之前，必须先为其定义\acode{Eq}的实例。在某个
类型被视为\acode{Number}之前，必须先被定义可以比较，这其实很合理。这就是子类在做的：帮助类声明加上限制。也就是说，
在定义 typeclass 中的函数体是，我们可以默认\acode{a}是属于\acode{Eq}的，因此能使用\acode{==}。

% TODO

% \begin{lstlisting}[language=Haskell]

% \end{lstlisting}

% \begin{lstlisting}[language=Haskell]

% \end{lstlisting}

% \begin{lstlisting}[language=Haskell]

% \end{lstlisting}

\subsection*{一个 yes-no typeclass}

% TODO

\subsection*{函子 typeclass}

% TODO

\subsection*{Kinds 以及一些 type-foo}

% TODO

\end{document}
