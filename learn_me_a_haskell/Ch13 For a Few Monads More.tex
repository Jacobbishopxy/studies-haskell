\documentclass[./main.tex]{subfiles}

\begin{document}

\subsection*{Writer 单子}

我们已经见识过了\acode{Maybe}，列表以及\acode{IO}单子，现在让我们看看\acode{Writer}单子。

相较于\acode{Maybe}用作于将值置入可能失败的 context 中，以及列表用作于非确定性的 context，\acode{Writer}单子
则是用作于将值置入一个附加值的 context 中，类似于日志。\acode{Writer}可以让我们在计算的同时收集所有日志记录，并将
它们合并成一个日志并附加在结果上。

例如我们想要将我们的值附加在字符串上用于解释事情的经过，亦或许是调试的目的。考虑一个函数接受一个值并返回一个布尔值：

\begin{lstlisting}[language=Haskell]
  isBigGang :: Int -> Bool
  isBigGang x = x > 9
\end{lstlisting}

如果想要不止是\acode{True}或\acode{False}值，还想要一段解释应该怎么办呢？

\begin{lstlisting}[language=Haskell]
  isBigGang :: Int -> (Bool, String)
  isBigGang x = (x > 9, "Compared gang size to 9.")
\end{lstlisting}

相较于返回一个\acode{Bool}，我们返回的是一个元组，其中第二个值为解释信息。

\begin{lstlisting}[language=Haskell]
  ghci> isBigGang 3
  (False,"Compared gang size to 9.")
  ghci> isBigGang 30
  (True,"Compared gang size to 9.")
\end{lstlisting}

那么如果我们有一个函数接受的是普通值，同时返回的是代用 context 的值，那么我们应该如何接受一个带有 context 的值，并将其
喂给这个普通函数呢？

当我们在探索\acode{Maybe}单子时，我们曾编写了\acode{applyMaybe}函数，即接受一个\acode{Maybe a}值，以及一个类型为
\acode{a -> Maybe b}的函数，并将\acode{Maybe a}值喂给该函数，即使该函数接受的是一个普通的\acode{a}而不是一个
\acode{Maybe a}。\acode{applyMaybe}考虑到了 context 的处理，也就是会注意可能失败的场景，而在\acode{a -> Maybe b}
中，只需处理普通的数即可。因为\acode{applyMaybe}（之后变成了\acode{>>=}）会帮忙检查\acode{Nothing}或\acode{Just}
的情况。

以同样的方式，再编写一个接受值以及附加日志的函数，也就是一个\acode{(a, String)}值，以及一个\acode{a -> (b,String)}
类型的函数，最后将值喂给函数。该函数有的 context 是附加日志值，而不是一个可能失败的 context，因此原有的日志会被保留，
并附上从函数产生的新的日志：

\begin{lstlisting}[language=Haskell]
  applyLog :: (a,String) -> (a -> (b,String)) -> (b,String)
  applyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog)
\end{lstlisting}

当我们拥有一个带有 context 的值并想将其喂给一个函数，我们通常会试着将值从 context 中剥离，然后再将其应用至函数并检查该
context 注重的是什么。在\acode{Maybe}单子中，我们检查是否为一个\acode{Just x}，如果是则将函数应用至\acode{x}。
而在日志的情况，我们知道元组的其中一部分是值另一部分是日志，因此我们先取出值\acode{x}，将\acode{f}应用至\acode{x}，
得到\acode{(y,newLog)}，其中\acode{y}是新的值而\acode{newLog}则是新的日志。不过如果返回的是\acode{newLog}，
那么并没有包含旧的日志，因此需要返回的是\acode{(y, log ++ newLog)}：

\begin{lstlisting}[language=Haskell]
  ghci> (3, "Smallish gang.") `applyLog` isBigGang
  (False,"Smallish gang.Compared gang size to 9")
  ghci> (30, "A freaking platoon.") `applyLog` isBigGang
  (True,"A freaking platoon.Compared gang size to 9")
  ghci> ("Tobin","Got outlaw name.") `applyLog` (\x -> (length x, "Applied length."))
  (5,"Got outlaw name.Applied length.")
  ghci> ("Bathcat","Got outlaw name.") `applyLog` (\x -> (length x, "Applied length"))
  (7,"Got outlaw name.Applied length")
\end{lstlisting}

看一下 lambda 里是什么情况，\acode{x}是一个普通字符串而不是一个元组，\acode{applyLog}用于追加日志。

\subsubsection*{幺半群来拯救我们}

现在的\acode{applyLog}从\acode{(a, String)}类型中获取值，但是日志就必须是一个\acode{String}吗？它使用\acode{++}
来追加日志，那么这不应该适用于所有列表而不单单只是字符列表么？当然是，现在改变一下类型：

\begin{lstlisting}[language=Haskell]
  applyLog :: (a, [c]) -> (a -> (b, [c])) -> (b, [c])
\end{lstlisting}

那么这对 bytestring 有效吗？当然，不过现在生效的只能是列表。看起来我们需要构建为 bytestring 另一个\acode{applyLog}。
不过等等！列表和 bytestring 都是幺半群。同样的，它们都是\acode{Monoid} typeclass 的实例，这就意味着它们都实现了
\acode{mappend}函数。那么无论是对于列表还是 bytestring 而言，\acode{mappend}正是用作于追加值。

\begin{lstlisting}[language=Haskell]
  ghci> [1,2,3] `mappend` [4,5,6]
  [1,2,3,4,5,6]
  ghci> B.pack [99,104,105] `mappend` B.pack [104,117,97,104,117,97]
  Chunk "chi" (Chunk "huahua" Empty)
\end{lstlisting}

棒！那么现在我们的\acode{applyLog}就能为任意幺半群工作了。修改一下实现，将\acode{++}替换为\acode{mappend}：

\begin{lstlisting}[language=Haskell]
  applyLog :: (Monoid m) => (a, m) -> (a -> (b, m)) -> (b, m)
  applyLog (x, log) f = let (y, newLog) = f x in (y, log `mappend` newLog)
\end{lstlisting}

由于包含值现在可以是任意幺半群，我们不再需要把一个元组想成一个值以及一个日志，而是一个值与一个幺半群的值。例如我们可以有一个
元组包含了一个物品名称以及其作为幺半群的价格。我们只需要使用\acode{Sum} newtype 来确保价格可以被求和。

\begin{lstlisting}[language=Haskell]
  import Data.Monoid
  type Food = String

  type Price = Sum Int

  addDrink :: Food -> (Food, Price)
  addDrink "beans" = ("milk", Sum 25)
  addDrink "jerky" = ("whiskey", Sum 99)
  addDrink _ = ("beer", Sum 30)
\end{lstlisting}

我们用字符串来代表事务，以及\acode{Sum}的\acode{Int}作为\acode{newtype}用于追踪总花销。提醒一下，对\acode{Sum}进行
\acode{mappend}可以将它们加总在一起：

\begin{lstlisting}[language=Haskell]
  ghci> Sum 3 `mappend` Sum 9
  Sum {getSum = 12}
\end{lstlisting}

通过\acode{applyLog}将价格进行求和：

\begin{lstlisting}[language=Haskell]
  ghci> ("beans", Sum 10) `applyLog` addDrink
  ("milk",Sum {getSum = 35})
  ghci> ("jerky", Sum 25) `applyLog` addDrink
  ("whiskey",Sum {getSum = 124})
  ghci> ("meat", Sum 5) `applyLog` addDrink
  ("beer",Sum {getSum = 35})
\end{lstlisting}

由于\acode{addDrink}返回的是类型为\acode{(Food,Price)}的元组，那么可以继续应用\acode{addDrink}在返回值上：

\begin{lstlisting}[language=Haskell]
  ghci> ("meat", Sum 5) `applyLog` addDrink `applyLog` addDrink
  ("beer",Sum {getSum = 65})
\end{lstlisting}

\subsubsection*{Writer 类型}

我们已经看到了一个值与一个幺半群可以像一个幺半群值那样运作，再测试一下\acode{Monad}实例。\acode{Control.Monad.Writer}
模块中提供了\acode{Writer w a}类型，连同其\acode{Monad}的实例，以及一些处理这个类型的函数。

首先是这个类型本身：

\begin{lstlisting}[language=Haskell]
  newtype Writer w a = Writer { runWriter :: (a, w) }
\end{lstlisting}

通过\acode{newtype}包裹使其成为\acode{Monad}的一个实例，同时其类型又有别于普通的元组。其中\acode{a}类型参数代表着值，
而\acode{w}类型参数代表附加的幺半群值。

其\acode{Monad}实例定义如下：

\begin{lstlisting}[language=Haskell]
  instance (Monoid w) => Monad (Writer w) where
    return x = Writer (x, mempty)
    (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')
\end{lstlisting}

首先解释一下\acode{>>=}，它的实现基本上等同于\acode{applyLog}，只不过现在的元组是包裹在\acode{Writer}的
\acode{newtype}中，我们需要模式匹配将其解包。首先将函数\acode{f}应用在\acode{x}上，得到一个\acode{Writer w a}值，
接着用一个\acode{let}表达式进行模式匹配。再将\acode{y}作为新结果，并使用\acode{mappend}将旧的幺半群值与新值结合。
最后的返回值则用\acode{Writer}构造函数打包起来的元组。

那\acode{return}呢？回忆一下\acode{return}的作用是接受一个值，并返回一个最小默认的 context 来包装我们的值。
那么究竟是什么样的 context 能代表 \acode{Writer} 呢？如果我们希望幺半群值所造成的影响越小越好，那么\acode{mempty}
是个合理的选择，其被当做identity 幺半群值，例如\acode{""}，\acode{Sum 0}，或是空的 bytestring。当我们对
\acode{mempty}使用\acode{mappend}与其它幺半群结合，那么结果便是其它的幺半群值。因此当用\acode{return}来做一个
\acode{Writer}，再用\acode{>>=}喂给其它函数，那函数返回的便是计算后的幺半群。

\begin{lstlisting}[language=Haskell]
  ghci> runWriter (return 3 :: Writer String Int)
  (3,"")
  ghci> runWriter (return 3 :: Writer (Sum Int) Int)
  (3,Sum {getSum = 0})
  ghci> runWriter (return 3 :: Writer (Product Int) Int)
  (3,Product {getProduct = 1})
\end{lstlisting}

由于\acode{Writer}没有定义\acode{Show}的实例，那么就必须要\acode{runWriter}来讲\acode{Writer}转成正常的元组。

这里的\acode{Writer}实例并未定义\acode{fail}，因此模式匹配失败时便会调用\acode{error}。

\subsubsection*{使用 do 表示法与 Writer}

我们现在有了一个\acode{Monad}实例，那么就可以用\acode{do}表示法对\acode{Writer}值进行串联。下面例中所有的幺半群值
都会用\acode{mappend}连接起来并得到最后结果：

\begin{lstlisting}[language=Haskell]
  import Control.Monad.Trans.Writer

  logNumber :: Int -> Writer [String] Int
  logNumber x = writer (x, ["Got number: " ++ show x])

  multWithLog :: Writer [String] Int
  multWithLog = do
    a <- logNumber 3
    b <- logNumber 5
    return (a * b)
\end{lstlisting}

与原文不同在于\acode{import Control.Monad.Trans.Writer}。\acode{logNumber}接受一个数值将其变为\acode{Writer}值。
对于幺半群而言，我们使用字符串列表将数值附加为字符串后置入这个单例列表中。\acode{multWithLog}则是一个\acode{Writer}值，
将\acode{3}与\acode{5}相乘并将它们附带的日志包含进最后的日志中。这里使用了\acode{return}来展示作为返回的\acode{a*b}。
又因为\acode{return}仅仅是将某物置入一个最小 context 中，因此我们可以确保它不会添加任何东西进日志中。

\begin{lstlisting}[language=Haskell]
  ghci> runWriter multWithLog
  (15,["Got number: 3","Got number: 5"])
\end{lstlisting}

有时我们仅仅只是想将一些幺半群值在某些特定位置被包含。为此，\acode{tell}函数就很有用了。它是\acode{MonadWriter}
typeclass 中的一部分，它当做\acode{Writer}使用时也能接受一个幺半群值，例如\acode{["This is going on"]}。我们能用它把
幺半群值接到任何一个 dummy 值\acode{()}上来构成一个新的\acode{Writer}。当拿到的结果是\acode{()}时，不会将其绑定至一个
变量上。例如：

\begin{lstlisting}[language=Haskell]
  multWithLog :: Writer [String] Int
  multWithLog = do
    a <- logNumber 3
    b <- logNumber 5
    tell ["Gonna multiply these two"]
    return (a * b)
\end{lstlisting}

可得：

\begin{lstlisting}[language=Haskell]
  ghci> runWriter multWithLog
  (15,["Got number: 3","Got number: 5","Gonna multiply these two"])
\end{lstlisting}

\subsubsection*{添加日志至程序中}

欧几里德算法是计算两个数值的最大公约数，即可以被两数相除的最大值。Haskell 有一个\acode{gcd}函数，不过让我们实现一个自己的版本
并提供日志功能。下面是普通的算法：

\begin{lstlisting}[language=Haskell]
  gcd' :: Int -> Int -> Int
  gcd' a b
    | b == 0 = a
    | otherwise = gcd' b (a `mod` b)
\end{lstlisting}

首先检查第二个值是否为 0，如果是则返回第一个值；如果不是，那么第一个数除以第二个数的余数，再次与第二个数进行计算，以此类推。测试：

\begin{lstlisting}[language=Haskell]
  ghci> gcd' 8 3
  1
\end{lstlisting}

很好，那么与之前一样使用字符串列表作为我们的幺半群，用于存储日志。那么新版的\acode{gcd'}函数的类型则会是：

\begin{lstlisting}[language=Haskell]
  gcd' :: Int -> Int -> Writer [String] Int
  gcd' a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        gcd' b (a `mod` b)
\end{lstlisting}

新函数接受两个普通的\acode{Int}值并返回一个\acode{Writer [String] Int}，即一个包含了长日志 context 的\acode{Int}。
除开使用\acode{do}表达式，我们也可以这样写：

\begin{lstlisting}[language=Haskell]
  Writer (a, ["Finished with " ++ show a])
\end{lstlisting}

不过\acode{do}表达式更方便阅读。接下来测试一下\acode{gcd'}，其结果是\acode{Writer [String] Int}，如果从\acode{newtype}
提取出来则会是一个元组，而元组的第一部分则是结果：

\begin{lstlisting}[language=Haskell]
  ghci> fst $ runWriter (gcd' 8 3)
  1
\end{lstlisting}

至于日志，由于日志是一连串的字符串，那么就可以使用\acode{mapM_ putStrLn}将它们打印出来：

\begin{lstlisting}[language=Haskell]
  ghci> mapM_ putStrLn $ snd $ runWriter (gcd' 8 3)
  8 mod 3 = 2
  3 mod 2 = 1
  2 mod 1 = 0
  Finished with 1
\end{lstlisting}

把普通的算法转成拥有日志是很棒的经验，仅仅是把普通的值重写成 monadic 值，剩下的就是靠\acode{>>=}与\acode{Writer}来帮忙处理。
用这种方法我们几乎可以对任何函数加上日志的功能，只需要把普通的值转换成\acode{Writer}，然后把普通函数调用换成\acode{>>=}即可
（当然也可以使用\acode{do}）。

\subsubsection*{效率低的列表构造函数}

在使用\acode{Writer}单子的时候，你必须注意使用的幺半群，因为列表有时会变得非常的慢。这是因为列表的\acode{mappend}使用的是
\acode{++}，而\acode{++}在很长的列表尾部添加元素是非常慢的。

在我们的\acode{gcd'}函数中，日志很快是因为列表的追加是这样的：

\begin{lstlisting}[language=Haskell]
  a ++ (b ++ (c ++ (d ++ (e ++ f))))
\end{lstlisting}

列表是一种从左至右而构建的数据结构，它的高效是因为我们首先构建的是左边的部分，而把另一串列表加到右边的时候性能也不错。但是如果不小心
像是下面这样操作列表：

\begin{lstlisting}[language=Haskell]
  ((((a ++ b) ++ c) ++ d) ++ e) ++ f
\end{lstlisting}

这变成了左结合，而非右结合，这样效率非常低，因为每次都把右边的部分加到左边的部分，而左边的部分又必须要从头开始构建。

以下函数类似于\acode{gcd'}，只是日志的顺序是相反的，它先记录剩下的操作然后再记录当前的操作：

\begin{lstlisting}[language=Haskell]
  gcdReverse :: Int -> Int -> Writer [String] Int
  gcdReverse a b
    | b == 0 = do
        tell ["Finished with " ++ show a]
        return a
    | otherwise = do
        result <- gcdReverse b (a `mod` b)
        tell [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)]
        return result
\end{lstlisting}

它先递归调用，然后把结果绑定到\acode{result}，然后把当前操作记录到日志，在递归的结果之后，最后展示的是完整的日志：

\begin{lstlisting}[language=Haskell]
  ghci> mapM_ putStrLn $ snd $ runWriter (gcdReverse 8 3)
  Finished with 1
  2 mod 1 = 0
  3 mod 2 = 1
  8 mod 3 = 2
\end{lstlisting}

这样没有效率是因为它让\acode{++}成了左结合而不是右结合。

\subsubsection*{差异列表}

由于列表在重复追加的情况下效率低下，那么最好要用一种高效追加的数据结构。其中一种就是差异列表 difference lists，与普通列表类似，
而它接受一个列表并前置追加另一串列表。一个等价于\acode{[1,2,3]}的差异列表是这样一个函数\acode{\\xs -> [1,2,3] ++ xs}。
一个等价于\acode{[]}的差异列表则是\acode{\\xs -> [] ++ xs}。

差异列表最酷的地方在于它支持高效的尾部追加。普通列表下，当我们通过\acode{++}向列表追加另一个列表时，它必须要走到左边列表尾部，
然后把右边列表中的元素一个一个的接上。那么差异列表是怎么实现的呢？两个差异列表的追加像是这样：

\begin{lstlisting}[language=Haskell]
  f `append` g = \xs -> f (g xs)
\end{lstlisting}

\acode{f}与\acode{g}函数接受列表并前置追加。如果\acode{f}函数是\acode{("dog"++)}（另一种\acode{\\x -> "dog" ++ xs}
的写法）以及\acode{g}函数是\acode{("meat"++)}，那么\acode{f `append` g}构造的函数就等同于：

\begin{lstlisting}[language=Haskell]
  \xs -> "dog" ++ ("meat" ++ xs)
\end{lstlisting}

我们通过构建一个新函数先将一个列表喂给第一个差异列表，然后再把结果喂给第二个差异列表，这样的方式将两个差异列表进行了追加操作。

让我们创建一个\acode{newtype}包装差异列表，这样我们可以让它实现幺半群实例：

\begin{lstlisting}[language=Haskell]
  newtype DiffList a = DiffList { getDiffList :: [a] -> [a] }
\end{lstlisting}

包装中的类型是\acode{[a] -> [a]}，因为差异列表实际上就是个接受一个列表并返回另一个列表的函数。将普通列表转换成差异列表很简单，
反之亦然：

\begin{lstlisting}[language=Haskell]
  toDiffList :: [a] -> DiffList a
  toDiffList xs = DiffList (xs ++)

  fromDiffList :: DiffList a -> [a]
  fromDiffList (DiffList f) = f []
\end{lstlisting}

把一个普通列表转换成差异列表就是按照之前定义那样，实现一个前置追加至另一个列表的函数。由于差异列表只是一个前置追加的函数，那么将
差异列表转回普通列表只需要喂给它空列表即可。

以下是差异列表的\acode{Monoid}定义：

\begin{lstlisting}[language=Haskell]
instance Semigroup (DiffList a) where
  DiffList f <> DiffList g = DiffList (f . g)

instance Monoid (DiffList a) where
  mempty = DiffList ([] ++)
\end{lstlisting}

与原文不同在于现在需要先定义\acode{Semigroup}的实例（\acode{<>}函数的本质与\acode{Monoid}实例中的\acode{mappend}一致），
这样在\acode{Monoid}实例中便无需再次定义\acode{mappend}了。对于列表而言\acode{mempty}就是\acode{id}函数，而
\acode{mappend}则是函数组合。测试

\begin{lstlisting}[language=Haskell]
  ghci> fromDiffList (toDiffList [1,2,3,4] `mappend` toDiffList [1,2,3])
  [1,2,3,4,1,2,3]
\end{lstlisting}

顶级！现在可以提高我们\acode{gcdReverse}函数的效率了：

\begin{lstlisting}[language=Haskell]
  gcd' :: Int -> Int -> Writer (DiffList String) Int
  gcd' a b
    | b == 0 = do
        tell (toDiffList ["Finished with " ++ show a])
        return a
    | otherwise = do
        result <- gcd' b (a `mod` b)
        tell (toDiffList [show a ++ " mod " ++ show b ++ " = " ++ show (a `mod` b)])
        return result
\end{lstlisting}

我们只需把幺半群的类型从\acode{[String]}改为\acode{DiffList String}，并且在\acode{tell}时把普通列表用\acode{toDiffList}
转成差异列表即可。

\begin{lstlisting}[language=Haskell]
  ghci> mapM_ putStrLn . fromDiffList . snd . runWriter $ gcd' 110 34
  Finished with 2
  8 mod 2 = 0
  34 mod 8 = 2
  110 mod 34 = 8
\end{lstlisting}

用\acode{runWriter}取出\acode{gcdReverse 110 34}结果，用\acode{snd}取出日志，并用\acode{fromDiffList}转成普通列表
再打印出来。

\subsubsection*{性能比较}

% TODO

\end{document}
